<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在 Rust 中使用多个线程交替打印 ABC</title>
      <link href="/2025/04/dfd12c29.html"/>
      <url>/2025/04/dfd12c29.html</url>
      
        <content type="html"><![CDATA[<p>在我<a href="https://alrisha.cn/2024/02/81afead4.html">先前的文章</a>中，我通过 Java 实现了使用多个线程交替打印 ABC。刚好最近在学习 Rust，于是就来尝试一下如何它来解决这个简单的问题。</p><p>类似地，我通过原子变量和互斥锁两种实现方式来完成这个任务。Rust 的实现与 Java 相比在细节上有着更多需要注意的地方（即非常多坑点），但最后写完后还是让我不得不佩服 Rust 的设计理念。强大且规则严格的编译器虽然在写代码的时候有些痛苦，但比起黑盒的 GC 的确是更加让人安心，是一门真正能让代码苦手也能写出高质量代码的语言。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>下面直接贴出全部的代码，后续其它小节将对每个实现进行详细的分析。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX_LEN: <span class="type">usize</span> = <span class="number">12</span>; <span class="comment">// 最大输出次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 通过 `AtomicUsize` 实现交替打印目标字符串的能力</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">by_atomic</span>(raw_data: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(raw_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..len &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">status_clone</span> = status.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data_clone</span> = data.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        handle_vec.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> status_clone.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) % len != i &#123;</span><br><span class="line">                    std::hint::<span class="title function_ invoke__">spin_loop</span>(); <span class="comment">// 自旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进入临界区</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">s</span> = status_clone.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Val &#123;0:?&#125; Index &#123;1:?&#125;&quot;</span>, data_clone[s % len], s);</span><br><span class="line">                <span class="comment">// 离开临界区</span></span><br><span class="line">                status_clone.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 必须将最大循环次数减去线程数，才能保证最终打印的数量正确</span></span><br><span class="line">                <span class="comment">// 这是因为我们通过 `fetch_add` 自增操作来控制 `status`</span></span><br><span class="line">                <span class="keyword">if</span> s &gt;= MAX_LEN - len &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handle_vec &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">by_mutex</span>(raw_data: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(raw_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..len &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data_clone</span> = data.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">status_tup</span> = status.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        handle_vec.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> (mutex_clone, condvar_clone) = &amp;*status_tup;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = mutex_clone.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">while</span> *s % len != i &#123;</span><br><span class="line">                    s = condvar_clone.<span class="title function_ invoke__">wait</span>(s).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 阻塞</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进入临界区</span></span><br><span class="line">                <span class="keyword">if</span> *s &lt; MAX_LEN &#123;</span><br><span class="line">                    <span class="comment">// 需要判断 `status` 是否超出 `MAX_LEN`</span></span><br><span class="line">                    <span class="comment">// 因为 `status` 在最终依次销毁线程时一定会超出最大值，此时无需打印</span></span><br><span class="line">                    <span class="comment">// 每存在一个线程，`status` 最终值就将增加1</span></span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Val &#123;0:?&#125; Index &#123;1:?&#125;&quot;</span>, data_clone[*s % len], *s);</span><br><span class="line">                &#125;</span><br><span class="line">                *s += <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 离开临界区, 唤醒其他线程</span></span><br><span class="line">                condvar_clone.<span class="title function_ invoke__">notify_all</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> *s &gt;= MAX_LEN &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handle_vec &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Last status: &#123;0:?&#125;&quot;</span>, status.<span class="number">0</span>.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 打印 MAX_LEN + len - 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = <span class="built_in">vec!</span>[<span class="string">&quot;A&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;B&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;C&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line">    <span class="title function_ invoke__">by_atomic</span>(input.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">by_mutex</span>(input.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Val <span class="string">&quot;A&quot;</span> Index 0</span><br><span class="line">Val <span class="string">&quot;B&quot;</span> Index 1</span><br><span class="line">Val <span class="string">&quot;C&quot;</span> Index 2</span><br><span class="line">Val <span class="string">&quot;A&quot;</span> Index 3</span><br><span class="line">Val <span class="string">&quot;B&quot;</span> Index 4</span><br><span class="line">Val <span class="string">&quot;C&quot;</span> Index 5</span><br><span class="line">Val <span class="string">&quot;A&quot;</span> Index 6</span><br><span class="line">Val <span class="string">&quot;B&quot;</span> Index 7</span><br><span class="line">Val <span class="string">&quot;C&quot;</span> Index 8</span><br><span class="line">Val <span class="string">&quot;A&quot;</span> Index 9</span><br><span class="line">Val <span class="string">&quot;B&quot;</span> Index 10</span><br><span class="line">Val <span class="string">&quot;C&quot;</span> Index 11</span><br><span class="line">------------------------------------------</span><br><span class="line">Val <span class="string">&quot;A&quot;</span> Index 0</span><br><span class="line">Val <span class="string">&quot;B&quot;</span> Index 1</span><br><span class="line">Val <span class="string">&quot;C&quot;</span> Index 2</span><br><span class="line">Val <span class="string">&quot;A&quot;</span> Index 3</span><br><span class="line">Val <span class="string">&quot;B&quot;</span> Index 4</span><br><span class="line">Val <span class="string">&quot;C&quot;</span> Index 5</span><br><span class="line">Val <span class="string">&quot;A&quot;</span> Index 6</span><br><span class="line">Val <span class="string">&quot;B&quot;</span> Index 7</span><br><span class="line">Val <span class="string">&quot;C&quot;</span> Index 8</span><br><span class="line">Val <span class="string">&quot;A&quot;</span> Index 9</span><br><span class="line">Val <span class="string">&quot;B&quot;</span> Index 10</span><br><span class="line">Val <span class="string">&quot;C&quot;</span> Index 11</span><br><span class="line">Last status: 14</span><br></pre></td></tr></table></figure><h1 id="原子操作实现"><a href="#原子操作实现" class="headerlink" title="原子操作实现"></a>原子操作实现</h1><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">by_atomic</span>(raw_data: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(raw_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..len &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">status_clone</span> = status.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data_clone</span> = data.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        handle_vec.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> status_clone.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) % len != i &#123;</span><br><span class="line">                    std::hint::<span class="title function_ invoke__">spin_loop</span>(); <span class="comment">// 自旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进入临界区</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">s</span> = status_clone.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Val &#123;0:?&#125; Index &#123;1:?&#125;&quot;</span>, data_clone[s % len], s);</span><br><span class="line">                <span class="comment">// 离开临界区</span></span><br><span class="line">                status_clone.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 必须将最大循环次数减去线程数，才能保证最终打印的数量正确</span></span><br><span class="line">                <span class="comment">// 这是因为我们通过 `fetch_add` 自增操作来控制 `status`</span></span><br><span class="line">                <span class="keyword">if</span> s &gt;= MAX_LEN - len &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handle_vec &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们通过原子化引用计数智能指针 <code>Arc</code> 来共享输入数据和原子状态变量 <code>status</code>。同时需要保存每个线程的句柄到 <code>handle_vec</code> 中，以便在最后等待所有线程结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(raw_data);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">status</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure><p>我们需要创建 <code>len</code> 个线程，<code>len</code> 是字符串数组的长度，每个线程都负责打印一个字符。对每一个线程，我们都需要赋予其输入数据和状态变量的所有权。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..len &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status_clone</span> = status.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_clone</span> = data.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    handle_vec.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个线程，我们需要一个无限循环来确保线程持续地打印字符。通过原子变量 <code>status_clone</code> 和自旋锁 <code>std::hint::spin_loop()</code> 来保证输出顺序，当前不应输出的线程将一直处于自旋状态直到 <code>status</code> 的值满足条件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> status_clone.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) % len != i &#123;</span><br><span class="line">        std::hint::<span class="title function_ invoke__">spin_loop</span>(); <span class="comment">// 自旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = status_clone.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Val &#123;0:?&#125; Index &#123;1:?&#125;&quot;</span>, data_clone[s % len], s);</span><br><span class="line">    <span class="comment">// 离开临界区</span></span><br><span class="line">    status_clone.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须将最大循环次数减去线程数，才能保证最终打印的数量正确</span></span><br><span class="line">    <span class="comment">// 这是因为我们通过 `fetch_add` 自增操作来控制 `status`</span></span><br><span class="line">    <span class="comment">// 在最后一轮循环中，`status` 将会超出最大值，此时无需打印直接退出即可</span></span><br><span class="line">    <span class="keyword">if</span> s &gt;= MAX_LEN - len &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个非常容易忽略的点是，如果将</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = status_clone.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Val &#123;0:?&#125; Index &#123;1:?&#125;&quot;</span>, data_clone[s % len], s);</span><br><span class="line">status_clone.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br></pre></td></tr></table></figure><p>改为下述两行代码，尽管<code>status_clone</code>的值在两种情况下都是相同的，但下述代码将无法保证打印的顺序执行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = status_clone.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Val &#123;0:?&#125; Index &#123;1:?&#125;&quot;</span>, data_clone[s % len], s);</span><br></pre></td></tr></table></figure><p>这是因为 <code>status</code> 的值一旦修改，就表示脱离了临界区,此时无法保证该线程能按预期顺序立即打印字母，即 <code>status</code> 可以看作一个互斥锁，脱离 <code>spin_loop()</code> 自旋表示获取锁，状态 <strong>改变</strong> 表示释放锁。</p><h1 id="互斥锁实现"><a href="#互斥锁实现" class="headerlink" title="互斥锁实现"></a>互斥锁实现</h1><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">by_mutex</span>(raw_data: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(raw_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..len &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data_clone</span> = data.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">status_tup</span> = status.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        handle_vec.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> (mutex_clone, condvar_clone) = &amp;*status_tup;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = mutex_clone.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">while</span> *s % len != i &#123;</span><br><span class="line">                    s = condvar_clone.<span class="title function_ invoke__">wait</span>(s).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 阻塞</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进入临界区</span></span><br><span class="line">                <span class="keyword">if</span> *s &lt; MAX_LEN &#123;</span><br><span class="line">                    <span class="comment">// 需要判断 `status` 是否超出 `MAX_LEN`</span></span><br><span class="line">                    <span class="comment">// 因为 `status` 在最终依次销毁线程时一定会超出最大值，此时无需打印</span></span><br><span class="line">                    <span class="comment">// 每存在一个线程，`status` 最终值就将增加1</span></span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Val &#123;0:?&#125; Index &#123;1:?&#125;&quot;</span>, data_clone[*s % len], *s);</span><br><span class="line">                &#125;</span><br><span class="line">                *s += <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 离开临界区, 唤醒其他线程</span></span><br><span class="line">                condvar_clone.<span class="title function_ invoke__">notify_all</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> *s &gt;= MAX_LEN &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handle_vec &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Last status: &#123;0:?&#125;&quot;</span>, status.<span class="number">0</span>.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 打印 MAX_LEN + len - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在互斥锁实现中，我使用了 <code>Mutex</code> 和 <code>Condvar</code> 来实现线程间的同步。<code>Mutex</code> 用于保护共享数据的访问，而 <code>Condvar</code> 用于在条件不满足时阻塞线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(raw_data);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = data.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">status</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..len &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_clone</span> = data.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">status_tup</span> = status.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    handle_vec.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于互斥锁和状态变量元组，应当通过解引用再取地址的方式来获取其值。否则编译器无法推断元组内数据的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (mutex_clone, condvar_clone) = &amp;*status_tup;</span><br></pre></td></tr></table></figure><p>类似地，我们可以通过无限循环字符的持续打印。互斥锁的使用和原子变量非常类似，不同的是在满足阻塞条件时，不使用自旋而是使用基于 <code>Condvar</code> 的阻塞方式。没有获取锁的线程将一直阻塞直到其他线程通过 <code>notify_all()</code> 唤醒。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = mutex_clone.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">while</span> *s % len != i &#123;</span><br><span class="line">        s = condvar_clone.<span class="title function_ invoke__">wait</span>(s).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">    <span class="keyword">if</span> *s &lt; MAX_LEN &#123;</span><br><span class="line">        <span class="comment">// 需要判断 `status` 是否超出 `MAX_LEN`</span></span><br><span class="line">        <span class="comment">// 因为 `status` 在最终依次销毁线程时一定会超出最大值，此时无需打印</span></span><br><span class="line">        <span class="comment">// 每存在一个线程，`status` 最终值就将增加1（相对 MAX_LEN）</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Val &#123;0:?&#125; Index &#123;1:?&#125;&quot;</span>, data_clone[*s % len], *s);</span><br><span class="line">    &#125;</span><br><span class="line">    *s += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 离开临界区, 唤醒其他线程</span></span><br><span class="line">    condvar_clone.<span class="title function_ invoke__">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> *s &gt;= MAX_LEN &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和原子操作实现的不同点在于，我们需要在打印完字符后，<strong>首先</strong> 判断 <code>status</code> 是否超出最大值 <code>MAX_LEN</code>。因为原子操作中进入临界区的条件基于原子变量数值的大小，而在互斥锁实现中进入临界区则是由 <code>Condvar</code> 来控制的。</p><p>可以在函数最后打印 <code>Mutex</code> 的值来看看最终的 <code>status</code> 是多少。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> Lock </tag>
            
            <tag> Rust </tag>
            
            <tag> Atomic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用计数 GC 算法：为什么都用上 Python 了还要手动关闭对象？</title>
      <link href="/2025/02/6339ab96.html"/>
      <url>/2025/02/6339ab96.html</url>
      
        <content type="html"><![CDATA[<p>和 Java 不同，引用计数是 Python <strong>主要</strong>的垃圾回收算法（下文均指 CPython 解释器）。需要首先明确的是，包括 Python 在内的任何高级语言的垃圾回收机制都是非常复杂的，实际上，Python 的垃圾回收也包含了分代机制等复杂的概念，本文只关注引用计数这方面的内容。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>引用计数 GC 算法，简单来说，就是当一个对象被引用的次数为 0 时，才进行回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = A() <span class="comment"># 对象 A 实例被局部变量 a 引用，引用计数为 1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">b = func() <span class="comment"># 对象 A 实例被全局变量 b 引用，引用计数为 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alrisha@Pisces:~/code/python$ python script.py</span><br><span class="line">Object created</span><br><span class="line">exit</span><br><span class="line">Object deleted</span><br></pre></td></tr></table></figure><p>注意到由于 Python 全局变量的作用域，对象 A 的实例最终在程序结束时才被删除。</p><p>引用计数算法有非常多的优点，其占用内存空间小，而由于计数为 0 时即可触发 GC，因此也几乎没有时间上的停顿（几乎没有 STW，Stop the World），而其本身实现也非常容易。但是，它相对于基于 GC Root 的可达性算法（如 JVM）有一个致命缺陷，那就是难以处理循环引用。实际上，Python 引入分代机制的原因之一就是为了解决循环引用的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj = <span class="literal">None</span></span>):</span><br><span class="line">        self.ptr = obj</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object A created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object A deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj = <span class="literal">None</span></span>):</span><br><span class="line">        self.ptr = obj</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object B created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object B deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">a.ptr = b</span><br><span class="line">b.ptr = a</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alrisha@Pisces:~/code/python$ python script.py</span><br><span class="line">Object A created</span><br><span class="line">Object B created</span><br><span class="line">exit</span><br><span class="line">Object A deleted</span><br><span class="line">Object B deleted</span><br></pre></td></tr></table></figure><p>可以看到，由于存在循环引用，即使我们手动删除了对象 A 的引用，它依然没有被回收。</p><p>当然，在小的 Python 项目中，可能无需关注这些细节，因为 Python 的垃圾回收机制最终几乎总是能处理类似的问题。但当遇到占用内存较大的项目并且存在硬件限制的场景时，循环引用带来的问题甚至可能类似于内存泄漏。由于每轮 GC 必定存在时间间隔，在两次 GC 间隔之间有可能存在非常多的循环引用对象，从而引发 OOM。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="弱引用（不推荐）"><a href="#弱引用（不推荐）" class="headerlink" title="弱引用（不推荐）"></a>弱引用（不推荐）</h2><p>弱引用是解决引用计数法中循环引用问题的一种方法，比较出名的例子就是 C++ 的智能指针。Python 提供了 <code>weakref</code> 模块来实现弱引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj = <span class="literal">None</span></span>):</span><br><span class="line">        self.ptr = obj</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object A created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object A deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj = <span class="literal">None</span></span>):</span><br><span class="line">        self.ptr = obj</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object B created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object B deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">a.ptr = weakref.ref(b)</span><br><span class="line">b.ptr = weakref.ref(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alrisha@Pisces:~/code/python$ python script.py</span><br><span class="line">Object A created</span><br><span class="line">Object B created</span><br><span class="line">Object A deleted</span><br><span class="line">exit</span><br><span class="line">Object B deleted</span><br></pre></td></tr></table></figure><p>我们可以认为，<strong>Python 的引用计数器仅记录强引用对象而不记录弱引用对象</strong>，因此恰当地使用弱引用能够很好地解决循环引用问题。</p><p>然而，我<strong>不推荐</strong>在 Python 中使用弱引用来解决循环引用问题。</p><ul><li>首先，Python 弱引用所使用的装饰器模式 API 在开发中添加了额外的复杂度。</li><li>其次，我认为 Python 中的弱引用，相当于开发者将对象所有权完全交给了 Python 解释器。这使得对象的生命周期完全不可控（在没有 GC 的 C++中这一点没那么明显）。</li><li>最后，使用弱引用也给开发者带来不小的心智压力，开发者必须时刻注意弱引用对象的判空，甚至会徒增很多不必要的代码量。</li></ul><p>一般来说，<strong>弱引用的应用场景在存在相互引用的父子对象之间，即父对象存储子对象的强引用，而子对象存储父对象的弱引用。</strong>当父对象被回收时，子对象中的弱引用也会被设置为 <code>None</code>；而子对象的回收却不会影响父对象的生命周期。</p><h2 id="手动关闭对象"><a href="#手动关闭对象" class="headerlink" title="手动关闭对象"></a>手动关闭对象</h2><p>传统的方法可能才是最好的选择。面对循环引用手动清理对象引用无疑是最直观有效的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj=<span class="literal">None</span></span>):</span><br><span class="line">        self.ptr = obj</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object A created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finish</span>(<span class="params">self</span>):</span><br><span class="line">        self.ptr = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ptr = <span class="literal">None</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object A deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj=<span class="literal">None</span></span>):</span><br><span class="line">        self.ptr = obj</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object B created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finish</span>(<span class="params">self</span>):</span><br><span class="line">        self.ptr = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object B deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">a.ptr = b</span><br><span class="line">b.ptr = a</span><br><span class="line"></span><br><span class="line">a.finish()</span><br><span class="line">b.finish()</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alrisha@Pisces:~/code/python$ python script.py</span><br><span class="line">Object A created</span><br><span class="line">Object B created</span><br><span class="line">Object A deleted</span><br><span class="line">exit</span><br><span class="line">Object B deleted</span><br></pre></td></tr></table></figure><p>那这里大伙就要问了，既然要手动关闭对象，那我还用 Python 干嘛呢？这不脱裤子放屁嘛？</p><p>对于脚本和科研用途来说，确实，这些 GC 上的细节无需特地在意。但对于希望使用 Python 进行大规模工程开发的人来说，这些问题还是非常关键的。另外，上边这个例子还是不够 Pythonic ，我们完全可以用 <code>with</code> 语法糖，通过 Python 类的上下文管理器来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj=<span class="literal">None</span></span>):</span><br><span class="line">        self.ptr = obj</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object A created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        self.ptr = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object A deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj=<span class="literal">None</span></span>):</span><br><span class="line">        self.ptr = obj</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object B created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        self.ptr = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Object B deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> a:</span><br><span class="line">    a.ptr = b</span><br><span class="line"><span class="keyword">with</span> b:</span><br><span class="line">    b.ptr = a</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alrisha@Pisces:~/code/python$ python script.py</span><br><span class="line">Object A created</span><br><span class="line">Object B created</span><br><span class="line">Object A deleted</span><br><span class="line">exit</span><br><span class="line">Object B deleted</span><br></pre></td></tr></table></figure><p>所以说，如果希望通过 Python 进行大规模工程开发，还是需要对 Python 的 GC 机制有一定的了解，多用 <code>with</code> 来关联对象的上下文。不要因为 Python 看起来简单而轻视其中的工程细节。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 2024 年</title>
      <link href="/2024/12/6e63371d.html"/>
      <url>/2024/12/6e63371d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>三个词总结我的 2024，大概就是 <strong>工作</strong>、<strong>论文</strong>和<strong>白忙活</strong></p></blockquote><p>很快就来到我第三个年终总结了，其实前几天我还在思考到底要不要按时写，因为看似有很多要说，但就像今年的关键词里说的一样，到头来也是白忙活 🤦‍。但是好不容易坚持下来了，还是坚持写写吧，一旦断更就不知道是不是还有下次了。</p><p>对我来说，2024 年全年的趋势，可以说是<strong>欲抑先扬</strong>。各位也可以发现我从 7 月份开始就暂停更新我的博客了，除了没有时间，实际上也是没有内容。秋招、中期、论文、专利，不仅让我不停内耗，实际上没有一个给我带来正反馈，至少在下半年是如此。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>年初的时候，我在找暑期实习的过程可以说是我今年过的最顺利的一段时间，具体内容各位可以参考我<a href="https://alrisha.cn/2024/05/97feaabb.html">这篇博客</a>。实际上，我在阿里云的暑期实习体验也很好，nice 的团队、风口的项目、坚实的公司背书，但也可能正是这些体验让我在秋招时迎来了较大的心理落差。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/12/31/syQbDYFzfmcShni.jpg" alt="阿里云谷园区门口"></p><p>BAT 和互联网的一众大厂我在秋招时基本都投过了简历，也基本都通过了面试，但最后的结果却都让我不是非常满意。在整个 24 年阿里云实习生比赛中拿了第三名，但转正一看待遇比不上身边任何一个人，我确实无话可说。必须承认，只有真正在找工作的时候，才能认识到自己的普通。</p><p>不过我现在发现，一个人绝大多数的痛苦和内耗实际上都来源于<strong>比较</strong>，并且人类这种生物总是喜欢向上比较，我称之为 <em>刻在 DNA 里的慕强</em> 。只能说可惜我是初出茅庐，暂未磨练出宠辱不惊的心性。</p><p>目前秋招已经算是告一段落了，但是有了前车之鉴，我不会再提前开香槟。等到我明年毕业，可能会来个毕业总结的特别篇吧，包括秋招的过程结果和一些面经。</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>论文这部分单独拿出来说其实也没有什么内容，但我还是想啰嗦这一大段，不吐不快。</p><p>前一年我提到，我深陷项目的痛苦中无法自拔（<a href="https://alrisha.cn/2023/12/dc43eb0d.html">见此</a>）。如此大的沉没成本，让我只能往这个项目的狭窄科研方向硬着头皮走下去。实际上，这也导致了我科研产出的捉襟见肘，中期险些挂球。</p><p>当然，离开 Z 老师阴影后其实实验室给我的压力已经几乎没有了，剩下的全是我自己压力自己：超窄研究方向拿不出成果 &#x3D;&gt; 拿不出成果答辩过不了 &#x3D;&gt; 答辩过不了毕不了业 &#x3D;&gt; 毕不了业没工作 &#x3D;&gt; 没工作只能路边吃土 …</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/12/31/tODGKdNz7U39M5j.jpg" alt="纯牛马"></p><p>嗯，内耗的具象化表现。</p><h2 id="忙活"><a href="#忙活" class="headerlink" title="忙活"></a>忙活</h2><p>是的，我没有打错，我认为如果在单独写一段<strong>白忙活</strong>的章节，整篇博文的氛围就太阴暗压抑了。大伙忙着跨年呢，扫什么兴呢 🤯？</p><p>从结果上看，确实，我今年做的很多事都是白忙活，但不能因为这样下一年就不再“忙活”了。不知道是什么结果才有努力的动力不是嘛？看人家公务员，固定年限升值加薪，结果大部分是尸位素餐；再看看我们程序员，朝不保夕，要么升职加薪，要么就是在被裁的路上，但对社会生产力和社会价值的贡献顶的上不知道多少公务员。我这个人可能天性就喜欢忙活，而且我觉得这挺好的。</p><p>并且一个小小硕士研究生实际上也不是那么忙，今年的游戏仍然还是占据我很大一部分时间。最近在玩 <a href="https://store.steampowered.com/agecheck/app/553850/">HELLDIVERS 2</a> ，非常有意思，已经沉迷其中了 😄。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/12/31/74mBLGuZJjlAvYQ.png" alt="Steam 2024 回顾"></p><h2 id="2025"><a href="#2025" class="headerlink" title="2025?"></a>2025?</h2><p>然后，转眼就到了 2024 年的最后一天。</p><p>如上文所述，我就不再对新年做什么别的期待了。期待越低，幸福感越高。拿我阿里云师兄在我拒绝 Offer 后对我说的话做结尾吧：<code>做什么选择都是对的，别太纠结</code></p><blockquote><p><strong>最后，祝看到这篇文章的朋友们 2025 新年快乐！</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Working </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当容量不是 2 的幂次方时，HashMap 是怎么处理的</title>
      <link href="/2024/07/a9f8b857.html"/>
      <url>/2024/07/a9f8b857.html</url>
      
        <content type="html"><![CDATA[<p>在 HashMap 中，<code>table</code> 容量初始值为 16 。且每次插入新元素后，如果需要扩容，都是通过 <code>&lt;&lt; 1</code> 运算将容量乘以 2。那么什么时候会出现容量可能不是 2 的幂次方的情况呢？</p><ol><li>通过 <code>putAll</code> 方法将一个 Map 的所有元素添加到另一个 Map 中。这时 HashMap 的容量不仅很大概率不是 2 的幂次方，而且不一定能够通过一次 <code>&lt;&lt; 1</code> 运算得到合适的容量。例如，原始 Map 容量为 4，添加的 Map 容量为 8，那么扩容后容量 $table.length &#x3D; 4 &lt;&lt; 1 &#x3D; 8$，而需要的容量为 12，远不能满足需求。</li><li>通过 IO 流反序列化 HashMap 。基本问题和 <code>putAll</code> 一样，都是一次左移无法满足需求</li></ol><p>那么 HashMap 就应该设计一个算法，计算这种一次左移无法得到的容量大小。这个问题换句话来说，就是：</p><blockquote><p>给定一个 int 类型的整数 n，如何求出不小于它的最接近的 2 的整数幂 m，比如给定 10 得出 16，给定 25 得出 32？</p></blockquote><p>直观地，我们会想到通过对数换底公式 $log_a(b) &#x3D; \frac{log_c(b)}{log_c(a)}$ 来计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">m</span> <span class="operator">=</span> Math.log(n) / Math.log(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> (<span class="type">int</span>) Math.ceil(m);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管能够正确地解决问题，我们还是可以直观地感觉到以上方法效率很低，因为涉及到许多高层方法和浮点运算。而在源码中，HashMap 作者则通过 <code>tableSizeFor</code> 方法巧妙高效地解决了这个问题。</p><h1 id="JDK-8-的处理方法"><a href="#JDK-8-的处理方法" class="headerlink" title="JDK 8 的处理方法"></a>JDK 8 的处理方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章 <a href="https://www.cnblogs.com/xiyixiaodao/p/14483876.html">HashMap 之 tableSizeFor 方法图解</a> 已经很好地讲解了这个函数的原理，这里我就不再赘述了。</p><h1 id="JDK-21-的处理方法"><a href="#JDK-21-的处理方法" class="headerlink" title="JDK 21 的处理方法"></a>JDK 21 的处理方法</h1><p>目前对 JDK 21 的源码解析比较少，让我们直接看看 <code>tableSizeFor</code> 在 JDK 21 中是怎么实现的吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Integer-numberOfLeadingZeros"><a href="#Integer-numberOfLeadingZeros" class="headerlink" title="Integer.numberOfLeadingZeros()"></a>Integer.numberOfLeadingZeros()</h2><p>看来具体的实现过程发生了很大的变化，中间的许多位移运算被归纳为了 <code>Integer.numberOfLeadingZeros</code> ，这其实是一个 JDK 1.5 引入的方法，用于计算一个整数的二进制表示中前导 0 的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of zero bits preceding the highest-order</span></span><br><span class="line"><span class="comment"> * (&quot;leftmost&quot;) one-bit in the two&#x27;s complement binary representation</span></span><br><span class="line"><span class="comment"> * of the specified &#123;<span class="doctag">@code</span> int&#125; value.  Returns 32 if the</span></span><br><span class="line"><span class="comment"> * specified value has no one-bits in its two&#x27;s complement representation,</span></span><br><span class="line"><span class="comment"> * in other words if it is equal to zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that this method is closely related to the logarithm base 2.</span></span><br><span class="line"><span class="comment"> * For all positive &#123;<span class="doctag">@code</span> int&#125; values x:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;floor(log&lt;sub&gt;2&lt;/sub&gt;(x)) = &#123;<span class="doctag">@code</span> 31 - numberOfLeadingZeros(x)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ceil(log&lt;sub&gt;2&lt;/sub&gt;(x)) = &#123;<span class="doctag">@code</span> 32 - numberOfLeadingZeros(x - 1)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the value whose number of leading zeros is to be computed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of zero bits preceding the highest-order</span></span><br><span class="line"><span class="comment"> *     (&quot;leftmost&quot;) one-bit in the two&#x27;s complement binary representation</span></span><br><span class="line"><span class="comment"> *     of the specified &#123;<span class="doctag">@code</span> int&#125; value, or 32 if the value</span></span><br><span class="line"><span class="comment"> *     is equal to zero.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Count leading 0&#x27;s</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我简单地解释一下 <code>numberOfLeadingZeros()</code> 的原理。我们拿一个 int 类型的整数 <code>i</code> 为例子，其的二进制表示是 <code>i = 0b 0000 0000 1011 1100 1011 1101 1010 1011</code> ，这个值大于 $2^{16}$，前导 0 个数为 8。</p><ol><li>首先，如果 <code>i</code> 等于 0 ，那么 <code>i</code> 的二进制表示中没有 1 ，直接返回 32；如果 <code>i</code> 小于等于 0 ，那么 <code>i</code> 的二进制表示中最高位是 1 ，直接返回 0；否则，继续执行下面的步骤。</li><li>初始化变量 <code>n = 31</code></li><li>如果 <code>i</code> 大于等于 $2^{16}$ ，那么 <code>n</code> 减去 16 ，<code>i</code> 右移 16 位。我们的例子符合这个条件。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n - 16 = 31 - 16 = 15</span><br><span class="line">i &gt;&gt;&gt; 16 = 0b 0000 0000 0000 0000 0000 0000 1011 1100</span><br></pre></td></tr></table></figure></li><li>如果 <code>i</code> 大于等于 $2^8$ ，那么 <code>n</code> 减去 8 ，<code>i</code> 右移 8 位。由于现在 <code>i = 0b 1011 1100 &lt; 0b 0001 0000 0000</code> ，不符合条件。</li><li>如果 <code>i</code> 大于等于 $2^4$ ，那么 <code>n</code> 减去 4 ，<code>i</code> 右移 4 位。而 <code>i = 0b 1011 1100 &gt; 0b 0001 0000</code> ，符合条件。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n - 4 = 15 - 4 = 11</span><br><span class="line">i &gt;&gt;&gt; 4 = 0b 0000 0000 0000 0000 0000 0000 0000 1011</span><br></pre></td></tr></table></figure></li><li>如果 <code>i</code> 大于等于 $2^2$ ，那么 <code>n</code> 减去 2 ，<code>i</code> 右移 2 位。而 <code>i = 0b 0000 1011 &gt; 0b 0000 0010</code> ，符合条件。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n - 2 = 11 - 2 = 9</span><br><span class="line">i &gt;&gt;&gt; 2 = 0b 0000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure></li><li>最后，返回 <code>n - (i &gt;&gt;&gt; 1)</code> ，即 <code>9 - 1 = 8</code> 。 <strong>8</strong> 即为 <code>i</code> 的二进制表示中前导 0 的个数。</li></ol><p>看过这段计算后，你应该已经看出，<code>numberOfLeadingZeros</code> 的计算过程其实就是通过 <strong>二分位移</strong> 来快速地在确定的几次位移运算之内，计算出一个整数的二进制表示中前导 0 的个数。其二分计算的思想实际上和 JDK 8 中类似，但在 JDK 21 中只是复用了这个 <code>Integer</code> 类的静态方法，免于重复造轮子，也省去了学习成本。</p><h2 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor()"></a>tableSizeFor()</h2><p>这时你肯定要说，不对啊，只是得到了前导 0 的个数，怎么就能得到最接近的 2 的整数幂了呢？接下来我们回到 <code>tableSizeFor</code> 方法看看代码。</p><p>我们详细讲讲 <code>int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1)</code> 这一行代码。</p><ol><li>对于输入的任意容量 <code>cap</code> ，我们首先减去 1 ，得到 <code>cap - 1</code> 。稍后解释这样做的原因。</li><li>计算 <code>cap - 1</code> 的前导 0 的个数，我们假设前导 0 的个数是 <code>k</code> 。</li><li>将 <code>-1</code> 无符号右移，得到一个前 <code>k</code> 位为 0，其余位为 1 的数。<blockquote><p>这一步是怎么得到的呢？<br>首先我们需要知道，<code>-1</code> 的二进制表示是 <code>0b 1111 1111 1111 1111 1111 1111 1111 1111</code> 。<br>且 <code>&gt;&gt;&gt;</code> 在 Java 中是 <strong>无符号</strong> 右移。<br>因此右移 <code>k</code> 位后，前 <code>k</code> 位都是 0 ，其余位都是 1 。<br>假设 <code>k = 8</code> ，那么右移后的结果是 <code>0b 0000 0000 1111 1111 1111 1111 1111 1111</code> 。</p></blockquote></li></ol><p>在计算完 <code>n</code> 之后，我们看到 <code>return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1</code> 直接返回了 <code>n + 1</code> 。</p><p>实际上这就能解释为什么我们在计算前导 0 的个数时，要先减去 1 了。我们首先要明确的是，<code>tableSizeFor</code> 方法的目的是得到一个不小于 <code>cap</code> 的最接近的 2 的整数幂，而一个 2 的整数幂必然在其二进制的某一位为 1 ，其他位为 0。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 = 0b 0000 0000 0000 0000 0000 0000 0000 0010</span><br><span class="line">4 = 0b 0000 0000 0000 0000 0000 0000 0000 0100</span><br><span class="line">8 = 0b 0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">16 = 0b 0000 0000 0000 0000 0000 0000 0001 0000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 Java 中，获取一个特定位以下全 1 的数，计算是较为便捷的（通过上文所示方法）。那么，我们先通过 <code>cap - 1</code> 得到一个特定位以下全 1 的数 <code>n</code>，最后再将这个 1 加回来，就能直接得到我们想要的一个值为 2 的整数幂的数了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 假设 cap = 10</span><br><span class="line">cap = 0b 0000 0000 0000 0000 0000 0000 0000 1010</span><br><span class="line">cap - 1 = 0b 0000 0000 0000 0000 0000 0000 0000 1001</span><br><span class="line"></span><br><span class="line">n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1)</span><br><span class="line">  = -1 &gt;&gt;&gt; 28</span><br><span class="line">  = 0b 1111 1111 1111 1111 1111 1111 1111 1111 &gt;&gt;&gt; 28</span><br><span class="line">  = 0b 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line"></span><br><span class="line">n + 1 = 0b 0000 0000 0000 0000 0000 0000 0001 0000</span><br><span class="line">      = 16</span><br><span class="line">// 16 是不小于 10 的最接近的 2 的整数幂，因此 HashMap 的 table 接下来应当扩容的到 16</span><br></pre></td></tr></table></figure><blockquote><p>本文参考文章：</p><ul><li><a href="https://www.cnblogs.com/xiyixiaodao/p/14483876.html">HashMap 之 tableSizeFor 方法图解</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析 HashMap 的哈希算法</title>
      <link href="/2024/07/a2b435f4.html"/>
      <url>/2024/07/a2b435f4.html</url>
      
        <content type="html"><![CDATA[<p>HashMap 是 Java 中常用的一种数据结构，它实现了 Map 接口，用于存储键值对。HashMap 的底层实现原理是数组和链表&#x2F;红黑树，通过哈希函数将键映射到数组中的某个位置，如果位置上已经有元素，则使用链表进行存储。</p><p>HashMap 的扩容机制是 HashMap 中的重要的算法，它通过调整 HashMap 的容量来控制 HashMap 的大小，以减少空间浪费和提高查询效率。一般来说，每次扩容，HashMap 存储链表&#x2F;红黑树的数组的长度都会变为 2 倍。在 HashMap 实现中，这个数组是一个成员变量 <code>table</code>。</p><p>为什么要这么设计？我们首先要知道一个好的 Hash 函数至少应该满足什么条件：</p><ol><li><strong>均匀分布</strong> ：经过哈希函数的计算，每个元素应该尽可能均匀地分布到数组中。具体地说，要保证每个 <code>table</code> 下标都有可能命中</li><li><strong>快速计算</strong> ：哈希函数的计算应该尽可能高效</li><li><strong>离散分布</strong> ：哈希函数的计算结果应该尽可能的离散，减少碰撞。具体地说，要保证每个 <code>table</code> 下标中的元素数量都差不多</li></ol><p>带着这些条件，我们看看 Java 的 HashMap 具体是怎么实现的。 <em>以下源码来自 JDK 21。</em></p><h1 id="深入源码看看-HashMap-的-put-方法"><a href="#深入源码看看-HashMap-的-put-方法" class="headerlink" title="深入源码看看 HashMap 的 put 方法"></a>深入源码看看 HashMap 的 put 方法</h1><p>我们知道，只有往 HashMap 中添加元素，才会触发扩容机制。因此我们需要从 <code>put</code> 方法出发，看看它具体做了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &#123;<span class="doctag">@code</span> key&#125;, or</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> null&#125; if there was no mapping for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment"> *         (A &#123;<span class="doctag">@code</span> null&#125; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &#123;<span class="doctag">@code</span> null&#125; with &#123;<span class="doctag">@code</span> key&#125;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来 <code>put</code> 和 <code>putIfAbsent</code> 等方法底层都是调用了 <code>putVal</code> 这个方法，那我们先跳过 <code>hash()</code> 这个方法，继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果 table 为空，或者 table 的长度为 0，那么就需要进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果当前 table 中 i 位置为空，直接插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这段代码 <code>i = (n - 1) &amp; hash</code> ，这里是计算元素在 <code>table</code> 数组中的位置，<code>n</code> 是 <code>table</code> 数组的长度。</p><h1 id="为什么是-2-的幂次方？"><a href="#为什么是-2-的幂次方？" class="headerlink" title="为什么是 2 的幂次方？"></a>为什么是 2 的幂次方？</h1><p>我们知道，<code>table</code> 数组的长度是 2 的幂次方。这里的 <code>(n - 1) &amp; hash</code> 是为了保证计算出来的位置在数组的范围内，也就是说，<code>i = (n - 1) &amp; hash</code> <strong>等价于</strong> <code>i = hash % n</code> 。</p><p>前面我们说过， <strong>均匀分布</strong> 是一个好的哈希函数的特点。这就要求我们每次通过 hash 计算出来的下标要尽可能的覆盖到整个数组，不能超出数组的范围。那么最直观的方式就是直接取模 <code>i = hash % n</code>。但是在计算机中，取模运算是比较耗时的，这不符合 <strong>快速计算</strong> 这一 hash 函数要求；而相对应的，位移运算可以说是效率最高的运算方式之一了。</p><p>如果我们以 <code>table</code> 数组的长度 <code>n</code> 是 2 的幂次方为前提，那么 <code>(n - 1) &amp; hash</code> 就相当于 <code>hash % n</code>，我举个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// hash 指是 int 类型，因此有 32 位，我们假设下方是我们待计算的 hash 值</span><br><span class="line">h = 0b 1101 1010 1011 1100 1011 1101 1010 1011</span><br><span class="line"></span><br><span class="line">// 假设 table 的长度是 16，即 n = 16，那么</span><br><span class="line">n = 0b 0000 0000 0000 0000 0000 0000 0001 0000</span><br><span class="line"></span><br><span class="line">// 如果直接计算 hash % n，那么其余数显然只和后 4 位有关，即</span><br><span class="line">i = h % n = 0b 0000 0000 0000 0000 0000 0000 0000 1011</span><br><span class="line"></span><br><span class="line">// 我们再来看看 n - 1 的二进制表示，它将后面的数位全部置为 1，即</span><br><span class="line">n - 1 = 15 = 0b 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line"></span><br><span class="line">// 这就能很容易看出，(n - 1) &amp; hash 就相当于 hash % n，即</span><br><span class="line">h = 0b 1101 1010 1011 1100 1011 1101 1010 1011</span><br><span class="line">&amp;</span><br><span class="line">n - 1 = 0b 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">=</span><br><span class="line">i = 0b 0000 0000 0000 0000 0000 0000 0000 1011</span><br></pre></td></tr></table></figure><p>因此，我们可以说 <code>(n - 1) &amp; hash</code> 这段计算 hash 落点的代码，同时实现了 HashMap 中 hash 函数的 <strong>快速计算</strong> 和 <strong>均匀分布</strong> 的两种能力。</p><h1 id="保证-hash-映射的离散分布"><a href="#保证-hash-映射的离散分布" class="headerlink" title="保证 hash 映射的离散分布"></a>保证 hash 映射的离散分布</h1><p>上一节我们谈到，通过 <code>(n - 1) &amp; hash</code> ，我们高效地获取了 hash 映射的落点。但是，这只是保证了 hash 映射的 <strong>均匀分布</strong> （每个 <code>table</code> 下标都有可能命中），而没有保证 hash 映射的 <strong>离散分布</strong> （每个 <code>table</code> 下标命中的元素数量都差不多）。那么 HashMap 又是怎么做才保证了 hash 映射的 <strong>离散分布</strong> 的呢？</p><p>在上文 <code>h = 0b 1101 1010 1011 1100 1011 1101 1010 1011</code> 的例子中，我们只取了 hash 的后 4 位 <code>0b 1011</code> 来计算 hash 落点，前 28 位没有参与计算。这显然是不合理的，因为这相当于我们只拿了 hash 的很小一部分来代表整个 hash 值对应的元素。少数人怎么能代表多数人呢？🤯</p><p>那么 JDK 是怎么解决这个问题的呢？我们来看看先前跳过的 <code>hash()</code> 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就相对清晰了，<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 所做的事情就是将 hash 的高 16 位和低 16 位进行 <strong>异或</strong> 运算，这样就能保证 hash 的高位和低位都参与到计算中，进而保证了 hash 映射的 <strong>离散分布</strong> 。</p><p>再拿之前的例子来看：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 假设 key.hashCode() 是我们先前使用的 hash 值</span><br><span class="line">h = 0b 1101 1010 1011 1100 1011 1101 1010 1011</span><br><span class="line">^</span><br><span class="line">h &gt;&gt;&gt; 16 = 0b 0000 0000 0000 0000 1101 1010 1011 1100</span><br><span class="line">=</span><br><span class="line">0b 1101 1010 1011 1100 0110 0111 0001 0111</span><br></pre></td></tr></table></figure><p>这么算完后，假设 <code>table</code> 的长度是 16，那么 <code>0b 0111</code> 才是真正参与计算的值，而不是之前的 <code>0b 1011</code>。这样就保证了 hash 映射的 <strong>离散分布</strong> 。</p><p>你可能会问，为什么是 16 位？这主要是因为绝大多数的 HashMap table 长度是不会超过 $2^{16} &#x3D; 65536$ 的。因此这样的计算足够满足大多数场景下，尽可能公平地考虑高位（本来不参与 hash 的）和低位（本来就要参与 hash 的）对 hash 的影响。</p><blockquote><p>本文参考文章：</p><ul><li><p><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">HashMap 源码分析</a></p></li><li><p><a href="https://blog.csdn.net/qq_31086797/article/details/106505321">hashmap 算法 h &amp; (length-1)详解</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述 OAuth 2.0 鉴权架构</title>
      <link href="/2024/06/12213648.html"/>
      <url>/2024/06/12213648.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-OAuth-2-0-？为什么我们需要它？"><a href="#什么是-OAuth-2-0-？为什么我们需要它？" class="headerlink" title="什么是 OAuth 2.0 ？为什么我们需要它？"></a>什么是 OAuth 2.0 ？为什么我们需要它？</h1><p>OAuth 2.0 是一个开放标准，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用。</p><p>一个最简单的例子就是支付宝的免密支付。例如我在订阅微博会员按月自动续费服务时，需要获得支付宝授权，因为本质上这个操作是用户在 A 服务（微博）上授权 B 服务（支付宝）的数据，而 A B 服务之间并没有直接的信任关系。</p><p>那么问题来了，在支付宝的研发侧视角看，我应该怎么确保这个微博用户真的请求了他自己的支付宝账户数据？微博对我而言是一个不可信的第三方，我怎么知道它没有伪造请求？这需要我们有一种机制来确保用户的授权请求是合法的，这也就是 OAuth 2.0 的主要作用。</p><h1 id="OAuth-2-0-架构"><a href="#OAuth-2-0-架构" class="headerlink" title="OAuth 2.0 架构"></a>OAuth 2.0 架构</h1><p>摘自 RFC 6749：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/06/30/bHB4nMGaSi2ulmI.png" alt="OAuth 2.0 基本架构"></p><p>资源映射，以上文支付宝授权为例：</p><ul><li>资源拥有者：C 端用户</li><li>客户端：微博</li><li>认证服务器：支付宝认证服务器&#x2F;第三方可信认证服务器</li><li>资源服务器：支付宝服务接口</li><li>资源：支付宝用户信息、支付宝免密续费服务等</li></ul><p>具体流程如下：</p><blockquote><ol><li>用户打开客户端以后，客户端要求用户给予授权。</li><li>用户同意给予客户端授权。</li><li>客户端使用上一步获得的授权，向认证服务器申请令牌。</li><li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</li><li>客户端使用令牌，向资源服务器申请获取资源。</li><li>资源服务器确认令牌无误，同意向客户端开放资源。</li></ol></blockquote><p>关键点在于 2. 和 3. ，即用户如何给客户端授权，一般有以下四种模式。</p><blockquote><p>关于 OAuth 2.0 架构的其他细节请阅读 <a href="https://datatracker.ietf.org/doc/rfc6749/">RFC 6749</a>，本文仅对我认为比较重要的部分进行说明</p></blockquote><h1 id="客户端授权模式"><a href="#客户端授权模式" class="headerlink" title="客户端授权模式"></a>客户端授权模式</h1><h2 id="授权码模式-Authorization-Code-Grant"><a href="#授权码模式-Authorization-Code-Grant" class="headerlink" title="授权码模式 (Authorization Code Grant)"></a>授权码模式 (Authorization Code Grant)</h2><p>授权码模式 (Authorization Code Grant) 是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/06/30/9sguOnwFevIhrUK.png" alt="授权码模式工作流"></p><p>具体流程如下：</p><blockquote><ol><li>用户访问客户端，后者将前者导向认证服务器。</li><li>用户选择是否给予客户端授权。</li><li>假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向 URI”（redirection URI），同时附上一个授权码。</li><li>客户端收到授权码，附上早先的”重定向 URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，<strong>对用户不可见</strong>。</li><li>认证服务器核对了授权码和重定向 URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token，可选，用来获取下一次的访问令牌）。</li></ol></blockquote><p>注意，这种方式需要<strong>在 HTTP 头信息中明确指定不得缓存</strong>。</p><h2 id="隐式授权模式-Implicit-Grant"><a href="#隐式授权模式-Implicit-Grant" class="headerlink" title="隐式授权模式 (Implicit Grant)"></a>隐式授权模式 (Implicit Grant)</h2><p>隐式授权模式 (Implicit Grant) 不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/06/30/lvZWQpnagsoAb57.png" alt="隐式授权模式工作流"></p><p>具体流程如下：</p><blockquote><ol><li>客户端将用户导向认证服务器。</li><li>用户决定是否给于客户端授权。</li><li>假设用户给予授权，认证服务器将用户导向客户端指定的”重定向 URI”，并在 URI 的 Hash 部分包含了访问令牌。</li><li>浏览器向资源服务器发出请求，其中不包括上一步收到的 Hash 值。</li><li>资源服务器返回一个网页，其中包含的代码可以获取 Hash 值中的令牌。</li><li>浏览器执行上一步获得的脚本，提取出令牌。</li><li>浏览器将令牌发给客户端。</li></ol></blockquote><h2 id="密码模式-Resource-Owner-Password-Credentials-Grant"><a href="#密码模式-Resource-Owner-Password-Credentials-Grant" class="headerlink" title="密码模式 (Resource Owner Password Credentials Grant)"></a>密码模式 (Resource Owner Password Credentials Grant)</h2><p>密码模式 (Resource Owner Password Credentials Grant) 中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。<br>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/06/30/XWtPCw49dVOrn6a.png" alt="密码模式工作流"></p><p>具体流程如下：</p><blockquote><ol><li>用户向客户端提供用户名和密码。</li><li>客户端将用户名和密码发给认证服务器，向后者请求令牌。</li><li>认证服务器确认无误后，向客户端提供访问令牌。</li></ol></blockquote><h2 id="客户端凭证模式-Client-Credentials-Grant"><a href="#客户端凭证模式-Client-Credentials-Grant" class="headerlink" title="客户端凭证模式 (Client Credentials Grant)"></a>客户端凭证模式 (Client Credentials Grant)</h2><p>客户端凭证模式 (Client Credentials Grant) 指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于 OAuth 框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/06/30/vUTX3R8ZpBzjSkt.png" alt="客户端凭证模式工作流"></p><p>具体流程如下：</p><blockquote><ol><li>客户端向认证服务器进行身份认证，并要求一个访问令牌。</li><li>认证服务器确认无误后，向客户端提供访问令牌。</li></ol></blockquote><h1 id="四种授权模式异同"><a href="#四种授权模式异同" class="headerlink" title="四种授权模式异同"></a>四种授权模式异同</h1><table><thead><tr><th>授权模式</th><th>安全性</th><th>适用场景</th><th>场景示例</th><th>复杂度&#x2F;实现难度</th></tr></thead><tbody><tr><td>授权码模式（Authorization Code Grant）</td><td>高</td><td>异步的方式进行认证和授权，适合安全性要求高、能够保护客户端密钥的情境。</td><td>用户在应用程序中点击“使用微信登录”，然后被重定向到微信的登录页面，用户登录后，应用程序收到一个授权码，用以获取访问令牌。</td><td>高</td></tr><tr><td>密码模式（Resource Owner Password Credentials Grant）</td><td>适中</td><td>客户端可以直接使用用户的凭据，适合受信任的客户端环境或需要与 API 直接交互的场景。</td><td>用户直接在客户端（如移动应用）中输入用户名和密码，客户端使用这些凭据直接向授权服务器请求访问令牌。</td><td>高</td></tr><tr><td>客户端凭证模式（Client Credentials Grant）</td><td>适中</td><td>适合服务间通信、不涉及用户信息的场景，如后端微服务之间的安全访问。</td><td>后端服务需要访问另一个 API，它使用自己的身份（客户端 ID 和密码）直接请求访问令牌，而不涉及用户。</td><td>低</td></tr><tr><td>隐式授权模式（Implicit Grant）</td><td>低</td><td>主要用于没有安全需求的公开客户端，如单页应用（SPA），但由于安全性较弱，现在不推荐作为主要授权方式使用。</td><td>前端 JavaScript 应用在浏览器中直接从授权服务器获取访问令牌，通常通过重定向响应 URL 来传递令牌。</td><td>中</td></tr></tbody></table><blockquote><p>本文参考文章：</p><ul><li><p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解 OAuth 2.0</a></p></li><li><p><a href="https://datatracker.ietf.org/doc/rfc6749/">The OAuth 2.0 Authorization Framework - RFC 6749</a></p></li><li><p><a href="https://oauth.net/2/">OAuth 2.0 官方网站</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth </tag>
            
            <tag> RFC </tag>
            
            <tag> 鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过 SSH 远程连接另一台 Windows 主机中的 WSL</title>
      <link href="/2024/05/9d022207.html"/>
      <url>/2024/05/9d022207.html</url>
      
        <content type="html"><![CDATA[<p>有这样一个场景，我在 Windows 主机 A 上，想要通过 SSH 连接到 Windows 主机 B 上的 WSL。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主机A (Windows) -----&gt; 主机B (Windows)</span><br><span class="line">                             |</span><br><span class="line">                             V</span><br><span class="line">                          WSL (在主机B上)</span><br></pre></td></tr></table></figure><p>Google 了一圈，找到了一个比较靠谱的方案（<a href="https://gist.github.com/mattbell87/f5bd7b78c8d0ad7f0dfc3addae4f4897?permalink_comment_id=4762099#gistcomment-4762099">原文</a>）：</p><blockquote><p>Latest WSL2 has systemctl support and can automatically map sshd’s connection to the Windows host. No need to redirect port.</p><ol><li>Make sure Windows OpenSSH works.</li><li>In windows, run <code>wsl --update</code> to make sure use latest WSL.</li><li>In WSL, run <code>sudo apt-get install openssh-server</code> to install ssh and <code>sudo systemctl enable --now ssh</code> to automatically start ssh when WSL starts.</li><li>Run <code>ssh -J windows_user@windows_ip wsl_user@localhost</code> to login to ssh</li><li>If step 4 works, add the following content to <code>.ssh/config</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host wsl</span><br><span class="line">  HostName localhost</span><br><span class="line">  User wsl_user</span><br><span class="line">  ProxyJump windows_user@windows_ip</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  UserKnownHostsFile=/dev/null</span><br></pre></td></tr></table></figure><ol start="6"><li>Connect to <code>wsl</code> remote in VSCode 🎉🎉🎉</li></ol></blockquote><p>看起来非常直观简单，直接使用 <code>ssh -J</code> 的桥接功能，将主机 B 作为跳板机，连接到主机 B 的 WSL 上。事不宜迟，马上来 <del>踩坑</del> 试试吧！</p><h1 id="踩坑-1：端口冲突"><a href="#踩坑-1：端口冲突" class="headerlink" title="踩坑 1：端口冲突"></a>踩坑 1：端口冲突</h1><p><strong>最新版本</strong> 的 WSL2 已经支持 <code>systemctl</code>，不需要再折腾 WSL 自带的虚拟网卡了。但是，如果你在 WSL 中安装了 <code>openssh-server</code>，那么 22 端口会和 Windows 的 OpenSSH 服务冲突，导致 WSL 中的 SSH 服务无法启动。</p><p>因此我们必须更改 Windows 或是 WSL 二者之一的 SSH 端口。由于防火墙机制的存在，我建议更改 Windows 主机 B 的 SSH 端口，因为在 Windows 中配置管理防火墙比较直观和方便。</p><blockquote><p><strong>请注意</strong> ，更改后的连接指令应该为 <code>ssh -J windows_user@windows_ip:2222 wsl_user@localhost</code>。</p></blockquote><h2 id="更改-Windows-的-SSH-端口"><a href="#更改-Windows-的-SSH-端口" class="headerlink" title="更改 Windows 的 SSH 端口"></a>更改 Windows 的 SSH 端口</h2><p>配置文件路径如下，其中 <code>ProgramData</code> 是隐藏文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramData\ssh\sshd_config</span><br></pre></td></tr></table></figure><p>解除端口注释，改成你想要的端口，比如我就改成了 2222：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># This is the sshd server system-wide configuration file.  See</span><br><span class="line"># sshd_config(5) for more information.</span><br><span class="line"></span><br><span class="line"># The strategy used for options in the default sshd_config shipped with</span><br><span class="line"># OpenSSH is to specify options with their default value where</span><br><span class="line"># possible, but leave them commented.  Uncommented options override the</span><br><span class="line"># default value.</span><br><span class="line"></span><br><span class="line">Port 2222   # 改这里！</span><br><span class="line">#AddressFamily any</span><br><span class="line">#ListenAddress 0.0.0.0</span><br><span class="line">#ListenAddress ::</span><br></pre></td></tr></table></figure><p>在 Windows <strong>管理员权限</strong> 下，输入以下命令重启 SSH 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop sshd</span><br><span class="line">net start sshd</span><br></pre></td></tr></table></figure><p>或者，你也可以搜索 Windows <code>服务</code>，找到 <code>OpenSSH SSH Server</code>，在图形化界面中重启。</p><p>确认服务重启后，输入以下命令查看端口是否已经更改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | findstr /i &quot;:2222&quot;</span><br></pre></td></tr></table></figure><h2 id="配置-Windows-防火墙"><a href="#配置-Windows-防火墙" class="headerlink" title="配置 Windows 防火墙"></a>配置 Windows 防火墙</h2><p>开启 Windows 的 Open SSH 服务后，只会自动添加一个默认只允许 22 端口的防火墙规则。我们需要手动添加一个防火墙规则，允许 2222 端口的连接。</p><p>详情查看：<a href="https://blog.csdn.net/qq_62129885/article/details/126846775">如何在 windows 开端口</a></p><h1 id="踩坑-2：配置-WSL-的-SSH"><a href="#踩坑-2：配置-WSL-的-SSH" class="headerlink" title="踩坑 2：配置 WSL 的 SSH"></a>踩坑 2：配置 WSL 的 SSH</h1><p>在前文中我们新安装了 <code>openssh-server</code>，并且启动了 SSH 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now ssh</span><br></pre></td></tr></table></figure><p>此时必须对其进行配置才能正常连接。作为本地桥接的主机，我们并没有很多安全需求，很多 SSH 的安全功能反而会给我们带来麻烦。</p><p>通过编辑 <code>/etc/ssh/sshd_config</code> 文件，将以下两项配置的注释解除并按如下所示修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PubkeyAuthentication yes</span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure><p>保存后重启 WSL 的 sshd 服务即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart ssh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 2024 暑期实习面经</title>
      <link href="/2024/05/97feaabb.html"/>
      <url>/2024/05/97feaabb.html</url>
      
        <content type="html"><![CDATA[<p>时间来到 5 月份，经历了 10 家公司 21 场面试的洗礼，我持续两个月的高强度暑期实习面试也总算可以说是告一段落了。这篇文章的主要目的是记录我这两个月以来的面试经历和总结感悟，既为我后续的职业规划做参考，也希望能稍微帮上一些有缘看到它的朋友。如果各位对我的简历感兴趣，也可以点击页面右上角的“<a href="https://alrisha.cn/about/">关于</a>”查看。</p><p>以下部分是我对我这几轮实习面试总体的总结，如果希望直接看具体面经请<a href="#%E8%AF%A6%E7%BB%86%E9%9D%A2%E7%BB%8F">点这里</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th align="left">公司</th><th align="left">岗位&#x2F;部门</th><th align="left">进度</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">阿里云</td><td align="left"><a href="#%E9%98%BF%E9%87%8C%E4%BA%91-ECS">ECS 弹性计算</a></td><td align="left">❌ 主动拒了二面</td><td align="left">提前批，和中间件部门冲突</td></tr><tr><td align="left">腾讯</td><td align="left"><a href="#%E8%85%BE%E8%AE%AF-TEG-%E5%B9%BF%E5%91%8A%E5%B7%A5%E7%A8%8B%E9%83%A8">TEG 广告工程部</a></td><td align="left">❌ 一面挂</td><td align="left"></td></tr><tr><td align="left">腾讯</td><td align="left"><a href="#%E8%85%BE%E8%AE%AF-TEG-%E8%85%BE%E8%AE%AF%E7%BD%91%E7%BB%9C%E7%A0%94%E5%8F%91%E9%83%A8">TEG 腾讯网络研发部</a></td><td align="left">✔ OC</td><td align="left"></td></tr><tr><td align="left">阿里云</td><td align="left"><a href="#%E9%98%BF%E9%87%8C%E4%BA%91-%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%AD%E9%97%B4%E4%BB%B6">云原生中间件</a></td><td align="left">❌ 三面挂</td><td align="left"></td></tr><tr><td align="left">美团</td><td align="left"><a href="#%E7%BE%8E%E5%9B%A2-%E4%BC%98%E9%80%89%E4%BA%8B%E4%B8%9A%E9%83%A8">优选事业部</a></td><td align="left">❌ 一面挂</td><td align="left"></td></tr><tr><td align="left">美团</td><td align="left"><a href="#%E7%BE%8E%E5%9B%A2-SaaS">SaaS</a></td><td align="left">✔ OC</td><td align="left"></td></tr><tr><td align="left">淘天</td><td align="left"><a href="#%E6%B7%98%E5%A4%A9-%E9%98%BF%E9%87%8C%E5%A6%88%E5%A6%88">阿里妈妈</a></td><td align="left">❌ 三面挂</td><td align="left"></td></tr><tr><td align="left">快手</td><td align="left"><a href="#%E5%BF%AB%E6%89%8B-%E5%9F%BA%E7%A1%80%E5%B9%B3%E5%8F%B0">基础平台</a></td><td align="left">❌ 一面挂</td><td align="left"></td></tr><tr><td align="left">阿里控股</td><td align="left"><a href="#%E9%98%BF%E9%87%8C%E6%8E%A7%E8%82%A1-%E8%B5%84%E9%87%87%E4%BA%A7%E5%93%81%E6%8A%80%E6%9C%AF%E9%83%A8">资采产品技术部</a></td><td align="left">❌ 主动拒了 HR 面</td><td align="left"></td></tr><tr><td align="left">阿里云</td><td align="left"><a href="#%E9%98%BF%E9%87%8C%E4%BA%91-%E5%88%9B%E6%96%B0%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%BF%83">创新业务中心</a></td><td align="left">✔ OC</td><td align="left"></td></tr><tr><td align="left">蚂蚁</td><td align="left">-</td><td align="left">❌ 简历挂</td><td align="left">蚂蚁认为我的简历适合做架构和中间件，但是蚂蚁的架构部门今年似乎不怎么招实习生了（也很有可能是我还不够格）</td></tr><tr><td align="left">米哈游</td><td align="left">-</td><td align="left">❌ 简历挂</td><td align="left">据说北京地区只要 TOP2 学历的实习生</td></tr><tr><td align="left">鹰角网络</td><td align="left">-</td><td align="left">❌ 简历挂</td><td align="left"></td></tr><tr><td align="left">EA China</td><td align="left">-</td><td align="left">❌ 笔试挂</td><td align="left">全英文笔试，难度不低，只能说我还是太菜了</td></tr></tbody></table><h2 id="各公司的面试风格（主观意见）"><a href="#各公司的面试风格（主观意见）" class="headerlink" title="各公司的面试风格（主观意见）"></a>各公司的面试风格（主观意见）</h2><h3 id="阿里系"><a href="#阿里系" class="headerlink" title="阿里系"></a>阿里系</h3><p>所有暑期实习 HC 较多的大厂里，我认为阿里系（包括蚂蚁）的面试难度是最大的（面试难度类似的字节暑期基本不怎么招人）。而在不同 BG 里，我认为难度排名大约是 <code>淘天 &gt;= 阿里云 = 蚂蚁 &gt; 其它</code> 。当然这和具体部门有关，比如我挂掉的<a href="#%E6%B7%98%E5%A4%A9-%E9%98%BF%E9%87%8C%E5%A6%88%E5%A6%88">阿里妈妈</a>，本身就是阿里纯纯的核中核部门，面试难度也是肉眼可见的地狱级别。</p><p>在面试方式方面，阿里系的面试基本不会直接问八股，而是每一个面试官都会和你沟通，试图在有限时间内了解你简历里的项目（这是最考验面试人的地方），然后在这其中深挖一些八股相关的问题甚至是场景题。</p><p>另外必须提醒的是，阿里系的<strong>笔试非常非常重要</strong>。笔试成绩会极大影响你在候选人中排序的位置，并且在面试中也会经常提及。例如我数据库方面比较薄弱，在笔试中都答的不好，这个问题在面试中也被反复拷打。而如果你的笔试成绩让面试官不满意，他甚至有权力让你加面笔试。</p><p>当然，难度大也有相应的回报，阿里系的实习生转正几率是大厂中最高的，只要表现符合预期，很少出现 HC 问题。</p><p>题外话，根据小道消息，阿里系学历卡 23 所院校的情况确实是客观存在的，就算实习生进去了可能也会影响转正，请各位留意。</p><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><p>和阿里类似，腾讯的面试八股也非常少，同样也是通过深挖项目来了解你的技术水平。但是就我个人了解，腾讯将其实习生面试和校招面试的难度区分的很大，所以总体来看暑期实习的面试并不是非常难（WXG 和部分 IEG 除外，这俩部门不仅是核中核，秋招还基本不怎么招人，全部 HC 都给实习生了）。随之而来的代价就是，腾讯的暑期转正难度也是我面试的这几家公司中最大的。</p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>和腾讯阿里不同，美团非常看中面试者的八股基础，在某些部门甚至会直接问简历上没有提及的八股问题。也是因为如此，美团的面试通过率相当一部分是可以通过自身的努力提高不少的。</p><p>美团在暑期实习转正率高的情况下，对暑期实习生的面试流程做了很多简化，例如尽量只有两轮技术面和取消 HR 面，确实比较良心。并且北邮的名号在美团是非常管用的，据说只要是北邮本硕，即使笔试就做了一题出来也能给你约面。</p><h3 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h3><p>一面挂的我可能没有立场来评价快手 😂，但我个人体感快手的面试特点是和美团类似的，非常看重八股基础，并且难度会比美团稍大。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><em><font color=#236B8E ><b>Q：</b>怎么准备面试？</font></em></p><p><strong>A：</strong> 以下提供一些我经常使用的网站以供参考</p><ol><li>八股文<ul><li><a href="https://javaguide.cn/home.html">JavaGuide</a></li><li><a href="https://xiaolincoding.com/">小林 Coding</a></li></ul></li><li>算法题<ul><li><a href="https://leetcode.cn/">LeetCode</a></li><li><a href="https://www.nowcoder.com/">牛客网</a></li></ul></li><li>面经<ul><li><a href="https://www.nowcoder.com/">牛客网</a></li><li><a href="https://maimai.cn/">脉脉</a></li></ul></li><li>简历制作<ul><li><a href="https://www.mujicv.com/">木及简历</a></li></ul></li></ol><p><em><font color=#236B8E ><b>Q：</b>没有实习经历，怎么办？</font></em></p><p><strong>A：</strong> 首先，有过另外一段互联网公司的实习经历的简历毫无疑问是最有竞争力的。但如果没有，你也可以考虑通过参与开源项目（比如我）、参加比赛、包装实验室项目甚至实现网上公开的大型项目来丰富你的简历。题外话，作为一位开源爱好者，我必须提醒各位的是，开源项目往往都是基础架构或是中间件，这样的简历在面试大多数业务部门的时候，可能需要准备好充足可信的理由和面试官解释你参与开源的动机和规划。</p><p><em><font color=#236B8E ><b>Q：</b>什么时候投递比较好？</font></em></p><p><strong>A：</strong> 3 月中旬开始即可，没有必要过早或是参与所谓“提前批”（亲身体会），我认为我今年的投递实际上就偏早了。另外，在投递选择部门时一定要慎重，尽量不要选择类似 <code>都喜欢</code> 这样的选项。</p><p><em><font color=#236B8E ><b>Q：</b>面试中要注意什么？</font></em></p><p><strong>A：</strong> 面试的时候除了技术问题，我觉得有几点也是不能忽视的</p><ol><li>要<strong>诚实</strong>，实在不会的知识点或者技术大胆承认，不懂装懂会扣更多的分。</li><li>积极展现自己的主动学习意愿和转正意愿（比起只是混一段实习经历，大多数公司更希望自己培养的实习生留下来）。</li><li>对自己简历上的项目一定要熟悉。绝大多数面试官很可能并不是很懂简历上写的东西，那么如何把它讲清楚就是实力的一种体现。</li></ol><p><em><font color=#236B8E ><b>Q：</b>每轮面试都有什么差别？</font></em></p><p><strong>A：</strong> 暑期实习的面试一般在二到三轮技术面左右（像腾讯 WXG 那种顶级部门论外），每轮面试的难度和内容都与面试官本人风格相关，没有一般规律。但从职级上讲，一轮的面试官一般是平级或稍高一级（按校招入职算）的前辈，二轮的面试官一般是你的直接领导（Leader），三轮的面试官一般是你的领导的领导，也称主管或总经理（General Manager, GM）。而 HR 面则不属于技术面，主要是了解你的个人情况和意向，一般不怎么挂人。如果你的技术水平过关，结果在 HR 面挂掉了，一般就是横向对比淘汰（说白点就是有另一个比你强要求还比你低的候选人），所谓的 KPI 面我认为几乎是不怎么存在的。</p><h1 id="详细面经"><a href="#详细面经" class="headerlink" title="详细面经"></a>详细面经</h1><h2 id="阿里云-创新业务中心"><a href="#阿里云-创新业务中心" class="headerlink" title="阿里云 创新业务中心"></a>阿里云 创新业务中心</h2><h3 id="一面（通过）-2024-4-15"><a href="#一面（通过）-2024-4-15" class="headerlink" title="一面（通过） 2024-4-15"></a>一面（通过） 2024-4-15</h3><ul><li>自我介绍</li><li>介绍项目 Nacos，指标是怎么配置的？</li><li>介绍 SkyWalking<ul><li>什么是 TracID 和 SpanID？</li><li>SkyWalking 的 TracID 是如何生成的？</li><li>Trace 上下文 Context 是什么？</li></ul></li><li>进程&#x2F;线程&#x2F;协程的区别</li><li>简要介绍一下线程池</li><li>如何在线程池中使用 ThreadLocal？</li><li>反问：<ul><li>Q: 主要业务是？</li><li>A: <a href="https://tongyi.aliyun.com/qianwen/">通义千问</a>大模型 to C&#x2F;B&#x2F;D 的方向，偏工程化</li><li>Q: Base 情况？</li><li>A: 仅杭州</li><li>Q: 面试流程？</li><li>A: 三轮技术面，一轮 HR 面</li></ul></li><li>后续面试官又打电话回来说他忘记了流程上我必须写算法题（因为笔试选择题做太烂了，排在同期笔试的 50% 之后 😫），给我加了一个简单题：<a href="https://leetcode.cn/problems/longest-common-prefix/description/">最长公共前缀</a></li></ul><p>（总计 40min）</p><h3 id="二面（通过）-2024-4-22"><a href="#二面（通过）-2024-4-22" class="headerlink" title="二面（通过） 2024-4-22"></a>二面（通过） 2024-4-22</h3><ul><li>面试官介绍部门：飞天实验室，产品主要是通义千问、阿里云百炼等</li><li>自我介绍</li><li>从零开始介绍 Nacos 和 Skywalking 项目问的很深</li><li>说说 Java 字节码增强的原理</li><li>那么 Arthas 和 jstack 这些工具又是什么原理呢？（不懂）</li><li>标记-复制和标记-清除&#x2F;整理两种算法的使用场景</li><li>嵌入式系统为什么不使用有 GC 的语言？（无法承受 STW 的代价）</li><li>大模型赛道非常竞争，目前我们作息为 995，你能适应吗？（害怕）</li><li>面试官有紧急会议，无反问环节（可以看出确实卷）</li></ul><p>（总计 60min，无算法）</p><h3 id="三面（通过）-2024-4-25"><a href="#三面（通过）-2024-4-25" class="headerlink" title="三面（通过） 2024-4-25"></a>三面（通过） 2024-4-25</h3><ul><li>免自我介绍直入主题，简要介绍 Nacos 项目</li><li>职业规划，开源项目都是架构方面，为什么要面试业务方面的工作？</li><li>请你给出一个量化的指标，评价你做的工作（没答好，面试官回答直接豁然开朗：用户对你提出的新功能的采用率）</li><li>讲讲 SkyWalking 项目和遇到的最大困难</li><li>线程和协程的应用场景</li><li>如果主进程挂了，这个进程中的线程和协程要怎么恢复？<ol><li>堆栈与上下文的持久化</li><li>复现执行（即重头跑一遍）</li></ol></li><li>大模型使用中你有什么经验能让模型回复更精确？</li><li>在工程技术方面上，你认为大模型的开发会有什么难点？</li><li>你希望在什么样的团队中工作？</li><li>你是否有带领团队的经验？说说如果你的下属抗拒你的决定，你会怎么做？</li><li>你怎么看待加班？</li><li>聊职业规划、团队赛道、加班情况、转正情况和晋升情况等</li><li>后面基本都在聊天了，所以无反问环节</li></ul><p>（总计 60min，无算法）</p><h2 id="阿里控股-资采产品技术部"><a href="#阿里控股-资采产品技术部" class="headerlink" title="阿里控股 资采产品技术部"></a>阿里控股 资采产品技术部</h2><h3 id="一面（通过）-2024-4-12"><a href="#一面（通过）-2024-4-12" class="headerlink" title="一面（通过） 2024-4-12"></a>一面（通过） 2024-4-12</h3><ul><li>面试官介绍部门</li><li>自我介绍</li><li>深挖 Nacos 项目</li><li>讲讲 gRPC 的原理</li><li>JKD 动态代理原理？还有别的动态代理方式吗？</li><li>反射有什么优点？又有什么缺点？</li><li>讲讲自己用过的线程池</li><li>Java 中有几种常见 IO 模型？你常用的是哪种？</li><li>你在平时使用过大模型吗？大模型的提示工程有哪些技巧？</li><li>场景题：2 个文件 50 亿字符串，4g 内存，找到这两个文件中都出现的字符串（哈希映射为小文件，每次都读小文件即可）</li><li>反问：<ul><li>Q: 阿里控股在集团中的定位？</li><li>A: 所有非业务技术岗都在这里</li><li>Q: Base 情况？</li><li>A: 仅杭州</li><li>Q: 面试流程？</li><li>A: 实习一般是两轮技术面，一轮 HR 面，每轮面试间隔不超过一周。但你的笔试成绩比较低，可能要加面一个技术面。</li></ul></li><li>后续额外加面算法题：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">两两交换链表中的节点</a></li></ul><p>（总计 40min）</p><h3 id="二面（通过）-2024-4-22-1"><a href="#二面（通过）-2024-4-22-1" class="headerlink" title="二面（通过） 2024-4-22"></a>二面（通过） 2024-4-22</h3><ul><li>自我介绍</li><li>拷打项目</li><li>为什么之前没有去实习？</li><li>讲讲网络隧道和 VPN，如果要你实现一个能够绕过防火墙的方式，你会怎么做？</li><li>对称加密和非对称加密的区别</li><li>讲讲 HTTPS</li><li>数组是如何实现随机访问的？</li><li>散列表都有什么实现方式？</li><li>什么是操作系统的中断？</li><li>是否了解大模型的底层原理与训练方式？（这我是真不会啊）</li><li>为什么 Java GC 往往要同时采用标记-复制和标记-清除&#x2F;整理两种算法？</li><li>反问：<ul><li>Q: 能举例说明团队的业务情况吗？</li><li>A: 资采产品技术部主要是做整个阿里集团的采购服务</li><li>Q: 转正情况？</li><li>A: 来一个转一个（真嘟假嘟？）</li></ul></li></ul><p>（总计 50min，无算法）</p><h3 id="三面（通过）-2024-4-25-1"><a href="#三面（通过）-2024-4-25-1" class="headerlink" title="三面（通过） 2024-4-25"></a>三面（通过） 2024-4-25</h3><ul><li>自我介绍</li><li>介绍项目</li><li>对 To B 业务有什么看法？</li><li>目前手头有什么 Offer？</li><li>介绍开源经历</li><li>反问<ul><li>Q: 作息情况？</li><li>A: 公司规定 9 点上班 6 点下班，但实际上大部分是 10 点上班 8 点下班，周末加班情况不多</li><li>Q: 介绍一下阿里控股和爱橙科技？</li><li>A: 爱橙科技为原 CTO 线，主要业务基本都为 B 端</li></ul></li></ul><p>（总计 30min，无算法）</p><h2 id="快手-基础平台"><a href="#快手-基础平台" class="headerlink" title="快手 基础平台"></a>快手 基础平台</h2><h3 id="一面（挂）-2024-4-2"><a href="#一面（挂）-2024-4-2" class="headerlink" title="一面（挂） - 2024-4-2"></a>一面（挂） - 2024-4-2</h3><ul><li>自我介绍</li><li>讲项目</li><li>讲讲进程、线程、协程的关系和区别</li><li>TCP 拥塞控制</li><li>TCP 的 TIME_WAIT 状态是什么？为什么要有这个状态？</li><li>TCP 连接中，如果客户端宕机了，服务端怎么处理？</li><li>了解 Java 的锁吗？讲讲什么是乐观锁？自旋锁是乐观锁吗？自旋锁是怎么实现的？（没答好）</li><li>了解 JVM GC 机制吗？GC 主要处理的哪部分内存？如何判断对象是否需要被 GC 回收？</li><li>做题：<a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a>（时间复杂度答错了 😭）</li><li>反问：<ul><li>Q: 你们团队主要做什么？</li><li>A: 基础平台大部门</li><li>Q: Base 情况？</li><li>A: 北京，西二旗</li><li>Q: 面试流程？</li><li>A: 两轮技术面，一轮 HR 面</li></ul></li></ul><h2 id="淘天-阿里妈妈"><a href="#淘天-阿里妈妈" class="headerlink" title="淘天 阿里妈妈"></a>淘天 阿里妈妈</h2><h3 id="一面（通过）-2024-3-28"><a href="#一面（通过）-2024-3-28" class="headerlink" title="一面（通过） - 2024-3-28"></a>一面（通过） - 2024-3-28</h3><blockquote><p>我今年暑期<strong>最艰难</strong>的一场面试！</p></blockquote><ul><li>自我介绍</li><li>三个项目分别一条条拷打，共计 40min 包括但不限于：<ul><li>项目参与契机</li><li>项目目标与产出</li><li>项目技术栈详解</li><li>项目难点与解决方案</li><li>项目细节，例如： Nacos 的 CP 模型与 AP 模型详解…</li></ul></li><li>八股：<ul><li>HTTP 与 HTTPS 的区别</li><li>HTTP 头的主要字段</li><li>TCP 三次握手与四次挥手</li><li>线程池的主要参数，核心线程、阻塞队列、最大线程数、拒绝策略之间的关系</li><li>消息队列的主要作用和特点</li><li>MySQL 的事务隔离级别</li><li>MySQL 的索引类型</li><li>Java GC 如何减少 STW 的影响</li><li>…（以上都是比较正常的按下不表，下面各个都是<strong>重量级</strong>）</li><li>volatile 关键字使用了指令重排，指令重排有什么好处，为什么要设计指令重排？（啊？）</li><li>B+ 树的特点，为什么高度一般是 3~4 层，为什么 MySQL 设计数据都存储在叶子节点？（啊？？）</li><li>a, b, c 列建立联合索引，查询条件为 <code>WHERE c = 1 AND a = 1</code> 时索引的使用情况，<code>WHERE c = 1 OR a = 1</code> 呢？（啊？？？）</li><li>HashMap 的 <code>indexFor()</code> 函数是什么？为什么这么设计？（啊？？？？）</li><li>…（还有不少，被问懵了忘掉了）</li></ul></li><li>场景题<ul><li>有一个百亿的无序数据集，如何查找到其中所有不重复的数据？（分治）</li><li>多用户多商家的前提下，用户需要看到他下的所有订单，商家需要看到他卖出的所有订单，怎么设计数据表？（三张表，用户表、商家表、订单表）</li></ul></li><li>算法题：<a href="https://leetcode.cn/problems/reverse-only-letters/description/">仅仅反转字母</a></li><li>SQL 题：一个表有两列，一列是 name，一列是 score，一个学生可能有多个成绩，找出最高成绩为 7 的学生名字，必须用子查询（寄！）</li><li>反问：<ul><li>Q: 你们团队主要做什么？</li><li>A: 广告业务黄埔军校</li><li>Q: Base 情况？</li><li>A: 北京杭州都可以</li></ul></li></ul><p>（总计 120min）</p><h3 id="二面（通过）-2024-4-9"><a href="#二面（通过）-2024-4-9" class="headerlink" title="二面（通过） - 2024-4-9"></a>二面（通过） - 2024-4-9</h3><ul><li>自我介绍</li><li>讲项目</li><li>如何评估 QPS 吞吐量</li><li>为什么使用协程进行网络 IO 操作</li><li>讲讲 Python 的 GIL 锁</li><li>如何让 Python 拥有更高的性能</li><li>C++ 和 Python&#x2F;Java 的区别</li><li>对于一个服务端程序，如何确定其支持的最大并发连接数</li><li>对 10 亿个互不相同的无符号整数，32GB 内存，如何进行排序？</li><li>是否有小于 O(nlogn)的排序算法？对这 10 亿个无符号整数，快速排序更快还是这个算法更快？</li><li>做题：对一个正整数 n ，求 n 除以 [1,n] 所有数字的商的和，要求时间复杂度在 O(n) 以下（纯数学题，难！）<ul><li>我找到的规律是这样的：</li><li>记 <code>s = sqrt(n)</code> ， <code>prev = n/1 + n/2 + ... + n/s</code> ，<code>next = n/(s + 1) + n/(s + 2) + ... + n/n</code> ，结果 <code>res = prev + next</code>。</li><li><strong>有这样的规律</strong> ： <code>prev - next = s * s</code></li><li>则有： <code>res = prev + next = prev + (prev - s * s) = 2 * prev - s * s</code></li><li>这样就可以仅计算 <code>prev</code> 就可以得到结果，时间复杂度为 O(sqrt(n))。</li></ul></li><li>反问：<ul><li>Q: 我能学到什么？</li><li>A: （介绍了阿里妈妈广告业务）</li><li>Q: 我在技术上还有能提高的地方吗？</li><li>A: 我们主要技术栈是 C++，你的技术栈在我们这不是很有优势</li></ul></li></ul><p>（总计 90min）</p><h3 id="三面（挂）-2024-4-17"><a href="#三面（挂）-2024-4-17" class="headerlink" title="三面（挂） - 2024-4-17"></a>三面（挂） - 2024-4-17</h3><ul><li>自我介绍</li><li>介绍项目</li><li>参与开源的契机</li><li>职业规划和 Base 期望</li><li>讲讲 static 关键字？具体特点是什么？它修饰的类保存在哪个 JVM 内存区域？</li><li>MetaSpace 和方法区的关系？</li><li>聊聊 Java 中的锁</li><li>在多线程程序中，如何进行断点调试？</li><li>场景题：设计一个数据结构，存储 100 亿个数据的中位数，保证查找时间复杂度为 O(1)，插入时间复杂度为 O(logn)。（用两个堆存储，一个大顶堆一个小顶堆，堆顶都为中位数即可）</li><li>场景题：100 亿个商品，实现分布式的连续编号，怎么做？（没太理解题目意思 😰，我答雪花算法不符合面试官的意图）</li><li>算法题：定义最多 256 位的整数类，并实现加法运算。（我封装了 BigInteger，面试官不满意，后面自己又实现了一个大数相加的算法）</li><li>简要说了一下如果能实习的话所在小组的工作内容，无反问环节。</li></ul><p>（总计 60min）</p><h2 id="美团-SaaS"><a href="#美团-SaaS" class="headerlink" title="美团 SaaS"></a>美团 SaaS</h2><h3 id="一面（通过）-2024-3-27"><a href="#一面（通过）-2024-3-27" class="headerlink" title="一面（通过） - 2024-3-27"></a>一面（通过） - 2024-3-27</h3><ul><li>自我介绍</li><li>介绍项目 Nacos</li><li>介绍实验室项目</li><li>线程的状态有哪些？WAITING 和 BLOCKED 的区别？</li><li>为什么要有虚拟内存？虚拟内存的段页式管理是怎么实现的？</li><li>讲讲 TCP 的三次握手和四次挥手</li><li>HTTP 主要状态码有哪些？405 和 504 分别是什么含义？</li><li>Java 有哪八种基本数据类型？</li><li>讲讲 Java HashMap 的实现原理，负载因子有什么含义？为什么每次扩容都是 2 倍？</li><li>三个线程交替打印 ABC （直接贴上<a href="https://alrisha.cn/2024/02/81afead4.html">我的博客</a>）</li><li>讲讲 MySQL 的 MyISAM 和 InnoDB 的区别</li><li>InnoDB 读未提交和读已提交的区别？如何实现从读未提交到读已提交？</li><li>InnoDB 读已提交和可重复读的区别？如何实现从读已提交到可重复读？</li><li>MVCC 内部如何实现可重复读？如何计算&#x2F;判断事务的版本号？</li><li>对 a, b, c 列建立联合索引，查询条件为 a 和 c 时索引的使用情况？</li><li>做题：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">反转链表 II</a></li><li>反问：<ul><li>Q: 你们团队主要做什么？</li><li>A: SaaS 内的低代码平台，目前在内部推进使用，任务有一定的挑战性</li><li>Q: Base 情况？</li><li>A: 北京，朝阳那一带</li><li>Q: 实习面试流程？</li><li>A: 两轮技术面，一轮 HR 面</li></ul></li></ul><p>（总计 70min）</p><h3 id="二面（通过）-2024-4-1"><a href="#二面（通过）-2024-4-1" class="headerlink" title="二面（通过） - 2024-4-1"></a>二面（通过） - 2024-4-1</h3><ul><li>自我介绍</li><li>面试官介绍部门</li><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a></li><li><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">二叉树的直径</a></li><li>引申问题：在不使用全局变量的情况下，找到二叉树中距离最大的任意两个<strong>节点</strong> （看着简单，实际上上手非常复杂，边界条件也非常麻烦，最后没做出来 😭）</li><li>为什么读计算机专业？</li><li>职业意向和规划是什么？</li><li>反问：<ul><li>Q: 介绍部门？</li><li>A: SaaS 部门主要面向 B 端，商家侧的赋能都是这个大部门的主要业务</li><li>Q: Base 情况？</li><li>A: 北京关庄地铁站附近。</li><li>Q: 面试流程？</li><li>A: 两个技术面，HR 面实习生不一定有。</li></ul></li></ul><h2 id="美团-优选事业部"><a href="#美团-优选事业部" class="headerlink" title="美团 优选事业部"></a>美团 优选事业部</h2><h3 id="一面（挂）-2024-3-22"><a href="#一面（挂）-2024-3-22" class="headerlink" title="一面（挂） - 2024-3-22"></a>一面（挂） - 2024-3-22</h3><ul><li>自我介绍</li><li>介绍项目 Nacos</li><li>RPC 和 HTTP 的区别</li><li>了解 GC 吗？讲讲 G1 垃圾回收器的基本原理</li><li>讲讲 Java 并发，JUC 常用的类库有？</li><li>讲讲 ConcurrentHashMap 的实现原理</li><li>ConcurrentHashMap 读操作需要加锁吗？（答错了，用了 volatile 修饰的读操作不需要加锁）</li><li>讲讲红黑树的基本原理？</li><li>除了 HashMap 你知道有什么地方用到了红黑树吗？（我回答 epoll 在内核态维护了一个红黑树，面试官还提到 DNS 也是用红黑树实现查找的）</li><li>讲讲 epoll 原理，它和 select&#x2F;poll 的区别？</li><li>Synchronized 实现原理和锁升级过程</li><li>了解 MySQL 吗？讲讲事务的隔离级别</li><li>可重复读在 MySQL 中是怎么实现的？</li><li>讲讲 MVCC 的基本原理</li><li>聚簇索引和非聚簇索引的原理与区别，非聚簇索引叶子节点存储的是什么？（答的一坨）</li><li>MySQL 最左匹配原则是什么？</li><li>做题：<a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">二叉树的锯齿形层序遍历</a></li><li>反问：<ul><li>Q: 你们团队主要做什么？我进去后会做什么？</li><li>A: 优选事业部是很大的部门，技术栈是 Java 为主，但不知道你具体会到哪个组。</li><li>Q: Base 情况？有没有转正机会？</li><li>A: 都在北京；如果有转正意愿机会很大。</li></ul></li></ul><p>（总计 70min）</p><h2 id="阿里云-云原生中间件"><a href="#阿里云-云原生中间件" class="headerlink" title="阿里云 云原生中间件"></a>阿里云 云原生中间件</h2><h3 id="一面（通过）-2024-3-12"><a href="#一面（通过）-2024-3-12" class="headerlink" title="一面（通过） - 2024-3-12"></a>一面（通过） - 2024-3-12</h3><ul><li>做题 1：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">合并 K 个升序链表</a>，暴力 O(n^2)做出来面试官不满意，后面提出用优先队列优化到 O(nlogk) 面试官才觉得 OK。</li><li>做题 2：<a href="https://leetcode.cn/problems/russian-doll-envelopes/description/">俄罗斯套娃信封问题</a>，先排序再用动态规划做出来了，本质上是最长上升子序列问题。<br>（共 40min 左右，两道 Hard ，人有点麻 🤮）</li></ul><blockquote><p><strong>Tips:</strong> 先不管题目的难易程度，各位会发现这些题目都是 Leetcode 的原题，而且虽然你是在白板上写的，但面试官很快就能发现你做的正不正确，我非常有理由怀疑面试官就是一个分屏窗口开着 Leetcode 复制题目来给我们面试，接着直接贴走你白板上的代码回 Leetcode 上运行的，然后逮着错误的样例追着你问。这个规律应该适用于阿里全系的面试算法题。</p></blockquote><ul><li>项目拷打：Apache SkyWalking<ul><li>线程间同步方式</li><li>协程间同步方式</li><li>协程使用时需要避免什么问题？（1. 避免池化 2. 仅用于 IO 密集型任务，不要用在 CPU 密集型任务）</li><li>线程和协程如何交互？</li><li>如何解决线程和协程数据同步的问题？技术选型是什么？（排除了加锁队列，选择了使用代理线程的方式）</li><li>代理线程只有一个，是否会出现单点故障？如何解决？（如果代理层也使用线程池消耗得不偿失，失去项目原本的意义；通过设定一定的队列大小阈值并在文档中提醒用户来一定程度避免单点故障）</li></ul></li><li>面试官提了一嘴 Nacos ，但是只问了我对接人是谁。面试官：其实我就是 Nacos 团队的，这个你既然做过就不问你了。（汗流浃背 😓）</li><li>反问：<ul><li>Q: 你们团队主要做什么？</li><li>A: 云原生中间件，Nacos、Seata、RocketMQ、Sentinel 等</li><li>Q: Base 情况？</li><li>A: 杭州为主，北京也有，后面能协商</li><li>Q：面试流程？</li><li>A：三轮技术面，一轮 HR 面，今天这是第一面简历面</li></ul></li></ul><p>（总计 80min）</p><h3 id="二面（通过）-2024-3-18"><a href="#二面（通过）-2024-3-18" class="headerlink" title="二面（通过） - 2024-3-18"></a>二面（通过） - 2024-3-18</h3><ul><li>打招呼（我在 OSPP 活动里问过他问题）</li><li>讲讲 HashMap 和 ConcurrentHashMap 的实现原理</li><li>为什么要用红黑树？红黑树的实现原理？为什么它的查询是 log(n) 的？（没答出来，我真不会写红黑树 😓，只说它是平衡二叉树，类似优先队列的堆）</li><li>那讲讲堆排序的具体过程</li><li>TCP 和 UDP 的区别？</li><li>TCP 如何保证可靠传输，即不丢包？</li><li>说说 TCP 快速重传</li><li>线程和进程的区别？</li><li>进程通信方式和线程同步方式？</li><li>讲讲你学到最多的项目（肯定不敢讲 Nacos 了，怎么能关公面前耍大刀呢）</li><li>如果微服务之间出现慢查询怎么排查？（网络问题？数据库问题？程序内部问题？总之没答好）</li><li>那换种说法，如果服务器变得很卡，怎么排查？一般有什么原因？<ul><li><ol><li>内存占用过高，比如 Java GC 负担过重，或者 C&#x2F;C++ 这种内存不安全语言出现内存泄漏。</li></ol></li><li><ol start="2"><li>CPU 占用过高，比如程序出现忙等待问题。</li></ol></li><li><ol start="3"><li>网络阻塞或 DNS 解析失败。</li></ol></li><li>（实际上应该再答一个磁盘 IO 方面的，当时没想到）</li><li>解决方案可以用 TOP 查看哪个进程出问题了，再用 Jstack 等堆栈工具分析。</li><li>但是面试官 <strong>还是不太满意</strong></li></ul></li><li>那你说说 TOP 指令里 load 的含义，怎么解读？（当时没想出来，只能说不会 😭）</li><li>反问：<ul><li>Q: 开源社区商业化模式？如何盈利的？</li><li>A: 提供差异化的商业解决方案，用户团队小时会用开源版本，当用户做大后由于业务需求会进一步购买商业版。</li><li>Q: 为什么要做开源？为何不用 Oracle 的闭源商业模式？</li><li>A: 用户不会感觉被“绑架”，可以很方便的做迁移，这一点对很多用户有很大的吸引力。</li><li>Q: 面试流程？</li><li>A: 如果通过，还有一轮技术面和一轮 HR 面，官网的测评和笔试都是需要做的。</li><li>Q: 我有什么能改进的地方？</li><li>A: 对高流量分布式系统的排查经验不足，但对校招实习生来说也是正常的。其它还好。</li></ul></li></ul><p>（总计 45min，无算法题）</p><h3 id="三面（挂）-2024-3-28"><a href="#三面（挂）-2024-3-28" class="headerlink" title="三面（挂） - 2024-3-28"></a>三面（挂） - 2024-3-28</h3><ul><li>自我介绍</li><li>细问 Nacos 的实现原理，非常非常细的那种，比如心跳机制阈值几秒</li><li>Nacos 有什么缺点吗？</li><li>简要介绍 SkyWalking</li><li>有什么个人爱好</li><li>最喜欢的爱好是？</li><li>为什么选择阿里？</li><li>反问：<ul><li>Q: 开源项目盈利点？</li><li>A: 没有盈利，甚至每年都要投入非常多的资金维护。但是拿到的用户值得这些代价</li><li>Q: Base 情况？</li><li>A: 杭州为主，实习可以考虑北京，但如果后续能够转正，之后最好来杭州</li></ul></li></ul><p>（总计 40min）</p><h2 id="腾讯-TEG-腾讯网络研发部"><a href="#腾讯-TEG-腾讯网络研发部" class="headerlink" title="腾讯 TEG 腾讯网络研发部"></a>腾讯 TEG 腾讯网络研发部</h2><h3 id="一面（通过）-2024-3-11"><a href="#一面（通过）-2024-3-11" class="headerlink" title="一面（通过） - 2024-3-11"></a>一面（通过） - 2024-3-11</h3><ul><li>自我介绍</li><li>介绍两个开源项目</li><li>进程、线程和协程的区别</li><li>select、poll、epoll 的区别和原理</li><li>epoll 的 ET 和 LT 模式区别和原理</li><li>开放题目：如何设计一个高网络并发的系统</li><li>了解容器化技术吗？说明一下 Docker 的三种网络模式（人傻了，根本没看过这东西 😰）</li><li>说说学校的项目？讲讲 BGP 协议和 AS 组织机构映射。<br>（共 30min，无算法题）</li><li>反问：<ul><li>Q: 你们团队主要做什么？</li><li>A: 做 SDN 协议开发，管理整个腾讯内部的所有交换机&#x2F;路由器，两个方向，一个是容器网络（Docker&#x2F;k8s），一个是传统网络，面试官是传统网络方向的。</li><li>Q: Base 情况？</li><li>A: 北京和深圳</li><li>Q: HC 情况？</li><li>A: 不清楚</li><li>Q: 对我今天的面试评价如何？</li><li>A: 整体还行，但是有些技术深度不够，特别是网络方面的（下次必须恶补容器化网络 😓）。如果有接下来我们部门的流程可以多准备一下这些方面的内容。</li></ul></li></ul><h3 id="二面（通过）-2024-3-15"><a href="#二面（通过）-2024-3-15" class="headerlink" title="二面（通过） - 2024-3-15"></a>二面（通过） - 2024-3-15</h3><ul><li>自我介绍</li><li>介绍项目：Nacos 到 Skywalking</li><li>介绍实验室和实验室项目（面试官对这个很感兴趣，聊了很久）</li><li>TCP 三次握手和四次挥手，为什么分别是三次和四次？</li><li>什么时候使用多进程，什么时候使用多线程？</li><li>做题：<a href="https://leetcode.cn/problems/reverse-linked-list/description/">反转链表</a><br>（大约 40min，接下来是应该算是领导力测试）</li><li>身边的人怎么评价你？</li><li>你怎么评价自己？</li><li>有什么日常爱好？</li><li>Base 期望？家乡是哪的？</li><li>如果让你带一个小团队你应该怎么做？</li><li>虽然你是网络方向的专业，但简历上描写很少，为什么？</li><li>反问：<ul><li>Q: 主要工作内容？</li><li>A: 容器网络和传统网络（和一面一样的回答）。</li><li>Q: 面试流程？</li><li>A: 如果有接下来的流程，还有一轮领导力面试。</li></ul></li></ul><p>（总计 60min）</p><h3 id="三面（通过）-2024-3-21"><a href="#三面（通过）-2024-3-21" class="headerlink" title="三面（通过） - 2024-3-21"></a>三面（通过） - 2024-3-21</h3><ul><li>自我介绍</li><li>聊聊实验室研究方向和项目</li><li>对网络有什么了解？使用 FRR 组网吗？</li><li>讲讲你对 BGP 的理解</li><li>知道 tcpdump 吗？怎么使用？（不会用，只会 Wireshark 😭）</li><li>讲讲 tcp 报文头都有哪些字段吧（寄！）</li><li>本科网络工程专业和别的计算机类专业有什么区别？有什么特殊的课程吗？</li><li>你的 GPA 排名大概是多少？</li><li>平时写代码吗？有接触 C&#x2F;C++ 吗？</li><li>工作地点有什么意向吗？</li><li>反问：<ul><li>Q: 部门工作内容？</li><li>A: （和一二面类似）</li><li>Q: 为什么要专门提到工作意向？</li><li>A: 希望实习在深圳，工作可以选北京，因为领导层都在深圳，可以更多观察实习生是否匹配。</li></ul></li></ul><p>（总计 40min）</p><h2 id="腾讯-TEG-广告工程部"><a href="#腾讯-TEG-广告工程部" class="headerlink" title="腾讯 TEG 广告工程部"></a>腾讯 TEG 广告工程部</h2><h3 id="一面（挂）-2024-3-6"><a href="#一面（挂）-2024-3-6" class="headerlink" title="一面（挂） - 2024-3-6"></a>一面（挂） - 2024-3-6</h3><ul><li><p>自我介绍</p></li><li><p>介绍项目 Nacos</p></li><li><p>根据项目引出问题：分布式链路追踪模型及其基本原理、线程&#x2F;进程&#x2F;协程的对比区别、协程模型与 Java 和 Python 的协程实现…</p></li><li><p>介绍项目 Apache SkyWalking</p></li><li><p>根据项目引出问题：池化技术优缺点、GIL 锁对 Python 线程的影响、项目难点（线程与协程通信）…</p></li><li><p>介绍实验室项目</p></li><li><p>根据项目引出问题：团队协作、项目规划、应付甲方的方式（对，你没看错）…<br>（以上大约 40+min）</p></li><li><p>做题：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">用两个栈实现队列</a></p></li><li><p>反问：</p><ul><li><p>Q: 你们团队主要做什么？</p></li><li><p>A: 我们团队主要做大数据工具（Spark、Flink、Hadoop）的二次开发和封装，提供给其它部门使用</p></li><li><p>Q: Base 情况？</p></li><li><p>A: 只有北京</p></li><li><p>Q: HC 情况？</p></li><li><p>A: 往年招的少，今年应该会多（又汗流浃背了 😓）</p></li><li><p>Q: 对我简历做个基本评价？（旁敲侧击面评 🤭）</p></li><li><p>A：写的还可以</p></li><li><p>Q: 如果有后续，流程大概是怎么样的？</p></li><li><p>A：秋招三轮技术面，你这个实习岗有可能少一些</p></li></ul></li><li><p>最后面试官又问了一句：我们做这些大数据相关的工具，你有没有意愿？我： <strong>意愿的话，我希望等面试流程走完再进一步讨论吧（🤡）</strong></p></li></ul><h2 id="阿里云-ECS"><a href="#阿里云-ECS" class="headerlink" title="阿里云 ECS"></a>阿里云 ECS</h2><h3 id="一面（通过）-2024-3-2"><a href="#一面（通过）-2024-3-2" class="headerlink" title="一面（通过） - 2024-3-2"></a>一面（通过） - 2024-3-2</h3><ul><li><p>自我介绍</p></li><li><p>介绍项目 Nacos</p></li><li><p>介绍项目 Apache SkyWalking</p></li><li><p>介绍实验室项目<br>（以上大约 20+min）</p></li><li><p>讲讲你对协程的理解（结合项目，先从进程和线程关系讲到协程的概念，然后对比 Python 和 Java 的协程实现：asyncio vs Virtual Thread）</p></li><li><p>做题：一个 Map 给出用户喜欢的歌，一个 Map 给出歌手唱过的歌，求用户最喜欢的歌手</p><blockquote><p>特简单的题目结果题目看错了，面试官好心多给了 10 分钟，幸好最后做出来了（汗流浃背了 😓）</p></blockquote></li><li><p>反问：</p><ul><li><p>Q: 你们团队主要做什么？</p></li><li><p>A: （我听下来大概是 ECS 内部中台）</p></li><li><p>Q: 是否有转正名额？</p></li><li><p>A: 阿里云现在只招转正实习生（即有 HC 才招实习）</p></li><li><p>Q: Base 情况？我希望能转正的话可以去杭州</p></li><li><p>A: 杭州为主，北京也有。实习会在北京，会记录你转正后的 Base 意愿</p></li></ul></li></ul><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><h3 id="美团-笔试-2024-3-9"><a href="#美团-笔试-2024-3-9" class="headerlink" title="美团 - 笔试 - 2024-3-9"></a>美团 - 笔试 - 2024-3-9</h3><p>(120 min)</p><table><thead><tr><th align="center">第一题</th><th align="center">第二题</th><th align="center">第三题</th><th align="center">第四题</th><th align="center">第五题</th></tr></thead><tbody><tr><td align="center">100%</td><td align="center">100%</td><td align="center">100%</td><td align="center">70%</td><td align="center">10%</td></tr></tbody></table><h3 id="蚂蚁-笔试-2024-3-16"><a href="#蚂蚁-笔试-2024-3-16" class="headerlink" title="蚂蚁 - 笔试 - 2024-3-16"></a>蚂蚁 - 笔试 - 2024-3-16</h3><p>（100 min）</p><table><thead><tr><th align="center">第一题</th><th align="center">第二题</th><th align="center">第三题</th><th align="center">选择题（15 题）</th></tr></thead><tbody><tr><td align="center">100%</td><td align="center">100%</td><td align="center">5%</td><td align="center">7 单选 5 多选 3 语言题（Java 或 C++二选一）</td></tr></tbody></table><h3 id="米哈游-笔试-2024-3-17"><a href="#米哈游-笔试-2024-3-17" class="headerlink" title="米哈游 - 笔试 - 2024-3-17"></a>米哈游 - 笔试 - 2024-3-17</h3><p>（120 min，做的最烂的一场笔试 🥹）</p><table><thead><tr><th align="center">第一题</th><th align="center">第二题</th><th align="center">第三题</th><th align="center">选择题（15 题）</th></tr></thead><tbody><tr><td align="center">82%</td><td align="center">64%（没想到 BigInteger ，郁闷了一天）</td><td align="center">18%</td><td align="center">单选 + 多选</td></tr></tbody></table><h3 id="阿里云-笔试-2024-3-24"><a href="#阿里云-笔试-2024-3-24" class="headerlink" title="阿里云 - 笔试 - 2024-3-24"></a>阿里云 - 笔试 - 2024-3-24</h3><p>(100 min)</p><table><thead><tr><th align="center">第一题</th><th align="center">第二题</th><th align="center">第三题</th><th align="center">选择题（15 题）</th></tr></thead><tbody><tr><td align="center">100%</td><td align="center">100%</td><td align="center">0%</td><td align="center">8 单选 7 多选</td></tr></tbody></table><h3 id="阿里控股-笔试-2024-3-30"><a href="#阿里控股-笔试-2024-3-30" class="headerlink" title="阿里控股 - 笔试 - 2024-3-30"></a>阿里控股 - 笔试 - 2024-3-30</h3><p>菜！</p><p>(100 min)</p><table><thead><tr><th align="center">第一题</th><th align="center">第二题</th><th align="center">第三题</th><th align="center">选择题（15 题）</th></tr></thead><tbody><tr><td align="center">100%</td><td align="center">18%</td><td align="center">0%</td><td align="center">8 单选 7 多选</td></tr></tbody></table><h3 id="淘天-笔试-2024-4-3"><a href="#淘天-笔试-2024-4-3" class="headerlink" title="淘天 - 笔试 - 2024-4-3"></a>淘天 - 笔试 - 2024-4-3</h3><p>(100 min)</p><table><thead><tr><th align="center">第一题</th><th align="center">第二题</th><th align="center">第三题</th><th align="center">选择题（15 题）</th></tr></thead><tbody><tr><td align="center">100%</td><td align="center">25%</td><td align="center">10%</td><td align="center">8 单选 7 多选</td></tr></tbody></table><h3 id="华为-笔试-2024-4-17"><a href="#华为-笔试-2024-4-17" class="headerlink" title="华为 笔试 - 2024-4-17"></a>华为 笔试 - 2024-4-17</h3><blockquote><p>庆祝第一次笔试 AK ！🎉🎉🎉</p></blockquote><p>(120 min)</p><table><thead><tr><th align="center">第一题</th><th align="center">第二题</th><th align="center">第三题</th></tr></thead><tbody><tr><td align="center">100%</td><td align="center">100%</td><td align="center">100%</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internship </tag>
            
            <tag> 面试 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过代码计算组合数：解决矩阵最大对角路径问题</title>
      <link href="/2024/04/d7afbe85.html"/>
      <url>/2024/04/d7afbe85.html</url>
      
        <content type="html"><![CDATA[<p>组合数 C(n, k)表示从 n 个元素中选择 k 个元素的组合数，其公式为：</p><p>$$<br>C(n, k) &#x3D; \frac{n!}{k!(n-k)!}\tag{1}<br>$$</p><p>其中”!”表示阶乘，即 $n! &#x3D; n * (n-1) * (n-2) * … * 1$。</p><p>然而，直接使用这个公式编写代码计算组合数可能会导致溢出，因为阶乘的值增长非常快。因此，我们通常使用更有效的方法来计算组合数。</p><h1 id="k-分数分解"><a href="#k-分数分解" class="headerlink" title="k 分数分解"></a>k 分数分解</h1><p>我们可以通过变换公式 (1) 得到一个新的适合程序运算的公式，计算过程如下：</p><p>$$<br>C(n, k) &#x3D; \frac{n!}{k!(n-k)!} \<br>&#x3D; (\frac{1}{1} * \frac{1}{2} * \frac{1}{3} * … * \frac{1}{k}) * \frac{n!}{(n-k)!}<br>$$</p><p>展开 $\frac{n!}{(n-k)!}$ 得到：</p><p>$$<br>C(n, k) &#x3D; (\frac{1}{1} * \frac{1}{2} * \frac{1}{3} * … * \frac{1}{k}) * [(n-k+1) * (n-k+2) * … * n] \<br>&#x3D; \frac{(n-k+1)}{1} * \frac{(n-k+2)}{2} * … * \frac{n}{k}\tag{2}<br>$$</p><p>也就是说，我们得到了一个等价的组合数公式 (2) ，通过这个公式，我们能很容易写出一段代码实现组合数的计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">combinationByK</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            res = res * (n - k + i) / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的时间复杂度是 O(k)，空间复杂度是 O(1)。</p><h1 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h1><p>组合数的递推公式是：</p><p>$$<br>C(n, k) &#x3D; C(n-1, k-1) + C(n-1, k)\tag{3}<br>$$</p><p>这个公式的含义是，从 n 个元素中选择 k 个元素的组合数等于从 n-1 个元素中选择 k-1 个元素的组合数（即选择了特定的一个元素）和从 n-1 个元素中选择 k 个元素的组合数（即没有选择特定的那个元素）的和。</p><p>我们很容易直观得想到通过递归的方法实现它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">combinationByDP</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> combination(n - <span class="number">1</span>, k - <span class="number">1</span>) + combination(n - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，这个函数的时间复杂度是 O(2^k)，空间复杂度是 O(k)，效率非常低。因此，我们通常通过动态规划的方法实现这个组合数公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">combinationByDP</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的时间复杂度是 O(nk)，空间复杂度也是 O(nk)，因为我们需要计算并存储所有小于或等于 n 和 k 的组合数。</p><p>相比<a href="#k-%E5%88%86%E6%95%B0%E5%88%86%E8%A7%A3">k 分数分解</a>的方法，这个程序的缺点是它需要更多的时间和空间。因为它需要计算并存储所有小于或等于 n 和 k 的组合数，而不仅仅是 C(n, k)。如果 n 和 k 都非常大，这可能会成为一个问题。然而，如果我们需要计算很多不同的组合数，这个程序可能会更快，因为它可以复用已经计算过的组合数。</p><h1 id="应用：解决矩阵最大对角路径问题"><a href="#应用：解决矩阵最大对角路径问题" class="headerlink" title="应用：解决矩阵最大对角路径问题"></a>应用：解决矩阵最大对角路径问题</h1><p>给定一个 m * n 的矩阵，求从左上角到右下角的最大对角路径的和。对角路径是指从左上角到右下角的路径， <strong>每一步只能向右或向下移动</strong> 。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这是一个经典组合数问题。我们可以这样抽象这个问题：假设我们有一个 m * n 的矩阵，我们要从左上角走到右下角，每次只能向右或向下移动。那么，从左上角到右下角的任何路径都必须包含 m - 1 步向下移动和 n - 1 步向右移动，总共 m + n - 2 步。</p><p>问题就转化为了在 m + n - 2 步中选择 m - 1 步向下移动的方式有多少种，这就是一个组合问题。答案是 $C(m+n-2, m-1)$ 或 $C(m+n-2, n-1)$ ，其中 $C(a, b)$ 表示从 a 个元素中选择 b 个元素的组合数。</p><h2 id="通过-k-分数分解计算组合数"><a href="#通过-k-分数分解计算组合数" class="headerlink" title="通过 k 分数分解计算组合数"></a>通过 k 分数分解计算组合数</h2><p>根据前文的式 (2) ，我们可以得到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试：3 * 7 的矩阵</span></span><br><span class="line">        System.out.println(uniquePaths(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> m + n - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Math.min(m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">            res = res * (a - b + i) / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的时间复杂度是 O(min(m, n))，空间复杂度是 O(1)。</p><h2 id="通过动态规划计算组合数"><a href="#通过动态规划计算组合数" class="headerlink" title="通过动态规划计算组合数"></a>通过动态规划计算组合数</h2><p>我们也可以通过动态规划的方法计算组合数。</p><p>我们可以定义一个二维数组 dp，其中 <code>dp[i][j]</code> 表示从左上角到位置 <code>(i, j)</code> 的路径数量。对于位置 <code>(i, j)</code> ，我们只能从位置 <code>(i-1, j)</code> 或位置 <code>(i, j-1)</code> 到达，所以 <code> dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试：3 * 7 的矩阵</span></span><br><span class="line">        System.out.println(uniquePaths(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的时间复杂度是 O(mn)，空间复杂度也是 O(mn)。</p><p>读者不难看出，这个问题的解法和上文提到的 <a href="#%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F">组合数递推公式</a> 中的动态规划解法本质上是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器突然变得卡顿，怎么办？（2）Java GC 导致的卡顿</title>
      <link href="/2024/04/bd9408a6.html"/>
      <url>/2024/04/bd9408a6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章系列未来计划持续更新，把我在学习&#x2F;实习&#x2F;工作中遇到的相关实际案例记录在这里</p><p>系列综述：</p><p><a href="https://alrisha.cn/2024/03/d1e89f6a.html">服务器突然变得卡顿，怎么办？（1）综述</a></p></blockquote><p>本文内容基于美团技术博客文章 <a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">《Java 中 9 种常见的 CMS GC 问题分析与解决》</a> 算是<strong>转载性质</strong>的章节。尽管在美团博客中提到的是 CMS GC，但是对于其他 GC 实现也是很有参考意义的。</p><p>另外我也推荐一篇最近在看的关于 ZGC 的文章 <a href="https://javadoop.com/post/zgc">《ZGC 介绍》</a> ，这篇文章很好的让我了解了 JDK 最新的 GC 实现方法和思想。</p><p>关于 Java 主要的三大 GC 实现的介绍，可以看以下的系列文章，我认为都是干货满满的：</p><ul><li><a href="https://mp.weixin.qq.com/s/sTj1OSP_h_rrv1cVmgLUlA">新一代 Java 垃圾回收神器：ZGC</a></li><li><a href="https://mp.weixin.qq.com/s/i_fajFhDEjXTzv5Z2tA97w">为什么 G1 能够替代 CMS 回收器？</a></li><li><a href="https://mp.weixin.qq.com/s/17S4WbATE8Sy2-pfyCf21Q">彻底弄懂了 CMS 收集器原理，这个轮子造的真值！</a></li></ul><h1 id="真的是-GC-引发的问题吗？"><a href="#真的是-GC-引发的问题吗？" class="headerlink" title="真的是 GC 引发的问题吗？"></a>真的是 GC 引发的问题吗？</h1><p>首先需要确定的是，在一次 GC 问题处理的过程中，如何判断是 GC 导致的故障，还是系统本身引发 GC 问题？</p><p>在一个系统故障问题中，我们通常会得到下面四个表象指标：</p><ol><li>GC 耗时增大</li><li>线程 Block 增多</li><li>慢查询增多</li><li>CPU 负载高</li></ol><p>一般来说，可以通过以下四个维度思考这个问题：</p><ol><li><strong>时序分析</strong>：发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高（要有足够的时间 Gap），那么整个问题影响链就可能是：<code>CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; 线程 Block 增多 -&gt; RT 上涨</code>。</li><li><strong>概率分析</strong>：使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：<code>慢查询增多 -&gt; GC 耗时增大 -&gt; CPU 负载高 -&gt; 线程 Block 增多 -&gt; RT上涨</code>。</li><li><strong>实验分析</strong>：通过故障演练等方式对问题现场进行模拟，触发其中部分条件（一个或多个），观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：<code>线程Block增多 -&gt; CPU 负载高 -&gt; 慢查询增多 -&gt; GC 耗时增大 -&gt; RT 上涨</code>。</li><li><strong>反证分析</strong>：对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：<code>GC 耗时增大 -&gt; 线程 Block 增多 -&gt; RT 上涨</code>。</li></ol><p>不同的根因，后续的分析方法是完全不同的。如果是 CPU 负载高那可能需要用火焰图看下热点、如果是慢查询增多那可能需要看下 DB 情况、如果是线程 Block 引起那可能需要看下锁竞争的情况。</p><p>这就是说，在很多场景下，很可能并不是 GC 导致的系统问题，如果不事先进行细致的问题定位，很可能会花费大量不必要的时间在错误的方向上。最后如果各个表象证明都没有问题，那可能 GC 确实存在瓶颈，可以继续往下分析。</p><h1 id="GC-问题处理流程"><a href="#GC-问题处理流程" class="headerlink" title="GC 问题处理流程"></a>GC 问题处理流程</h1><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/04/06/XOU6SMuQC2rxT5v.jpg" alt="GC 问题处理流程"></p><h2 id="制定标准"><a href="#制定标准" class="headerlink" title="制定标准"></a>制定标准</h2><p>这块内容其实非常重要，但大部分系统中都是缺失的，缺少预见性。具体来说，需要结合应用系统的 TP9999 时间和延迟、吞吐量等设定具体的指标，而不是被问题驱动。一般情况下，评判 GC 的两个核心指标为：</p><ul><li><strong>延迟（Latency）</strong>： 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。</li><li><strong>吞吐量（Throughput）</strong>： 应用系统的生命周期内，由于 GC 线程会占用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。</li></ul><p>目前各大互联网公司的系统基本都更追求低延时，避免一次 GC 停顿的时间过长对用户体验造成损失，衡量指标主要由如下两点来判断：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/04/06/taEIgOycjJ4hf2H.jpg" alt="主要衡量指标"></p><p>简而言之，即为 <strong>一次停顿的时间不超过应用服务的 TP9999（满足千分之九百九十九的网络请求所需要的最低耗时），GC 的吞吐量不小于 99.99%</strong> 。举个例子，假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30 ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。</p><blockquote><p>除了这两个指标之外还有 Footprint（资源量大小测量）、反应速度等指标，互联网这种实时系统追求低延迟，而很多嵌入式系统则追求 Footprint。</p></blockquote><h2 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h2><p>目前线上服务基本都是分布式服务，某个节点发生问题后，如果条件允许一定不要直接操作重启、回滚等动作恢复，优先通过摘掉流量的方式来恢复，这样我们可以将堆、栈、GC 日志等关键信息保留下来，不然错过了定位根因的时机，后续解决难度将大大增加。当然除了这些，应用日志、中间件日志、内核日志、各种 Metrics 指标等对问题分析也有很大帮助。</p><h2 id="因果分析"><a href="#因果分析" class="headerlink" title="因果分析"></a>因果分析</h2><p>判断 GC 异常与其他系统指标异常的因果关系，可以参考<a href="#%E7%9C%9F%E7%9A%84%E6%98%AF-GC-%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97">上文</a>提到的 4 种分析方法，避免在排查过程中走入误区。</p><h2 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h2><p>确定是 GC 的问题后，可以借助相关的排查工具并通过 5 why 根因分析法以及下午各种常见的场景进行逐一匹配，或者直接参考下述根因鱼骨图，找出问题发生根因，最后再选择优化手段。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/04/06/HXchnVOaosyiLur.png" alt="根因鱼骨图"></p><h2 id="调优建议"><a href="#调优建议" class="headerlink" title="调优建议"></a>调优建议</h2><ul><li><p><strong>Trade Off</strong>：与 CAP 注定要缺一角一样，GC 优化要在延迟（Latency）、吞吐量（Throughput）、容量（Capacity）三者之间进行权衡。</p></li><li><p><strong>最终手段</strong>：GC 发生问题不是一定要对 JVM 的 GC 参数进行调优，大部分情况下是通过 GC 的情况找出一些业务问题，切记上来就对 GC 参数进行调整，当然有明确配置错误的场景除外。</p></li><li><p><strong>控制变量</strong>：控制变量法是在蒙特卡洛（Monte Carlo）方法中用于减少方差的一种技术方法，我们调优的时候尽量也要使用，每次调优过程尽可能只调整一个变量。</p></li><li><p><strong>善用搜索</strong>：理论上 99.99% 的 GC 问题基本都被遇到了，我们要学会使用搜索引擎的高级技巧，重点关注 StackOverFlow、Github 上的 Issue、以及各种论坛博客，先看看其他人是怎么解决的，会让解决问题事半功倍。</p></li><li><p><strong>调优重点</strong>：总体上来讲，我们开发的过程中遇到的问题类型也基本都符合正态分布，太简单或太复杂的基本遇到的概率很低。</p></li><li><p><strong>GC 参数</strong>：如果堆、栈确实无法第一时间保留，一定要保留 GC 日志，这样我们最起码可以看到 GC Cause，有一个大概的排查方向。关于 GC 日志相关参数，最基本的 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 等一些参数就不再提了，建议可以添加以下参数，可以提高我们分析问题的效率。</p></li></ul><table><thead><tr><th align="center">分类</th><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">基本参数</td><td align="left"><code>-XX:+PrintGCDetails</code></p><code>-XX:+PrintGCDatestamps</code></p><code>-XX:+PrintGCTimeStamps</code></td><td align="left">GC 日志的基本参数</td></tr><tr><td align="center">时间相关</td><td align="left"><code>-XX:+PrintGCApplicationConcurrentTime</code></p><code>-XX:+PrintGcApplicationStoppedTime</code></td><td align="left">详细步骤的并行时间，STW 时间等等</td></tr><tr><td align="center">年龄相关</td><td align="left"><code>-XX:+PrintTenuringDistribution</code></td><td align="left">可以观察 GC 前后的对象年龄分布，方便发现过早晋升问题</td></tr><tr><td align="center">空间变化</td><td align="left"><code>-XX:+PrintHeapAtGC</code></td><td align="left">各个空间在 GC 前后的回收情况，非常详细</td></tr><tr><td align="center">引用相关</td><td align="left"><code>-XX:+PrintReferenceGc</code></td><td align="left">观察系统的软引用、弱引用、虚引用等回收情况</td></tr></tbody></table><ul><li><p><strong>其他建议</strong>：</p><ul><li><p><strong>主动式 GC</strong>：也有另开生面的做法，通过监控手段监控观测 Old 区的使用情况，即将到达阈值时将应用服务摘掉流量，手动触发一次 Major GC，减少 CMS GC 带来的停顿，但随之系统的健壮性也会减少，如非必要不建议引入。</p></li><li><p><strong>禁用偏向锁</strong>：偏向锁在只有一个线程使用到该锁的时候效率很高，但是在竞争激烈情况会升级成轻量级锁，此时就需要先消除偏向锁，这个过程是 STW 的。如果每个同步资源都走这个升级过程，开销会非常大，所以在已知并发激烈的前提下，一般会禁用偏向锁 <code>-XX:-UseBiasedLocking</code> 来提高性能。不过，偏向锁在 JDK 15 之后就是默认是关闭的，在现在最新的 LTS JDK 21 中已经彻底移除了偏向锁。</p></li><li><p><strong>虚拟内存</strong>：启动初期有些操作系统（例如 Linux）并没有真正分配物理内存给 JVM ，而是在虚拟内存中分配，使用的时候才会在物理内存中分配内存页，这样也会导致 GC 时间较长。这种情况可以添加 <code>-XX:+AlwaysPreTouch</code> 参数，让 VM 在 commit 内存时跑个循环来强制保证申请的内存真的 commit，避免运行时触发缺页异常。在一些大内存的场景下，有时候能将前几次的 GC 时间降一个数量级，但是添加这个参数后，启动的过程可能会变慢。</p></li></ul></li></ul><h1 id="GC-常见问题罗列"><a href="#GC-常见问题罗列" class="headerlink" title="GC 常见问题罗列"></a>GC 常见问题罗列</h1><p>本文罗列了常见的几种 GC 问题，排查难度从上到下依次递增。在美团博客<a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">原文</a>中列出了部分 CMS 特有的问题，如 <em>CMS Old GC 频繁</em> 、 <em>单次 CMS Old GC 耗时长</em> 等，这里不再赘述。</p><h2 id="GC-常见问题-1：参数配置不当导致的动态扩容"><a href="#GC-常见问题-1：参数配置不当导致的动态扩容" class="headerlink" title="GC 常见问题 1：参数配置不当导致的动态扩容"></a>GC 常见问题 1：参数配置不当导致的动态扩容</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><strong>服务刚刚启动时 GC 次数较多</strong>，最大空间剩余很多但是依然发生 GC。我们可以通过观察 GC 日志或者通过监控工具来观察堆的空间变化情况。GC Cause 一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在 JVM 的参数中 <code>-Xms</code> 和 <code>-Xmx</code> 设置的不一致，在初始化时只会初始 <code>-Xms</code> 大小的空间存储信息，每当空间不够用时再向操作系统申请，这样的话必然要进行一次 GC。</p><p>另外，如果空间剩余很多时也会进行缩容操作，JVM 通过 <code>-XX:MinHeapFreeRatio</code> 和 <code>-XX:MaxHeapFreeRatio</code> 来控制扩容和缩容的比例，调节这两个值也可以控制伸缩的时机。</p><p>整个伸缩的模型理解可以看这个图，当 committed 的空间大小超过了低水位&#x2F;高水位的大小，capacity 也会随之调整：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/04/06/vcpATHfOj6tSER9.jpg" alt="GC 内存伸缩模型"></p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>观察 GC 触发时间点 Old&#x2F;MetaSpace 区的 committed 占比是不是一个固定的值，或者像上文提到的观察总的内存使用率也可以。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>尽量将成对出现的空间大小配置参数设置成固定的</strong>，如 <code>-Xms</code> 和 <code>-Xmx</code>，<code>-XX:MaxNewSize</code> 和 <code>-XX:NewSize</code>，<code>-XX:MetaSpaceSize</code> 和 <code>-XX:MaxMetaSpaceSize</code> 等。</p><p>一般来说，我们需要保证 Java 虚拟机的堆是稳定的，确保 <code>-Xms</code> 和 <code>-Xmx</code> 设置的是一个值（即初始值和最大值一致），获得一个稳定的堆，同理在 MetaSpace 区也有类似的问题。不过在不追求停顿时间的情况下震荡的空间也是有利的，可以动态地伸缩以节省空间，例如作为富客户端的 Java 应用。</p><h2 id="GC-常见问题-2：显式-GC"><a href="#GC-常见问题-2：显式-GC" class="headerlink" title="GC 常见问题 2：显式 GC"></a>GC 常见问题 2：显式 GC</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p>除了扩容缩容会触发 GC 之外，还有 Old 区达到回收阈值、MetaSpace 空间不足、Young 区晋升失败、大对象担保失败等几种触发条件，如果这些情况都没有发生却触发了 GC ？这种情况有可能是代码中手动调用了 <code>System.gc</code> 方法，此时可以找到 GC 日志中的 GC Cause 确认。</p><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p><code>System.gc</code> 会引发一次 STW 的 Full GC。如果在应用程序中 <code>System.gc</code> 被频繁调用，显然是难以接受的。为此，有些资料提出添加 <code>-XX:+DisableExplicitGC</code> 参数来避免这种 GC。</p><p>但如果禁用掉的话就会带来另外一个内存泄漏问题，此时就需要说一下 <code>DirectByteBuffer</code>，它有着零拷贝等特点，被 Netty 等各种 NIO 框架使用，会使用到堆外内存。堆内存由 JVM 自己管理，堆外内存必须要手动释放，这依赖于<code>System.gc</code>的调用。如果打开了 <code>-XX:+DisableExplicitGC</code>，清理工作就可能得不到及时完成，于是就有发生 Direct Memory 的 OOM。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>无论是保留还是去掉都会有一定的风险点，不过目前互联网中的 RPC 通信会大量使用 NIO，所以总体来说<strong>建议保留这种 GC 方式</strong>。</p><p>我们可以采用 JVM 提供的 <code>-XX:+ExplicitGCInvokesConcurrent</code> 和 <code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code> 参数来将 <code>System.gc</code> 的触发类型从 <code>Foreground</code>（串行 GC） 改为 <code>Background</code>（并行 GC），这样的话就能大幅降低了 STW 开销，同时也不会发生 NIO Direct Memory OOM。</p><p>不止 CMS，在 G1 或 ZGC 中开启 <code>ExplicitGCInvokesConcurrent</code> 模式，都会采用高性能的并发收集方式进行收集，不过还是建议在代码规范方面也要做好约束，规范好 <code>System.gc</code> 的使用。</p><blockquote><p>HotSpot 对 <code>System.gc</code> 有特别处理，最主要的地方体现在一次 <code>System.gc</code> 是否与普通 GC 一样会触发 GC 的统计&#x2F;阈值数据的更新，HotSpot 里的许多 GC 算法都带有自适应的功能，会根据先前收集的效率来决定接下来的 GC 中使用的参数，但 <code>System.gc</code> 默认不更新这些统计数据，避免用户强行 GC 对这些自适应功能的干扰（可以参考 <code>-XX:+UseAdaptiveSizePolicyWithSystemGC</code> 参数，默认是 false）</p></blockquote><h2 id="GC-常见问题-3：MetaSpace-区-OOM"><a href="#GC-常见问题-3：MetaSpace-区-OOM" class="headerlink" title="GC 常见问题 3：MetaSpace 区 OOM"></a>GC 常见问题 3：MetaSpace 区 OOM</h2><h3 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h3><p>JVM 在启动后或者某个时间点开始，MetaSpace 的已使用大小在持续增长，同时每次 GC 也无法释放，调大 MetaSpace 空间也无法彻底解决。</p><h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><h4 id="MetaSpace-区都存放了什么数据？"><a href="#MetaSpace-区都存放了什么数据？" class="headerlink" title="MetaSpace 区都存放了什么数据？"></a>MetaSpace 区都存放了什么数据？</h4><p>Java7 之前字符串常量池被放到了 Perm 区（俗称永久代），所有被 intern 的 String 都会被存在这里，由于 String.intern 是不受控的，所以 <code>-XX:MaxPermSize</code> 的值也不太好设置，经常会出现 <code>java.lang.OutOfMemoryError: PermGen space</code> 异常，所以在 Java7 之后常量池等字面量（Literal）、类静态变量（Class Static）、符号引用（Symbols Reference）等几项被移到 Heap 中。而 Java8 之后 PermGen 也被移除，取而代之的是 MetaSpace。</p><p>在最底层，JVM 通过 mmap 接口向操作系统申请内存映射，每次申请 2MB 空间，这里是虚拟内存映射，不是真的就消耗了主存的 2MB，只有之后在使用的时候才会真的消耗内存。申请的这些内存放到一个链表中 VirtualSpaceList，作为其中的一个 Node。</p><p>在上层，MetaSpace 主要由 Klass Metaspace 和 NoKlass Metaspace 两大部分组成。</p><ul><li><strong>Klass MetaSpace</strong>：就是用来存 Klass 的，就是 Class 文件在 JVM 里的运行时数据结构，这部分默认放在 Compressed Class Pointer Space 中，是一块连续的内存区域，紧接着 Heap。Compressed Class Pointer Space 不是必须有的，如果设置了 -XX:-UseCompressedClassPointers，或者 -Xmx 设置大于 32 G，就不会有这块内存，这种情况下 Klass 都会存在 NoKlass Metaspace 里。</li><li><strong>NoKlass MetaSpace</strong>：专门来存 Klass 相关的其他的内容，比如 Method，ConstantPool 等，可以由多块不连续的内存组成。虽然叫做 NoKlass Metaspace，但是也其实可以存 Klass 的内容，上面已经提到了对应场景。</li></ul><h4 id="MetaSpace-区的内存管理特点"><a href="#MetaSpace-区的内存管理特点" class="headerlink" title="MetaSpace 区的内存管理特点"></a>MetaSpace 区的内存管理特点</h4><ul><li><strong>MetaSpace 内存管理</strong>：类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的。</li><li><strong>MetaSpace 弹性伸缩</strong>：由于 MetaSpace 空间和 Heap 并不在一起，所以这块的空间可以不用设置或者单独设置，一般情况下避免 MetaSpace 耗尽 VM 内存都会设置一个 MaxMetaSpaceSize，在运行过程中，如果实际大小小于这个值，JVM 就会通过 <code>-XX:MinMetaspaceFreeRatio</code> 和 <code>-XX:MaxMetaspaceFreeRatio</code> 两个参数动态控制整个 MetaSpace 的大小。</li></ul><p>由问题 1 可知，为了避免弹性伸缩带来的额外 GC 消耗，我们会将 <code>-XX:MetaSpaceSize</code> 和 <code>-XX:MaxMetaSpaceSize</code> 两个值设置为固定的，但是这样也会导致在空间不够的时候无法扩容，然后频繁地触发 GC，最终 OOM。所以关键原因就是 <strong>ClassLoader 不停地在内存中 load 了新的 Class ，一般这种问题都发生在动态类加载等情况上</strong>。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>可以 dump 快照之后通过 JProfiler 或 MAT 观察 Classes 的 Histogram（直方图） 即可，或者直接通过命令即可定位， jcmd 打几次 Histogram 的图，看一下具体是哪个包下的 Class 增加较多就可以定位了。不过有时候也要结合 InstBytes、KlassBytes、Bytecodes、MethodAll 等几项指标综合来看下。</p><p>如果无法从整体的角度定位，可以添加 <code>-XX:+TraceClassLoading</code> 和 <code>-XX:+TraceClassUnLoading</code> 参数观察详细的类加载和卸载信息。</p><p>一般来说问题基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等技术点上。在可观测性层面上，我们也应当及时给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。</p><h2 id="GC-常见问题-4：过早晋升"><a href="#GC-常见问题-4：过早晋升" class="headerlink" title="GC 常见问题 4：过早晋升"></a>GC 常见问题 4：过早晋升</h2><h3 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h3><p>这种场景主要发生在分代的收集器上面（例如 JDK 21 之前的 ZGC 就是没有分代机制的），“过早晋升”专业的术语称为 <em>Premature Promotion</em> 。90% 的对象朝生夕死，只有在 Young 区经历过几次 GC 的洗礼后才会晋升到 Old 区，每经历一次 GC 对象的 GC Age 就会增长 1，最大通过 <code>-XX:MaxTenuringThreshold</code> 来控制。</p><p>过早晋升一般不会直接影响 GC，总会伴随着浮动垃圾、大对象担保失败等问题，但这些问题不是立刻发生的，我们可以观察以下几种现象来判断是否发生了过早晋升。</p><ul><li><strong>分配速率接近于晋升速率，对象晋升年龄较小</strong>：GC 日志中出现 “Desired survivor size *** bytes, new threshold 1(max 6)”等信息，说明此时经历过一次 GC 就会放到 Old 区。</li><li><strong>Full GC 比较频繁，且经历过一次 GC 之后 Old 区的变化比例非常大</strong>：比如说 Old 区触发的回收阈值是 80%，经历过一次 GC 之后下降到了 10%，这就说明 Old 区的 70% 的对象存活时间其实很短。</li></ul><p>过早晋升的主要危害为：</p><ul><li>Young GC 频繁，总的吞吐量下降。</li><li>Full GC 频繁，可能会有较大停顿。</li></ul><h3 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h3><p>主要的原因有以下几点：</p><ul><li><p><strong>Young&#x2F;Eden 区过小</strong>：过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升，Young GC 采用的是复制算法，而 copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间（CMS 扫描 Card Table 或 G1 扫描 Remember Set 出问题的情况另说），没来及回收的对象增大了回收的代价，所以 Young GC 时间增加，同时又无法快速释放空间，Young GC 次数也跟着增加。</p></li><li><p><strong>对象分配速率过大</strong>：可以观察出问题前后 Mutator（应用执行的主要线程，和 GC 线程对应） 的对象分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。</p></li><li><p><strong>晋升年龄参数设置不合理</strong>：JVM 通过 <code>-XX:MaxTenuringThreshold</code> 参数来控制晋升年龄，每经过一次 GC，年龄就会加一，达到最大年龄就可以进入 Old 区，最大值为 15（因为 JVM 中使用 4 个比特来表示对象的年龄）。设定固定的 MaxTenuringThreshold 值作为晋升条件：</p><ul><li>MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生，Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。</li><li>MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。</li></ul></li></ul><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>如果是 <strong>Young&#x2F;Eden 区过小</strong>：我们可以在总的 Heap 内存不变的情况下适当增大 Young 区，具体怎么增加？一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。</li><li>如果是<strong>对象分配速率过大</strong>：<ul><li>偶发较大：通过内存分析工具找到问题代码，从业务逻辑上做一些优化。</li><li>一直较大：当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。</li></ul></li><li>如果是<strong>晋升年龄参数设置不合理</strong>：调整 <code>-XX:+PrintTenuringDistribution</code> 参数</li></ul><p>过早晋升问题一般不会特别明显，但日积月累之后可能会爆发一波收集器退化之类的问题，所以我们还是要提前避免掉的，可以看看自己系统里面是否有这些现象，如果比较匹配的话，可以尝试优化一下。一行代码优化的 ROI 还是很高的。</p><p>当然，反过来思考，如果在观察 Old 区前后比例变化的过程中，发现可以回收的比例非常小，如从 80% 只回收到了 60%，说明我们大部分对象都是存活的，此时 Old 区的空间可以适当调大些。</p><h2 id="GC-常见问题-5：内存碎片-amp-收集器退化"><a href="#GC-常见问题-5：内存碎片-amp-收集器退化" class="headerlink" title="GC 常见问题 5：内存碎片&amp;收集器退化"></a>GC 常见问题 5：内存碎片&amp;收集器退化</h2><h3 id="现象-4"><a href="#现象-4" class="headerlink" title="现象"></a>现象</h3><p>以 CMS 为例，并发的 CMS GC 算法，可能退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p><ul><li>带压缩动作的算法，称为 MSC，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。</li><li>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</li></ul><h3 id="原因-4"><a href="#原因-4" class="headerlink" title="原因"></a>原因</h3><h4 id="晋升失败（Promotion-Failed）"><a href="#晋升失败（Promotion-Failed）" class="headerlink" title="晋升失败（Promotion Failed）"></a>晋升失败（Promotion Failed）</h4><p>晋升失败就是指在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。直觉上乍一看这种情况可能会经常发生，但其实因为有 concurrentMarkSweepThread 和担保机制的存在，发生的条件是很苛刻的，除非是短时间将 Old 区的剩余空间迅速填满，例如上文中提到的过早晋升。</p><p>另外还有一种情况就是内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/04/06/KIqPio614RLb3Ze.png" alt="内存碎片"></p><p>内存碎片带来了两个问题：</p><ul><li><strong>空间分配效率较低</strong>：如果是连续的空间 JVM 可以通过使用 pointer bumping 的方式来分配，而对于这种有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问，查找可以存放新建对象的地址。</li><li><strong>空间利用效率变低</strong>：Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象，也就是本文所说的问题。</li></ul><h4 id="增量收集担保失败"><a href="#增量收集担保失败" class="headerlink" title="增量收集担保失败"></a>增量收集担保失败</h4><p>分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之，则代表不安全，不进行 Young GC，直接触发 Full GC。</p><h4 id="显式-GC"><a href="#显式-GC" class="headerlink" title="显式 GC"></a>显式 GC</h4><p>见<a href="#GC-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2%EF%BC%9A%E6%98%BE%E5%BC%8F-GC">常见问题 2</a></p><h4 id="并发模式失败（Concurrent-Mode-Failure）"><a href="#并发模式失败（Concurrent-Mode-Failure）" class="headerlink" title="并发模式失败（Concurrent Mode Failure）"></a>并发模式失败（Concurrent Mode Failure）</h4><p>最后一种情况，也是发生概率较高的一种，在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。</p><p>为什么 CMS GC 正在执行还会导致收集器退化呢？主要是由于 CMS 无法处理浮动垃圾（Floating Garbage）引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。所以 Old 区回收的阈值不能太高，否则预留的内存空间很可能不够，从而导致 Concurrent Mode Failure 发生。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p><strong>内存碎片</strong>：通过配置 <code>-XX:UseCMSCompactAtFullCollection=true</code> 来控制 Full GC 的过程中是否进行空间的整理（默认开启，注意是 Full GC，不是普通 CMS GC），以及 <code>-XX: CMSFullGCsBeforeCompaction=n</code> 来控制多少次 Full GC 后进行一次压缩。</p></li><li><p><strong>增量收集</strong>：降低触发 CMS GC 的阈值，即参数 <code>-XX:CMSInitiatingOccupancyFraction</code> 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 <code>-XX:+UseCMSInitiatingOccupancyOnly</code> 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。</p></li><li><p><strong>浮动垃圾</strong>：视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 <code>-XX:+CMSScavengeBeforeRemark</code> 在过程中提前触发一次 Young GC，防止后续晋升过多对象。</p></li></ul><p>正常情况下触发并发模式的 CMS GC，停顿非常短，对业务影响很小，但 CMS GC 退化后，影响会非常大，建议发现一次后就彻底根治。只要能定位到内存碎片、浮动垃圾、增量收集相关等具体产生原因，还是比较好解决的。</p><p>关于内存碎片这块，如果 <code>-XX:CMSFullGCsBeforeCompaction</code> 的值不好选取的话，可以使用 <code>-XX:PrintFLSStatistics</code> 来观察内存碎片率情况，然后再设置具体的值。</p><p>最后就是在编码的时候也要避免需要连续地址空间的大对象的产生，如过长的字符串，用于存放附件、序列化或反序列化的 byte 数组等，还有就是过早晋升问题尽量在爆发问题前就避免掉。</p><h2 id="GC-常见问题-6：堆外内存-OOM"><a href="#GC-常见问题-6：堆外内存-OOM" class="headerlink" title="GC 常见问题 6：堆外内存 OOM"></a>GC 常见问题 6：堆外内存 OOM</h2><h3 id="现象-5"><a href="#现象-5" class="headerlink" title="现象"></a>现象</h3><p>内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，<strong>通过 top 命令发现 Java 进程的 RES 甚至超过了 <code>-Xmx</code> 的大小</strong>。出现这些现象时，基本可以确定是出现了堆外内存泄漏。</p><h3 id="原因-5"><a href="#原因-5" class="headerlink" title="原因"></a>原因</h3><p>可以使用 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html">NMT</a> 确定是哪种原因导致的堆外内存泄漏。在项目中添加 <code>-XX:NativeMemoryTracking=detail</code> JVM 参数后重启项目（需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗）。使用命令 jcmd pid VM.native_memory detail 查看内存分布。重点观察 total 中的 committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 Unsafe.allocateMemory 和 DirectByteBuffer 申请的内存，但是不包含其他 Native Code（C 代码）申请的堆外内存。</p><p>如果 total 中的 committed 和 top 中的 RES 相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。</p><h4 id="主动申请堆外内存未释放"><a href="#主动申请堆外内存未释放" class="headerlink" title="主动申请堆外内存未释放"></a>主动申请堆外内存未释放</h4><p>JVM 使用 <code>-XX:MaxDirectMemorySize=size</code> 参数来控制可申请的堆外内存的最大值。在 Java 8 中，如果未配置该参数，默认和 <code>-Xmx</code> 相等。</p><p>NIO 和 Netty 都会取 <code>-XX:MaxDirectMemorySize</code> 配置的值，来限制申请的堆外内存的大小。NIO 和 Netty 中还有一个计数器字段，用来计算当前已申请的堆外内存大小，NIO 中是 <code>java.nio.Bits#totalCapacity</code>、Netty 中是 <code>io.netty.util.internal.PlatformDependent#DIRECT_MEMORY_COUNTER</code>。</p><p>当申请堆外内存时，NIO 和 Netty 会比较计数器字段和最大值的大小，如果计数器的值超过了最大值的限制，会抛出 OOM 的异常。</p><ul><li>NIO 中是：<code>OutOfMemoryError: Direct buffer memory</code>。</li><li>Netty 中是：<code>OutOfDirectMemoryError: failed to allocate capacity byte(s) of direct memory (used: usedMemory , max: DIRECT_MEMORY_LIMIT)</code>。</li></ul><p>我们可以检查代码中是如何使用堆外内存的，NIO 或者是 Netty，通过反射，获取到对应组件中的计数器字段，并在项目中对该字段的数值进行打点，即可准确地监控到这部分堆外内存的使用情况。</p><p>此时，可以通过 Debug 的方式确定使用堆外内存的地方是否正确执行了释放内存的代码。另外，需要检查 JVM 的参数是否有 <code>-XX:+DisableExplicitGC</code> 选项，如果有就去掉，因为该参数会使 System.gc 失效。（见<a href="#GC-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-2%EF%BC%9A%E6%98%BE%E5%BC%8F-GC">GC 常见问题 2</a>）</p><h4 id="通过-JNI-调用的-Native-Code-申请的内存未释放"><a href="#通过-JNI-调用的-Native-Code-申请的内存未释放" class="headerlink" title="通过 JNI 调用的 Native Code 申请的内存未释放"></a>通过 JNI 调用的 Native Code 申请的内存未释放</h4><p>这种情况排查起来比较困难，我们可以通过 Google perftools + Btrace 等工具，帮助我们分析出问题的代码在哪里。</p><p>除了项目本身的原因，还可能有外部依赖导致的泄漏，如 Netty 和 Spring Boot。</p><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>首先可以使用 NMT + jcmd 分析泄漏的堆外内存是哪里申请，确定原因后，使用不同的手段，进行原因定位。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2024/04/06/VkW6jyT5xbiDP7v.png" alt="堆外内存泄漏解决方案"></p><h2 id="GC-常见问题-7：JNI-引发的-GC-问题"><a href="#GC-常见问题-7：JNI-引发的-GC-问题" class="headerlink" title="GC 常见问题 7：JNI 引发的 GC 问题"></a>GC 常见问题 7：JNI 引发的 GC 问题</h2><h3 id="现象-6"><a href="#现象-6" class="headerlink" title="现象"></a>现象</h3><p>在 GC 日志中，出现 GC Cause 为 <code>GCLocker Initiated GC</code>。</p><h3 id="原因-6"><a href="#原因-6" class="headerlink" title="原因"></a>原因</h3><p>JNI（Java Native Interface）意为 Java 本地调用，它允许 Java 代码和其他语言写的 Native 代码进行交互。JNI 如果需要获取 JVM 中的 String 或者数组，有两种方式：</p><ul><li>拷贝传递。</li><li>共享引用（指针），性能更高。</li></ul><p>由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</p><p>GC Locker 可能导致的不良后果有：</p><ol><li>如果此时是 Young 区不够 Allocation Failure 导致的 GC，由于无法进行 Young GC，会将对象直接分配至 Old 区。</li><li>如果 Old 区也没有空间了，则会等待锁释放，导致线程阻塞。</li><li>可能触发额外不必要的 Young GC，JDK 有一个 Bug，有一定的几率，本来只该触发一次 GCLocker Initiated GC 的 Young GC，实际发生了一次 Allocation Failure GC 又紧接着一次 GCLocker Initiated GC。是因为 GCLocker Initiated GC 的属性被设为 full，导致两次 GC 不能收敛。</li></ol><h3 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>添加 <code>-XX+PrintJNIGCStalls</code> 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。</p></li><li><p>JNI 调用需要谨慎，不一定可以提升性能，反而可能造成 GC 问题。</p></li><li><p>升级 JDK 版本到 14 及以上，避免 <a href="https://bugs.openjdk.org/browse/JDK-8048556">JDK-8048556</a> 导致的重复 GC。</p></li></ul><p>JNI 产生的 GC 问题较难排查，需要谨慎使用。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
            <tag> CPU </tag>
            
            <tag> Memory </tag>
            
            <tag> Network </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器突然变得卡顿，怎么办？（1）综述</title>
      <link href="/2024/03/d1e89f6a.html"/>
      <url>/2024/03/d1e89f6a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章系列未来计划持续更新，把我在学习&#x2F;实习&#x2F;工作中遇到的相关实际案例记录在这里</p><p>系列目录：</p><ol><li>综述：本文章</li><li>Java GC 导致的卡顿：<a href="https://alrisha.cn/2024/04/bd9408a6.html">https://alrisha.cn/2024/04/bd9408a6.html</a></li></ol></blockquote><p>这是一道经典的面试场景题，但也可以说是实际开发过程中最经常遇到的问题之一。实际上，这个问题问的是当服务器出现不可用情况时，应当如何快速排查、定位问题并解决问题。</p><h1 id="可能的卡顿原因"><a href="#可能的卡顿原因" class="headerlink" title="可能的卡顿原因"></a>可能的卡顿原因</h1><p>对于卡顿原因，一般来说可以从以下几个大方考虑：</p><ul><li><p><strong>CPU</strong> : 当 CPU 占用过高时，服务器自然会发生卡顿。</p><ol><li><em>CPU 密集型任务</em> ：如果运行的服务是 CPU 密集型的任务，那么 CPU 资源占用是不可避免的，此时为了确保服务器自身的可用性，可以对这个 CPU 密集型任务做一定的 CPU 资源隔离（限制核数、限制抢占的时间片等）</li><li><em>并发竞争</em> ：如果发生比较严重的多线程竞争行为，线程频繁切换上下文也会导致 CPU 占用过高</li><li><em>持续占用</em> ：忙等待、死循环、JVM Full GC 等操作，会导致线程长时间占用并浪费 CPU 资源，具体也体现为 CPU 占用过高</li><li><em>恶意软件</em> ：（小概率）</li><li><em>硬件问题</em> ：（如过热降频，小概率）</li></ol></li><li><p><strong>内存</strong> : 内存占用过高也会产生卡顿</p><ol><li><em>内存泄漏</em> ：这是最常见的原因。当程序的代码中存在错误，使得它无法释放不再使用的内存时，就会发生内存泄漏。随着时间的推移，这些未释放的内存会越来越多，最终可能耗尽所有的内存。</li><li><em>缓存占用</em> ：有些程序会使用内存作为缓存，以提高数据访问的速度。如果缓存的大小没有得到有效的控制，可能会占用大量的内存。</li><li><em>大数据量处理</em> ：如果程序需要处理大量的数据，例如大型数据库操作、大文件读写等，可能会占用大量的内存。</li><li><em>多进程或多线程</em> ：每个进程或线程都会占用一定的内存。如果启动了大量的进程或线程，可能会占用大量的内存。</li><li><em>恶意软件</em> ：（小概率）</li></ol></li><li><p><strong>网络</strong> : 网络问题也会使得服务器出现卡顿</p><ol><li><em>网络带宽不足</em> ：如果服务器的网络带宽不足，无法满足应用的需求，那么可能会导致服务器响应变慢，甚至出现卡顿。</li><li><em>网络延迟高</em> ：如果服务器与客户端之间的网络延迟（latency）过高，那么客户端可能会感觉到服务器响应慢，这也可能被误认为是服务器卡顿。</li><li><em>网络丢包</em> ：如果网络中出现丢包，那么 TCP 协议会尝试重新发送丢失的数据包，这会增加网络延迟，降低网络吞吐量，可能导致服务器卡顿。</li><li><em>网络攻击</em> ：例如 DDoS 攻击（分布式拒绝服务攻击）可能会消耗大量的网络带宽，导致正常的网络请求无法得到响应，从而使服务器卡顿。</li><li><em>网络设备故障</em> ：例如路由器、交换机等网络设备的故障，也可能导致网络连接不稳定，从而影响服务器的性能（请注意，在网络问题中，设备故障 <strong>往往不是</strong> 小概率事件）。</li></ol></li><li><p><strong>其它</strong> :</p><ol><li>应用业务链路上的问题也会导致服务器卡顿，例如数据库慢查询、全表扫描&#x2F;索引未命中等</li><li>硬件设备的问题，如磁盘 I&#x2F;O 瓶颈、磁盘空间不足，但这些情况有时无法通过软件手段解决</li><li>…</li></ol></li></ul><h1 id="案例：Java-线程阻塞导致的高-CPU-占用"><a href="#案例：Java-线程阻塞导致的高-CPU-占用" class="headerlink" title="案例：Java 线程阻塞导致的高 CPU 占用"></a>案例：Java 线程阻塞导致的高 CPU 占用</h1><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CountDownLatch 实例，计数器的初始值为 1</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动一个工作线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; started.&quot;</span>);</span><br><span class="line">            <span class="comment">// 死循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                n = (n + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished.&quot;</span>);</span><br><span class="line">            <span class="comment">// 线程完成后，计数器减 1</span></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动三个等待线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待工作线程完成</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; started after all work threads finished.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例代码中，三个等待线程将永远不会被唤醒，因为工作线程一直在死循环中。这会导致 CPU 占用过高，从而使得服务器出现卡顿。</p><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>当服务器卡顿时，首先通过 <code>top</code> 指令查看高 CPU 占用的进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top - 16:10:59 up  2:15,  0 <span class="built_in">users</span>,  load average: 1.10, 1.03, 1.01</span><br><span class="line">任务:  66 total,   1 running,  65 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  5.1 us,  0.3 sy,  0.0 ni, 94.6 <span class="built_in">id</span>,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :  15828.4 total,  12199.9 free,   2143.8 used,   1484.7 buff/cache</span><br><span class="line">MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  13357.7 avail Mem</span><br><span class="line"></span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">  10136 alrisha   20   0 7270604  71140  19584 S  99.7   0.4  72:29.96 java</span><br><span class="line">   1187 alrisha   20   0   22.2g 627804  49520 S   2.7   3.9   2:06.34 node</span><br><span class="line">   1303 alrisha   20   0  817108  74448  38352 S   0.3   0.5   0:12.21 node</span><br><span class="line">      1 root      20   0  166272  11476   8128 S   0.0   0.1   0:00.58 systemd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时，进程 <code>10136</code> 占用的最多的 CPU 资源。</p><p>接下来，通过 <code>top -H -p 10136</code> 查看该进程的线程情况。其中，<code>-H</code> 参数表示显示线程信息，<code>-p</code> 参数表示指定进程号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">top - 16:13:13 up  2:17,  0 <span class="built_in">users</span>,  load average: 1.02, 1.02, 1.00</span><br><span class="line">Threads:  23 total,   1 running,  22 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  5.0 us,  0.2 sy,  0.0 ni, 94.5 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st</span><br><span class="line">MiB Mem :  15828.4 total,  12196.8 free,   2146.5 used,   1485.1 buff/cache</span><br><span class="line">MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  13355.1 avail Mem</span><br><span class="line"></span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">  10155 alrisha   20   0 7270604  71140  19584 R  99.9   0.4  74:41.01 Thread-0</span><br><span class="line">  10148 alrisha   20   0 7270604  71140  19584 S   0.3   0.4   0:00.35 Monitor Deflati</span><br><span class="line">  10136 alrisha   20   0 7270604  71140  19584 S   0.0   0.4   0:00.00 java</span><br><span class="line">  10137 alrisha   20   0 7270604  71140  19584 S   0.0   0.4   0:00.02 java</span><br><span class="line">  10138 alrisha   20   0 7270604  71140  19584 S   0.0   0.4   0:00.00 GC Thread<span class="comment">#0</span></span><br><span class="line">  10139 alrisha   20   0 7270604  71140  19584 S   0.0   0.4   0:00.00 G1 Main Marker</span><br><span class="line">  10140 alrisha   20   0 7270604  71140  19584 S   0.0   0.4   0:00.00 G1 Conc<span class="comment">#0</span></span><br><span class="line">  10141 alrisha   20   0 7270604  71140  19584 S   0.0   0.4   0:00.00 G1 Refine<span class="comment">#0</span></span><br><span class="line">  10142 alrisha   20   0 7270604  71140  19584 S   0.0   0.4   0:00.55 G1 Service</span><br><span class="line">  10143 alrisha   20   0 7270604  71140  19584 S   0.0   0.4   0:00.09 VM Thread</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意此时 <code>top</code> 显示的 <em>进程号</em> 实际上代表的是 <em>线程 ID</em> ，因此可以看到 <code>Thread-0</code> 占用了大量的 CPU 资源，其线程号为 <code>10155</code>，16 进制表示为 <code>0x27ab</code>。</p><p>接下来，通过 <code>jstack</code> 命令查看线程 <code>10155</code> 的堆栈，然后找到线程 <code>10155</code> 有关的前 10 行堆栈信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 10136 | grep -A 10 0x27ab</span><br></pre></td></tr></table></figure><blockquote><p>如果希望把全部堆栈信息输入一个 log 文件，可以使用 <code>jstack 10136 &gt; jstack.log</code> 命令。</p></blockquote><p>终端输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alrisha@Aquarius:~$ jstack 10136 | grep -A 10 0x27ab</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span> <span class="comment">#22 prio=5 os_prio=0 cpu=4957330.50ms elapsed=4954.81s tid=0x00007ff5a01be050 nid=0x27ab runnable  [0x00007ff522dfb000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at edu.bupt.App.lambda$main<span class="variable">$0</span>(App.java:20)</span><br><span class="line">        at edu.bupt.App$$Lambda<span class="variable">$1</span>/0x00007ff524000a08.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(java.base@17.0.10/Thread.java:840)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#23 prio=5 os_prio=0 cpu=0.33ms elapsed=4954.81s tid=0x00007ff5a01bf1d0 nid=0x27ac waiting on condition  [0x00007ff522cfb000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at jdk.internal.misc.Unsafe.park(java.base@17.0.10/Native Method)</span><br><span class="line">        - parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x000000071801b318&gt; (a java.util.concurrent.CountDownLatch<span class="variable">$Sync</span>)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(java.base@17.0.10/LockSupport.java:211)</span><br><span class="line">alrisha@Aquarius:~$</span><br></pre></td></tr></table></figure><p>可以看到，在示例代码的第 20 行，<code>Thread-0</code> 正在执行一个死循环。至此，定位完毕。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
            <tag> CPU </tag>
            
            <tag> Memory </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花式实现三个线程交替打印ABC</title>
      <link href="/2024/02/81afead4.html"/>
      <url>/2024/02/81afead4.html</url>
      
        <content type="html"><![CDATA[<p>“实现三个线程交替打印 ABC”是一道面试经典问题。网络上实际上也有了很多的解决方案，包括通过 <code>synchronized</code> 、<code>Semaphore</code> 、<code>ReentrantLock</code> 或是 <code>CyclicBarrier</code> 等方式实现。</p><p>这里我总结一下这些方案的特点，并提出几种我自己的代码实现。</p><blockquote><p>以下实现实际上在原问题上更近一步：结果必须输出特定数量的 <code>ABC</code> 字符串</p></blockquote><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>综合所有方案来看，本问题本质上是对一个状态机进行建模，也即不同的线程需要实现如下状态转换过程：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A ...</span><br></pre></td></tr></table></figure><p>我们知道，线程并行时执行顺序是不确定的，因此需要通过锁机制确保以上的状态转移过程。思路应该是：</p><ol><li>线程 A 首先获取锁 L 打印 A，此时线程 B 和 C 获取不到锁 L 被阻塞；</li><li>线程 A 打印任务结束，释放锁 L，此时 <strong>线程 B</strong> 需要拿到锁 L 打印 B ，我们需要确保线程 C 不能在此时获取锁；</li><li>线程 B 打印结束，线程 C 拿到锁 L ，线程 A 不能在此时获取锁；</li><li>以此类推…</li></ol><p>因此，主要难点实际上在于，<strong>如何保证只有下一个状态的线程在锁释放后一定能拿到锁</strong>。</p><p>我们可以有两种主要的解决方案：</p><ol><li><em>方案一：</em> 对每两个线程之间维护一个锁，只有在上一个线程执行完毕后才能释放这个锁，让下一个状态的线程继续执行，其他锁都不会释放。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread A -- Lock1 --&gt; Thread B -- Lock2 --&gt; Thread C -- Lock3 --&gt; Thread A --&gt; Lock1 ...</span><br></pre></td></tr></table></figure></li><li><em>方案二：</em> 维护一个状态变量 <code>state</code>，记录当前状态。每个线程判断该变量目前是否符合自己的执行状态，进而决定打印字符&#x2F;放弃操作。</li></ol><p>很显然，第二种方案更加直观，并且仅需要维护一个锁（甚至<a href="#Atomic-%E5%8F%98%E9%87%8F%E6%97%A0%E9%94%81%E6%96%B9%E6%A1%88">不需要锁</a>），占用资源更少。以下章节以方案二为基本思路给出两种比较清晰直白的解决方案。</p><p>关于方案一的实现，可以参考这些文章：</p><ul><li><a href="https://blog.csdn.net/m0_71777195/article/details/131608738">多线程知识：三个线程如何交替打印 ABC 循环 100 次</a></li><li><a href="https://blog.csdn.net/xiaokang123456kao/article/details/77331878">多线程交替打印 ABC 的多种实现方法</a></li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="ReentrantLock-Condition"><a href="#ReentrantLock-Condition" class="headerlink" title="ReentrantLock + Condition"></a>ReentrantLock + Condition</h2><p>下面是一个使用 <code>ReentrantLock</code> 和 <code>Condition</code> 实现三个线程交替打印 ABC 的整体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">TIMES</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// how many times &quot;ABC&quot; should print</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// volatile is needed to ensure visibility</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runnable</span> <span class="variable">printA</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runnable</span> <span class="variable">printB</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                state = <span class="number">2</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runnable</span> <span class="variable">printC</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != <span class="number">2</span>) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printA);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printB);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printC);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS C:\code\java\test&gt;  c:; cd &#x27;c:\code\java\test&#x27;; &amp; &#x27;C:\env\jdk21\bin\java.exe&#x27; &#x27;-XX:+ShowCodeDetailsInExceptionMessages&#x27; &#x27;-cp&#x27; &#x27;C:\code\java\test\target\classes&#x27; &#x27;org.example.PrintABCLock&#x27;</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">PS C:\code\java\test&gt;</span><br></pre></td></tr></table></figure><p>每个线程中大致流程是：</p><ol><li>根据设定的打印次数，循环执行打印任务；</li><li>对于每一轮打印任务，线程首先获取锁；</li><li>自旋等待状态变量 <code>state</code> 符合自己的打印条件，如果不符合则释放锁并等待；</li><li>符合条件后打印字符，修改状态变量 <code>state</code> 并唤醒其他线程；</li><li>释放锁。</li><li>重复 2-5 直到打印次数达到设定值。</li></ol><blockquote><p><strong>Q:</strong> <code>state</code> 一定需要使用 <code>volatile</code> 修饰吗？</p><p><strong>A:</strong> 在此例中不一定，但一般建议使用 <code>volatile</code>。</p><p>我们知道，锁本身就能够保证变量的可见性和原子性，并且此处也没有防止指令重排序的需求。然而，当持有锁的线程忙等待（<a href="https://en.wikipedia.org/wiki/Busy_waiting">busy waiting</a>）时，线程会持续占用锁并不会释放，此时 <code>state</code> 的修改不会被其他线程看到。因此，对于一些重要的线程间共享变量，我们仍然需要使用 <code>volatile</code> 修饰。</p><p>在此例中，自旋操作仅涉及 <code>state</code> 的读取，并且，即使自旋操作没有及时看到 <code>state</code> 的修改，也不会导致错误的结果（获取锁的线程仍会释放锁并继续自旋直到读取到 <code>state</code> 的变化）。但是，作为一个好的代码习惯，我仍然建议使用 <code>volatile</code> 修饰 <code>state</code>。</p></blockquote><h2 id="Atomic-变量（无锁方案）"><a href="#Atomic-变量（无锁方案）" class="headerlink" title="Atomic 变量（无锁方案）"></a>Atomic 变量（无锁方案）</h2><p>实际上，通过上边的方法我们发现，我们使用锁（无论是 <code>ReentrantLock</code> 还是 <code>synchronized</code>）的目的实际上只是为了保证状态变量 <code>state</code> 的可见性和原子性。</p><p>因此，我们可以使用 <code>AtomicInteger</code> 类型的 <code>state</code> 变量，从而以 CAS 实现无锁方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCAtomic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">TIMES</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runnable</span> <span class="variable">printA</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get() % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            state.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runnable</span> <span class="variable">printB</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get() % <span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            state.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runnable</span> <span class="variable">printC</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (state.get() % <span class="number">3</span> != <span class="number">2</span>) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            state.set(<span class="number">0</span>);   <span class="comment">// not use incrementAndGet() here to prevent Integer overflow</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printA);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printB);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printC);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS C:\code\java\test&gt;  c:; cd &#x27;c:\code\java\test&#x27;; &amp; &#x27;C:\env\jdk21\bin\java.exe&#x27; &#x27;-XX:+ShowCodeDetailsInExceptionMessages&#x27; &#x27;-cp&#x27; &#x27;C:\code\java\test\target\classes&#x27; &#x27;org.example.PrintABCAtomic&#x27;</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">PS C:\code\java\test&gt;</span><br></pre></td></tr></table></figure><p>每个线程中大致流程是：</p><ol><li>根据设定的打印次数，循环执行打印任务；</li><li>对于每一轮打印任务，线程自旋等待状态变量 <code>state</code> 符合自己的打印条件；</li><li>符合条件后打印字符，通过 CAS 操作修改状态变量 <code>state</code>；</li><li>重复 2-3 直到打印次数达到设定值。</li></ol><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>对于有状态的并行问题，实际上 <code>CompletableFuture</code> 也是一个不错的选择。我们可以使用 <code>thenApply()</code> 等方法来实现状态转移。</p><p>感兴趣的朋友可以自行实现。</p><h1 id="番外：如果使用公平锁？…"><a href="#番外：如果使用公平锁？…" class="headerlink" title="番外：如果使用公平锁？…"></a>番外：如果使用公平锁？…</h1><p>公平锁是这样的一种锁：对每个锁对象维护一个 <strong>FIFO 线程队列</strong>，当线程尝试获取锁时，如果有其他线程在等待，那么这个线程会被放到队列的末尾，等待其他线程释放锁后再尝试获取锁。</p><p>我们能否利用公平锁来实现三个线程交替打印 ABC 呢？</p><p>省流：<strong>不能</strong>。</p><p>对于公平锁的 FIFO 队列，我们希望出队（即获取锁）的线程有序（A -&gt; B -&gt; C -&gt; A …），那么必须确保线程入队有序。但是，我们知道，由于 JVM 指令重排序的原因，即使是顺序执行 Thread 的 <code>start()</code> 方法，也不能保证线程的执行顺序（因为每个线程的 <code>start()</code> 不存在 happens-before 关系）。因此，我们无法保证线程的入队顺序，进而也不能保证按一定顺序输出线程内数据。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Concurrent </tag>
            
            <tag> Lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决伪共享(False-Sharing)问题：最大化利用你的CPU缓存</title>
      <link href="/2024/01/a5771958.html"/>
      <url>/2024/01/a5771958.html</url>
      
        <content type="html"><![CDATA[<h1 id="解决伪共享-False-Sharing-问题：最大化利用你的-CPU-缓存"><a href="#解决伪共享-False-Sharing-问题：最大化利用你的-CPU-缓存" class="headerlink" title="解决伪共享(False-Sharing)问题：最大化利用你的 CPU 缓存"></a>解决伪共享(False-Sharing)问题：最大化利用你的 CPU 缓存</h1><p>这篇文章是先前我在<a href="https://alrisha.cn/2023/10/42ac2e8f.html">分布式 ID 生成算法 SnowFlake 及其 Go 实现</a>中提到的伪共享（<a href="https://en.wikipedia.org/wiki/False_sharing">False-Sharing</a>） 问题的延伸，主要是为了更好地理解并解决伪共享问题，以便通过最大化使用 CPU 缓存来增强性能。</p><h2 id="什么是伪共享？"><a href="#什么是伪共享？" class="headerlink" title="什么是伪共享？"></a>什么是伪共享？</h2><p>当代 CPU 普遍采用多级缓存的架构，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L1 Cache -&gt; L2 Cache -&gt; L3 Cache -&gt; RAM -&gt; Disk</span><br></pre></td></tr></table></figure><p>其中，缓存读写速度（以及硬件成本）依次递减，而容量则依次递增。当 CPU 访问某个内存地址时，会先从 L1 Cache 开始查找，如果没有找到，再从 L2 Cache 查找，以此类推。如果在 L1 Cache 中找到了，那么就会直接返回，否则就会将 L2 Cache 中的数据拷贝到 L1 Cache 中，再返回。</p><p>想要让程序运行的更快，就需要尽可能地利用低级别的缓存。CPU 缓存是由缓存行组成的，一个缓存行一般是 64 个字节，CPU 读取数据是以缓存行为单位的读取，这意味着即使是读 1 个字节的数据，CPU 也要读取这个数据所在的连续的 64 个字节的数据，如果使用的数据结构中的数据项不是彼此相邻连续的，如链表，那么读数据的时候就得不到这个缓存机制带来的好处；反之，例如 Java 中大部分情况下（JVM 并未强制规定数组连续）的数组存储空间是连续的，它就能够充分利用一个缓存行中的数据，这也是为什么往往数组的数据访问速度要比链表快的原因。</p><p><strong>伪共享问题</strong>：假设我们有 Java 中 long 类型（8 字节）的变量 a 和 b，当 a 和 b 同时存放于一个 L1 缓存行时，线程 1 从缓存行读取了 a，与此同时线程 2 读取了 b。此时由于线程 1 先读取了 L1 缓存，线程 2 的 L1 缓存读取失效（即缓存未命中），线程 2 必须到 L2 缓存甚至更加上级的存储介质中去读取 b，造成了额外的开销。这就是伪共享问题。</p><blockquote><p>关于伪共享更详细的例子和背后原理可以看 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484304&idx=1&sn=54bf0d07e69c5621c145afaece8f50d6&chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd">这篇文章</a>。</p></blockquote><h2 id="伪共享的解决方法"><a href="#伪共享的解决方法" class="headerlink" title="伪共享的解决方法"></a>伪共享的解决方法</h2><p>以下例子给出了一个受伪共享问题影响的程序，来自一篇<a href="https://zhuanlan.zhihu.com/p/187593289?ivk_sa=1024320u&utm_id=0">知乎文章</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FalseSharingDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        testPointer(<span class="keyword">new</span> <span class="title class_">Pointer</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPointer</span><span class="params">(Pointer pointer)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                pointer.a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                pointer.b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">        System.out.println(pointer.a + <span class="string">&quot;@&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(pointer.b + <span class="string">&quot;@&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span> &#123;</span><br><span class="line">    <span class="comment">//  变量需要 volatile 关键字修饰，避免重排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果有一个线程在读取 a 时，会顺带把同一缓存行中的 b 带出</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> a;</span><br><span class="line">    <span class="comment">//  该行用于解决伪共享的问题</span></span><br><span class="line">    <span class="comment">//  long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的机器上运行这段代码，耗时在 3000ms - 4000ms 之间。</p><p>而如果将 Pointer 类中的注释去掉，即通过向缓存行填充空数据来确保两个变量不同时在缓存行上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span> &#123;</span><br><span class="line">    <span class="comment">//  变量需要 volatile 关键字修饰，避免重排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果有一个线程在读取 a 时，会顺带把同一缓存行中的 b 带出</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> a;</span><br><span class="line">    <span class="comment">//  该行用于解决伪共享的问题</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> p0, p1, p2, p3, p4, p5, p6;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>耗时基本在 1000ms - 1100ms 之间，性能提升了三倍之多。</p><h2 id="滑动窗口优化"><a href="#滑动窗口优化" class="headerlink" title="滑动窗口优化"></a>滑动窗口优化</h2><p>通过填充的方法解决伪共享本质上仍然是用空间换时间的解决方案，这在一些高性能需求的热点数据上是非常有意义的，但不可能将变量全部都做防伪共享处理。</p><p>假设上文例子中的变量 a 是我们希望解决伪共享的热点数据，我们实际上并不能保证 a 一直独占缓存行，我们只能保证它不与 b 共享缓存行，因为我们只在 a-b 之间做了缓存行填充。当 a 被存储在缓存行尾的时候，缓存行前面的数据是有可能被另外的线程访问的，这又造成了伪共享问题。</p><p>作为优化，对于一个热点变量 a，我们假设其为 Java long 类型（8 字节），机器缓存大小为 64 字节，我们可以通过下面的方法保证该热点变量 a 总是独占一个缓存行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pointer</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> p0, p1, p2, p3, p4, p5, p6;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> a;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> p8, p9, p10, p11, p12, p13, p14;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个滑动窗口的思想，我们将 a 放在缓存行的中间，前后各填充 7 个 long 类型的数据，这样就保证了 a 一定独占一个缓存行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 7 * 8 = 56   (8 bytes)    7 * 8 = 56</span><br><span class="line">+----------+              +----------+</span><br><span class="line">|          |              |          |</span><br><span class="line">+----------+    count     +----------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-------------------------+</span><br><span class="line">|                         |</span><br><span class="line">+-------------------------+</span><br><span class="line">cache line(sliding window) 64 bytes</span><br><span class="line">-------------------------&gt;</span><br><span class="line">           slide</span><br></pre></td></tr></table></figure><p>该解决方案是我受到 Apache SkyWalking <a href="https://github.com/apache/skywalking/pull/2930">PR#2930</a> 的启发得出的。</p><h2 id="自定义原子类（推荐）"><a href="#自定义原子类（推荐）" class="headerlink" title="自定义原子类（推荐）"></a>自定义原子类（推荐）</h2><p>之前文章提到的<a href="https://github.com/baidu/uid-generator/blob/master/src/main/java/com/baidu/fsg/uid/utils/PaddedAtomicLong.java">百度 UUID 生成器</a>中，给出了一种防止伪共享的自定义原子类的最佳实践：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a padded &#123;<span class="doctag">@link</span> AtomicLong&#125; to prevent the FalseSharing problem&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The CPU cache line commonly be 64 bytes, here is a sample of cache line after padding:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 64 bytes = 8 bytes (object reference) + 6 * 8 bytes (padded long) + 8 bytes (a long value)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yutianbao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaddedAtomicLong</span> <span class="keyword">extends</span> <span class="title class_">AtomicLong</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3415778863941386253L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Padded 6 long (48 bytes) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6 = <span class="number">7L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructors from &#123;<span class="doctag">@link</span> AtomicLong&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaddedAtomicLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaddedAtomicLong</span><span class="params">(<span class="type">long</span> initialValue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * To prevent GC optimizations for cleaning unused padded references</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sumPaddingToPreventOptimization</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1 + p2 + p3 + p4 + p5 + p6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从头说明一下这个类的设计细节：</p><ul><li>通过 JVM 约定的 <code>static final long serialVersionUID</code> 字段，保证该类的序列化兼容性和一致性，确保不会因为 JVM 优化等原因而导致序列化后的类结构被改变。</li><li>仅填充了 6 个 long 类型的数据（占 48 byte），剩余的 16 byte 中，8 byte 用于存储 long 类型的数据，另外 8 byte 用于存储对象的引用&#x2F;元数据等信息，这样就保证了该类的大小为 64 byte，即一个缓存行的大小。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> (48 bytes)   (8 bytes)     (8 bytes)</span><br><span class="line">+----------+--------------+----------+</span><br><span class="line">|          |              |          |</span><br><span class="line">+----------+--------------+----------+</span><br><span class="line">   Padding    AtomicLong    Reference</span><br></pre></td></tr></table></figure><ul><li>通过添加一个没有实际作用的公共成员函数 <code>sumPaddingToPreventOptimization()</code>，来防止 JVM 对该类的优化，保证了 6 个填充变量不会被 GC 回收。</li></ul><h2 id="Contended-注解（推荐）"><a href="#Contended-注解（推荐）" class="headerlink" title="@Contended 注解（推荐）"></a>@Contended 注解（推荐）</h2><p>在 JDK 8 及以上版本中，Java 提供了 <code>@Contended</code> 注解，用于解决伪共享问题。<code>@Contended</code> 注解可以用于类、字段、方法等，用于告诉 JVM 对被注解的字段进行填充，从而避免伪共享问题。</p><p><code>@Contended</code> 注解默认只是在 JDK 内部起作用，如果我们的程序代码中需要使用到 <code>@Contended</code> 注解，那么需要开启 JVM 参数<code>-XX:-RestrictContended</code>才会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Contended &#123;</span><br><span class="line">    <span class="comment">//contention group tag</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>@Contended</code> 标注在类上表示该类对象中的实例数据整体需要独占缓存行。不能与其他实例数据共享缓存行。</p></li><li><p><code>@Contended</code> 标注在类中的字段上表示该字段需要独占缓存行。</p></li><li><p>除此之外 <code>@Contended</code> 还提供了分组的概念，注解中的 value 属性表示 contention group 。属于统一分组下的变量，它们在内存中是连续存放的，可以允许共享缓存行。不同分组之间不允许共享缓存行。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> CPU </tag>
            
            <tag> False-Sharing </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 2023 年</title>
      <link href="/2023/12/dc43eb0d.html"/>
      <url>/2023/12/dc43eb0d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>三个词总结我的 2023，大概就是 <strong>牛马</strong>、<strong>开源</strong>和<strong>孤独</strong></p></blockquote><p>又是一年之末，但今天想要总结一下这个无趣的一年真是让我提不起劲来。不得不说，今年一年的研究生生活只能用冤大头和毫无收获来形容。不过正是为了“自救”，今年我让自己投入开源社区的工作也确实是让我收获颇丰。</p><h2 id="牛马"><a href="#牛马" class="headerlink" title="牛马"></a>牛马</h2><p>其实我是不愿意在网络散发太多我的负面情绪的，但是这一年忍受下来的种种还是让我忍不住竖起我的中指。各位大可跳过这段牢骚以免影响大家新年的情绪。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/12/31/MB2R3XKdDc5jTyn.jpg" alt="黄豆.jpg"></p><p>研一之后，大家理所应当地加入了各种项目组，但我运气却非常爆棚，是唯一一个被导师分配到实验室另一个老师（以下简称 Z 老师）手底下做事的，刚开始的我确实是摩拳擦掌，准备大干一番。但在进了项目组后：</p><ul><li>每周开一次会，而 Z 老师是个 PPT 大师，本身对技术也是一知半解，技术栈和架构设计基本不听我的建议，却喜欢在每周的会上画大饼填需求（没错，乙方给甲方添需求），还是每周都画饼。这饼给甲方每周看的心满意足，给我每周看的流汗黄豆。</li><li>价值 7 位数的项目，合同上写的是 10 人的小组，实际开发、设计、文档、维护全部只有我一个人，没有任何一个人帮忙；作为代价，我能够每个月多发到高达 200 块人民币的天价补贴。</li><li>每天早上 8-9 点享有电话闹钟服务，并且<strong>周末不间断</strong>，即使是开线上会议或是微信发一条消息的问题（例如，把服务器上的一个 txt 文件发给他）也需要打电话直接通知，生怕我把微信卸载了。</li><li>每天晚上 8 点经常会打电话提新需求（我猜是他吃完晚饭了终于有时间看今天做了啥），包括周六周日。</li><li>双休没有，法定假日更别想要。我记得很清楚，五一假期我还在动车上开会写代码。</li><li>几万行的代码我一个人来写，100 多页的文档我一个人来做，项目需求的专利更是要我亲自写好，但发出去后我才发现，<strong>这个专利上完全没有我本人的名字</strong>。</li><li>实验室其它学生，包括我导师的学生和 Z 老师自己的学生都能找到适合的方向开题，我却因为所有时间都花在这个狗屁项目上，只能拿这个基本没有创新点只有工程问题的课题来硬开题；我好不容易套了算法模型进去让他们审报告，我导师和 Z 老师却互相推诿。截至今天，我报告已经写完三周，没有一个老师看过一眼。</li><li>…</li></ul><p>这一年，我没有在实验室学会任何新的技术，没有提升任何科研能力；室友发论文的发论文，发专利的发专利，我什么都没有，幸幸苦苦写的专利甚至还不是自己的，连最后一作都不愿意给我加上。现在即使项目结项了，我在元旦假期后还要再去甲方做“售后工作”；同时，实验室各位的开题都快答辩了，我的报告甚至都还没有人看。</p><p>这就是我的 2023。</p><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>总而言之，2023 大体来说对我来说是比较压抑的，我做的这个项目可以说彻底断了我的科研梦。为了我自己的出路，我必须在实验室的实习禁令下另外找到一条提升自己的方法。这就是我参与开源社区的最初原因之一。</p><p>可以说，我对技术的热情被开源社区重新点燃了。从 GSOC 2023 到 OSPP 2023，我都参与了一些开源项目的开发，也认识了很多技术大牛。开源精神和最前沿的技术不仅仅是拓宽了我的视野，参与其中更是让我的能力得到了肉眼可见的提升。再和实验室的无趣项目和无情压榨的老师一对比，属实是高下立判。</p><p>关于我的 GSOC 项目，可以<a href="https://alrisha.cn/2023/09/8053138b.html">看这里</a>。Apache SkyWalking 的社区环境非常好，社区中的各位也非常愿意提供帮助和建议。在这里我能对相关行业最先进的技术有更进一步的了解，例如 GraaLVM、无边车 istio、异步编程等等。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/09/05/S29re3GxmcIVLDO.png" alt="gsoc-completion-certificate.png"></p><p>关于我的 OSPP 项目，因为我仍然还在 Nacos 社区中处理剩余的部分问题，所以还没有给出这次活动的总结。官网公告可以看<a href="https://summer-ospp.ac.cn/org/prodetail/23ab10353?lang=zh&list=pro">此处</a>。Nacos 社区和 Apache SkyWalking 社区风格不同，由于阿里的背书和其商业化程度较深，社区的需求也更加严谨周密，我在也这里学到了很多项目管理和开发的经验。</p><p>到了年末，开源社区对我来说已经不是“实验室以外的救命稻草”，我更愿意把它作为我日常学习工作的一部分。我能切实看到我和社区共同成长，这样的正反馈是很难以替代的。</p><h2 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h2><p>其实这一部分的小标题我本来是想写 <em>游戏</em> 的，因为游戏确实是陪伴了我除了学习以外的大多数时间。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/12/31/tBnrMPoAiGfQH7s.png" alt="steam2023.png"></p><p>但是正因为这样，不就说明了我的 <em>孤独</em> 吗？</p><p>正如前面所说，我所在的项目组全实验室任务最重，但却只有我一个人；而其它同学都结伴分配在各自项目组中，彼此都建立起了一定的社交关系。我甚至连空闲时间都没有，谈何社交？室友的共同话题也越来越少，唯一算得上娱乐的也就是自己去听听喜欢的音乐会罢了。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/12/31/bEK7tPxyJdfMIos.jpg" alt="d9.jpg"></p><p>到最后，最可靠的还是游戏。不止是 RPG 或是射击游戏，今年我也尝试了很多 Galagame ，从 9nine 到樱之诗，从放松有趣的文本到引人深省的哲思，我认为 Galagame 才是文学的终极载体 —— 黄油部分只是其中的小小一部分。明年希望能静下心来把白色相簿 2 给读完。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/12/31/r48VGzMcjEQnibW.jpg" alt="2560px-Sakura_No_Uta.jpg"></p><p>相信各位看完上面写的这段，应该知道我有多 <em>孤独</em> 了吧？</p><h2 id="2024-？"><a href="#2024-？" class="headerlink" title="2024 ？"></a>2024 ？</h2><p>然后，转眼就到了 2023 年的最后一天。</p><p>无论 2023 年如何，再过几个小时它也要掉入历史的尘埃中了。2024 会怎么样呢？我觉得在新的一年，我得在性格上更“自私”一点：学位是我的，技术是我的，找到的工作是我的，工资和补贴是我的，其它的全部滚球。不要成为精神上的懦夫，这就是我对我自己在新的一年的期许。</p><blockquote><p><strong>最后，祝看到这篇文章的朋友们 2024 新年快乐！</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 yum 无响应解决办法</title>
      <link href="/2023/12/5a183433.html"/>
      <url>/2023/12/5a183433.html</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS-7-yum-无响应解决办法"><a href="#CentOS-7-yum-无响应解决办法" class="headerlink" title="CentOS 7 yum 无响应解决办法"></a>CentOS 7 yum 无响应解决办法</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在实验室的 CentOS 7 服务器上配置 Python 环境的时候，出现了 <code>yum</code> 指令无响应的问题，即在输入任何 yum 及其相关的指令后，光标会停顿在空白处闪烁，终端无任何输出，CTRL + C 也无法退出指令。只有关闭整个终端再新建才能进行别的操作。</p><p>同时，指令 <code>rpm -qa</code> 指令同样出现了无响应的问题，但 rpm 的其它指令可正常执行。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>很大可能是先前的 yum 指令执行被人为或异常中断，导致 rpm 包数据库出错被锁定。（又是哪个笨蛋学弟？🤯）</p><p>参考解决方案：</p><ul><li><a href="https://stackoverflow.com/questions/57818761/terminal-hangs-when-executing-yum-commands">https://stackoverflow.com/questions/57818761/terminal-hangs-when-executing-yum-commands</a></li><li><a href="https://www.jianshu.com/p/cfd6dae240c8">https://www.jianshu.com/p/cfd6dae240c8</a></li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先应该干掉 yum&#x2F;rpm 的进程，通过 <code>ps -aux</code> 和 <code>kill -9</code> 组合拳可以做到。不过因为我直接关闭的终端因此似乎不存在仍然运行的 yum 进程。</p><p>其次，应该将 rpm 数据库锁删除，即分别执行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /var/lib/rpm/.rpm.lock</span><br><span class="line"><span class="built_in">rm</span> /var/lib/rpm/.dbenv.lock</span><br></pre></td></tr></table></figure><p>我们服务器 yum 的问题在这就解决了，随后就是 <code>yum clean all</code> 等一系列常规操作了。</p><p>但如果仍然没有解决问题，可以尝试重建 rpm 数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /var/lib/rpm/__db.*</span><br><span class="line">rpm -vv -rebuilddb</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式 ID 生成算法 SnowFlake 及其 Go 实现</title>
      <link href="/2023/10/42ac2e8f.html"/>
      <url>/2023/10/42ac2e8f.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式-ID-生成算法-SnowFlake-及其-Go-实现"><a href="#分布式-ID-生成算法-SnowFlake-及其-Go-实现" class="headerlink" title="分布式 ID 生成算法 SnowFlake 及其 Go 实现"></a>分布式 ID 生成算法 SnowFlake 及其 Go 实现</h1><p>在先前总结我 <a href="https://alrisha.cn/2023/09/8053138b.html">GSOC 2023 项目的文章</a>中，我提到了 Python agent 的 ID 生成是主要的性能瓶颈。我的 Mentor 为了解决这个问题，专门提了一个 <a href="https://github.com/apache/skywalking/issues/10849">issue</a> ，其主要内容就是将 Skywalking Python agent 的 ID 生成规则和 Java agent 一致。他在写这个 PR 的时候也有和我讨论参考我的意见，我也就这个机会进一步了解了著名的分布式 ID 生成算法 SnowFlake。</p><p>在我 Mentor 的这个 PR 中，他实际上是以雪花算法(SnowFlake 算法)的思想来生成唯一 ID ，具体实现和应用场景还是和原版雪花算法有很多不同。而我这篇博客的主要目的，还是在于记录雪花算法的主要原理，并以<a href="https://github.com/baidu/uid-generator">百度开源的一个 ID 生成器</a>为例子来进一步说明。最后，我也给出我自己写的代码——通过 Go 实现百度 ID 生成器的部分内容。</p><h2 id="SnowFlake-雪花算法"><a href="#SnowFlake-雪花算法" class="headerlink" title="SnowFlake - 雪花算法"></a>SnowFlake - 雪花算法</h2><p>SnowFlake 原先是 Twitter(现 X) 开源的分布式 ID 生成算法，<a href="https://github.com/twitter-archive/snowflake/tree/snowflake-2010">源代码</a>已经不再维护，为仅可读状态。该算法将一个 64 位的 UUID(Universally Unique Identifier) 拆分成如下部分：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/10/15/sT43Dl8BtFnZAQ7.png" alt="Snowflake-identifier.png"></p><ul><li><strong>首位</strong> ： 固定为 0 作为占位，因为往往用 long 存储雪花 ID，而大部分计算机第一位 0 表示整数，1 表示复数</li><li><strong>时间戳</strong> ： 41 bits，毫秒精度。（依照 UNIX 时间，时间戳从协调世界时 1970 年 1 月 1 日 0 时 0 分 0 秒开始，因此可自定义的时间共 69 年。）</li><li><strong>物理机器标识码</strong> ： 10 bits，可最多支持 1024 台机器</li><li><strong>序列号</strong> ： 12 bits，每台机器每 4096 位滚动一次（有保护功能，避免在同一毫秒内滚动从而产生重复 ID 的情况——因为 UNIX 时间是以毫秒为单位的）</li></ul><p>实际上在生产过程中，每个部分所占位比重可以灵活变通。时间戳方面，可以以工程项目起始时间为基准，记录相对时间戳，例如我的项目 A 是 2020.1.1 启动的，那么项目 A 的雪花 ID 的时间戳部分都可以设置为与之对应的相对 UNIX 时间，这样以来也可以缩小时间戳部分的比特位数，为其它部分腾出空间；物理机器标识码当然也可以根据实际的物理机器&#x2F;虚拟化容器数量来配置；序列号则应当在保证其它部分可用的情况下尽量长，减少毫秒内滚动。</p><p>SnowFlake 算法 ID 具有如下特征：</p><ol><li><strong>全局唯一性</strong>：雪花算法可以保证集群系统的 ID 全局唯一</li><li><strong>趋势递增</strong>：由于强依赖时间戳，所以整体趋势会随着时间递增</li><li><strong>不满足单调递增</strong>：在不考虑时间回拨的情况下，虽然在单机中可以保持单调递增，但在分布式集群中无法做到单调递增，只能保证总体趋势递增</li><li><strong>信息安全</strong>：指的是 ID 生成不规则，无法猜测下一个生成的 ID</li></ol><p>SnowFlake 算法以其简单、高性能、无需额外依赖而闻名，但它还是存在几个问题：</p><p><em><strong>服务器时间回拨</strong></em> ： 由于雪花算法严重依赖系统时间，所以当发生服务器时钟回拨的问题时可能产生重复的 ID。</p><p><em><strong>机器 ID 分配</strong></em> ：机器 ID 需要单独分配，业内目前普遍采用 <code>zookeeper</code> 或数据库方式，但是没有合理的分配和回收方案，存在浪费问题。</p><h2 id="时间回拨问题的解决方案"><a href="#时间回拨问题的解决方案" class="headerlink" title="时间回拨问题的解决方案"></a>时间回拨问题的解决方案</h2><p>由于雪花算法重度依赖机器的当前时间，所以一旦发生时间回拨，将有可能导致生成的 ID 可能与此前已经生成的某个 ID 重复（前提是生成 ID 时序列号也刚好一致）。</p><p>常见的解决方案如下：</p><ol><li><p><strong>抛出异常或延迟等待（缓解）</strong><br>当算法检测到时钟回拨后，直接抛出异常；或者阻塞等待一段时间，再判断时钟是否追上来。这种方式简单粗暴，但是会影响服务可用性，只适用于并发量不高的系统。</p></li><li><p><strong>备用机高可用方案（避免）</strong><br>通过备用机方案，当发现时钟回拨后，切换到备用机上继续生成 ID。这种方式可以保证服务可用性，但是需要额外的机器成本。</p></li><li><p><strong>时间戳脱离系统时间自增（避免）</strong><br>如果时间戳字段不再依赖于系统时间，那么即使发生时钟回拨，也不会影响 ID 冲突。这种方案需要程序自动在每一毫秒内自增时间戳，每一毫秒内的序列号 seq 不会浪费，或者说是将所有时间戳字段都转化为了 seq 字段。局限性是很明显的，这个方案只有当系统对 ID 的时间戳功能没有需求，仅需要提供自增 ID 的情况下，才可以考虑。</p></li><li><p><strong>缓存序列号缓解时钟回拨问题（缓解）</strong><br>这个方案并不能彻底解决时钟回拨，而是一个缓解方法。由于一个毫秒内序列号往往不能全部用完，因此我们可以将一定时间内（例如 2 秒）的序列号进行缓存。一旦发生了时钟回拨，那么就可以从缓存中获取未使用的序列号。这种方案可以保证服务短时可用性，但若时钟回拨时间超过缓存时间，仍然需要抛出异常，并且会破坏 ID 自增性。</p></li><li><p><strong>增加时钟回拨缓冲位（缓解）</strong><br>参考: <a href="https://www.cnblogs.com/shoshana-kong/p/17319231.html">https://www.cnblogs.com/shoshana-kong/p/17319231.html</a><br><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://img-blog.csdnimg.cn/img_convert/75792ef5993f645706a24364a604278a.png"><br>在该博客的实现方式中，采用从机器序列中取出的 3 个比特位作为时间序列缓冲位，当发生一次时间回拨事件则缓冲位加一，支持 8 次回拨事件的容错，当缓冲位达到 8 时，抛出异常。然而，这种方式仍然无法保证 ID 的单调递增性，因为当发生回拨事件时，时间戳位是跳跃而不是单调递增的。</p><p>事实上，应当将三个缓冲位设在时间戳位之后（即第 63 - 61 位），这样才能保证 ID 的单调递增性不受时间戳跳跃的影响。类似的，也可以根据系统需求，调整时间戳位数、机器位数和序列号位数，随后增大缓冲位数。</p><p>这种方案会导致常态下有三个比特位的浪费，但是可以保证<strong>短时</strong>服务可用性，且不会破坏 ID 的单调递增性。</p></li></ol><h2 id="百度-UUID-生成器"><a href="#百度-UUID-生成器" class="headerlink" title="百度 UUID 生成器"></a>百度 UUID 生成器</h2><p>以下以百度 UUID 生成器为例讲讲雪花算法的生产实践。</p><p>仓库地址：<a href="https://github.com/baidu/uid-generator">https://github.com/baidu/uid-generator</a><br>中文文档：<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</a></p><p>具体图例、设计细节、性能测试请进入<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">中文文档</a>中进一步阅读，下文只给出基本的介绍与其对原始 SnowFlake 算法的改进。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/10/16/RwAzv2yaT3dnx1D.png" alt="snowflake.png"></p><ul><li><p><strong>sign</strong> (1bit)<br>固定 1bit 符号标识（值为 0），即生成的 UID 为正数。</p></li><li><p><strong>delta seconds</strong> (28 bits)<br>当前时间，相对于时间基点”2016-05-20”的增量值，单位：秒，最多可支持约 8.7 年</p></li><li><p><strong>worker id</strong> (22 bits)<br>机器 id，最多可支持约 420w 次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。</p></li><li><p><strong>sequence</strong> (13 bits)<br>每秒下的并发序列，13 bits 可支持每秒 8192 个并发。</p></li></ul><h3 id="CachedUidGenerator-与-RingBuffer"><a href="#CachedUidGenerator-与-RingBuffer" class="headerlink" title="CachedUidGenerator 与 RingBuffer"></a><code>CachedUidGenerator</code> 与 <code>RingBuffer</code></h3><p>在基本的 SnowFlake ID 生成算法之上，百度进一步封装了一个 <code>CachedUidGenerator</code> 。在这个生成器中，采用了一种被称为 <code>RingBuffer</code> 的环形数组数据结构作为缓存，数组每个元素成为一个 slot。RingBuffer 容量默认为 Snowflake 算法中 sequence 最大值，且必须为 2^N。</p><p><code>Tail 指针</code>、<code>Cursor 指针</code>用于环形数组上读写 slot：</p><ul><li><p><strong>Tail 指针</strong><br>表示 Producer 生产的最大序号(此序号从 0 开始，持续递增)。Tail 不能超过 Cursor，即生产者不能覆盖未消费的 slot。当 Tail 已赶上 curosr，此时可通过 rejectedPutBufferHandler 指定 PutRejectPolicy</p></li><li><p><strong>Cursor 指针</strong><br>表示 Consumer 消费到的最小序号(序号序列与 Producer 序列相同)。Cursor 不能超过 Tail，即不能消费未生产的 slot。当 Cursor 已赶上 tail，此时可通过 rejectedTakeBufferHandler 指定 TakeRejectPolicy</p></li></ul><p>CachedUidGenerator 采用了双 RingBuffer，<code>Uid-RingBuffer</code> 用于存储 Uid、<code>Flag-RingBuffer</code> 用于存储 Uid 状态(是否可填充、是否可消费)</p><p>RingBuffer 有下述三种填充时机：</p><ul><li><p><strong>初始化预填充</strong><br>RingBuffer 初始化时，预先填充满整个 RingBuffer 。</p></li><li><p><strong>即时填充</strong><br>消费时，即时检查剩余可用 slot 量(tail - cursor)，如小于设定阈值，则补全空闲 slots。这个阈值是可配置的。</p></li><li><p><strong>周期填充</strong><br>通过 Schedule 线程，定时补全空闲 slots。可通过 scheduleInterval 配置，以应用定时填充功能，并指定 Schedule 时间间隔。</p></li></ul><p>由于数组元素在内存中是连续分配的，可最大程度利用 CPU cache 以提升性能，但同时会带来 <em><strong>伪共享(FalseSharing)</strong></em> 问题，在这里百度通过了数据补齐的方式把它解决了。这是一个比较深层次且有趣的 CPU 性能优化问题，我还在不止一次地方遇到它，后续我会专门为其写一篇博客，这里不再赘述。</p><h3 id="百度关于-UID-比特分配的建议"><a href="#百度关于-UID-比特分配的建议" class="headerlink" title="百度关于 UID 比特分配的建议"></a>百度关于 UID 比特分配的建议</h3><p>对于并发数要求不高、期望长期使用的应用，可增加 timeBits 位数，减少 seqBits 位数。例如节点采取用完即弃的 WorkerIdAssigner 策略，重启频率为 12 次&#x2F;天，那么配置成 <code>&#123;&quot;workerBits&quot;:23, &quot;timeBits&quot;:31, &quot;seqBits&quot;:9&#125;</code> 时，可支持 28 个节点以整体并发量 14400 UID&#x2F;s 的速度持续运行 68 年。</p><p>对于节点重启频率频繁、期望长期使用的应用，可增加 workerBits 和 timeBits 位数，减少 seqBits 位数。例如节点采取用完即弃的 WorkerIdAssigner 策略，重启频率为 24*12 次&#x2F;天，那么配置成 <code>&#123;&quot;workerBits&quot;:27, &quot;timeBits&quot;:30, &quot;seqBits&quot;:6&#125;</code> 时，可支持 37 个节点以整体并发量 2400 UID&#x2F;s 的速度持续运行 34 年。</p><h2 id="Go-实现百度-UID-生成器"><a href="#Go-实现百度-UID-生成器" class="headerlink" title="Go 实现百度 UID 生成器"></a>Go 实现百度 UID 生成器</h2><p>仓库地址：<a href="https://github.com/FAWC438/uid-generator-go">https://github.com/FAWC438/uid-generator-go</a></p><p>我根据百度的 <a href="https://github.com/baidu/uid-generator">uid-generator</a> 利用 Go 重构了具体实现，实际上只是想顺便练习一下 Go 的语法和编写思想。但可惜在并发编程这边，Go 和 Java 的差异很大，而我对 Go 语言还完完全全只是一知半解的入门者，我最后也没能完全复现 Go 版本下的百度 uid-generator 的结果。不过我仍然还是大体上实现了基本的 Go 版本的雪花算法，以及 <code>RingBuffer</code> 数据结构及其伪共享优化，感兴趣的朋友可以进入仓库地址查看，更欢迎大家提出 Issue 和 PR 对代码提出意见或对其进行改进。</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul><li>美团 Ledf: <a href="https://github.com/Meituan-Dianping/Leaf-">https://github.com/Meituan-Dianping/Leaf-</a></li><li>滴滴 Tinyid: <a href="https://github.com/didi/tinyid">https://github.com/didi/tinyid</a></li><li>Butterfly: <a href="https://github.com/SimonAlong/Butterfly">https://github.com/SimonAlong/Butterfly</a> 及其文档：<a href="https://www.yuque.com/simonalong/butterfly/tul824">https://www.yuque.com/simonalong/butterfly/tul824</a></li><li><a href="https://blog.51cto.com/stefanxfy/5083406">https://blog.51cto.com/stefanxfy/5083406</a></li><li><a href="https://www.cnblogs.com/shoshana-kong/p/17319231.html">https://www.cnblogs.com/shoshana-kong/p/17319231.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> SnowFlake </tag>
            
            <tag> Distributed ID </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何单独编译 Nacos 客户端源码并将其注入 Spring Cloud 中</title>
      <link href="/2023/10/44259116.html"/>
      <url>/2023/10/44259116.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何单独编译-Nacos-客户端源码并将其注入-Spring-Cloud-中"><a href="#如何单独编译-Nacos-客户端源码并将其注入-Spring-Cloud-中" class="headerlink" title="如何单独编译 Nacos 客户端源码并将其注入 Spring Cloud 中"></a>如何单独编译 Nacos 客户端源码并将其注入 Spring Cloud 中</h1><p>如果你由于 Spring Cloud 应用业务内的问题，需要自定义 Nacos 的客户端部分代码；或者你是开源贡献者，为 Nacos 客户端部分贡献了部分代码，接下来希望能验证修改后的 Nacos 客户端在 Spring Cloud 中的可用性，那么你一定希望知道如何单独编译 Nacos 客户端部分的源码并将其注入至现有的 Spring Cloud 应用&#x2F;demo 中。</p><p>不幸的是，Nacos 官方文档仅提供了服务端的编译安装方法。接下来，这篇博客就将介绍如何将新编译的 Nacos 客户端注入对应的 Spring Cloud Alibaba starter 中，将 starter 中固定版本的 Nacos 客户端替换为你本地编译的 Nacos 客户端。</p><h2 id="单独编译-Nacos-客户端源码"><a href="#单独编译-Nacos-客户端源码" class="headerlink" title="单独编译 Nacos 客户端源码"></a>单独编译 Nacos 客户端源码</h2><p>首先，克隆 Nacos 主仓库，并进入该文件夹，推荐使用 idea 操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/alibaba/nacos.git</span><br><span class="line"><span class="built_in">cd</span> nacos</span><br></pre></td></tr></table></figure><p>找到源代码中的 Nacos 版本并记录下来，这个版本一定是 <code>未发布版本号-SNAPSHOT</code> ，例如目前 Nacos 发布版本是 <code>2.2.3</code>，代码仓库中的 Nacos 版本则是 <code>2.3.0-SNAPSHOT</code> 。具体值需要参考根目录下的 <code>pom.xml</code> 中的 <code>revision</code> 字段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 就是这个👇 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">revision</span>&gt;</span>2.3.0-SNAPSHOT<span class="tag">&lt;/<span class="name">revision</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接下来，需要使用 Maven <strong>同时本地编译 <code>nacos-client</code>、<code>nacos-common</code> 和 <code>nacos-api</code></strong> 。切记<strong>不要</strong>只编译 <code>nacos-client</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipITs -Dmaven.test.skip=<span class="literal">true</span> -pl com.alibaba.nacos:nacos-client -pl com.alibaba.nacos:nacos-common -pl com.alibaba.nacos:nacos-api</span><br></pre></td></tr></table></figure><p>随后，版本 <code>2.3.0-SNAPSHOT</code> 的 Nacos 客户端就会被编译到本地的 Maven 仓库中。再次提醒，不要只编译 <code>nacos-client</code> ，Nacos 客户端必须依赖对应版本的 <code>nacos-common</code> 和 <code>nacos-api</code> 包。</p><h2 id="将本地编译完成的-Nacos-客户端注入-Spring-Cloud-Starter-中"><a href="#将本地编译完成的-Nacos-客户端注入-Spring-Cloud-Starter-中" class="headerlink" title="将本地编译完成的 Nacos 客户端注入 Spring Cloud Starter 中"></a>将本地编译完成的 Nacos 客户端注入 Spring Cloud Starter 中</h2><p>通过 Maven 的 <code>dependencyManagement</code> 机制，我们可以将 Spring Cloud Alibaba Starter 中的 Nacos 客户端版本固定为我们本地编译的版本。</p><p>首先，我们需要导入 Nacos 的 Spring Cloud Starter 依赖，配置中心功能与服务注册&#x2F;发现功能分别对应以下两个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以下三个版本有一一对应关系，不能随意组合--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2021.0.5<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.cloud.alibaba.version</span>&gt;</span>2021.0.5.0<span class="tag">&lt;/<span class="name">spring.cloud.alibaba.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--nacos 本地编译版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nacos.version</span>&gt;</span>2.3.0-SNAPSHOT<span class="tag">&lt;/<span class="name">nacos.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意，<code>$&#123;spring.cloud.alibaba.version&#125;</code> 必须正确配置，详情可参考 Spring Cloud Alibaba <a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">版本说明文档</a>。</p><p>随后，配置 <code>dependencyManagement</code> 即可将本地的 Nacos 客户端注入至这两个 Starter 中，替换其默认版本的 Nacos 客户端代码。此处必须将本地编译的 <code>nacos-client</code>、<code>nacos-common</code> 和 <code>nacos-api</code> 三个包都注入，否则会出现类初始化错误。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此，我们成功将本地编译的 Nacos 客户端注入至 Spring Cloud 应用中。接下来，我们可以在这个应用中使用或测试新编译的 Nacos 客户端了。</p><h2 id="附录：一个完整的-pom-xml-示例"><a href="#附录：一个完整的-pom-xml-示例" class="headerlink" title="附录：一个完整的 pom.xml 示例"></a>附录：一个完整的 <code>pom.xml</code> 示例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.edu.bupt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-practice<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-practice<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>spring-practice<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下三个版本有一一对应关系，不能随意组合--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2021.0.5<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.cloud.alibaba.version</span>&gt;</span>2021.0.5.0<span class="tag">&lt;/<span class="name">spring.cloud.alibaba.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos 本地编译版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nacos.version</span>&gt;</span>2.3.0-SNAPSHOT<span class="tag">&lt;/<span class="name">nacos.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.cloud.alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.project-lombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSOC 2023 - 我的第一次开源之旅</title>
      <link href="/2023/09/8053138b.html"/>
      <url>/2023/09/8053138b.html</url>
      
        <content type="html"><![CDATA[<h1 id="GSOC-2023-我的第一次开源之旅"><a href="#GSOC-2023-我的第一次开源之旅" class="headerlink" title="GSOC 2023 - 我的第一次开源之旅"></a>GSOC 2023 - 我的第一次开源之旅</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天北京时间凌晨 2 点左右，Google 给我发邮件确认了项目终审通过，3 个多月以来的 GSOC(<a href="https://summerofcode.withgoogle.com/">Google Summer of Code</a>) 活动算是圆满结束了。今年 5 月份以来我在 GSOC 、 OSPP(<a href="https://summer-ospp.ac.cn/">Open Source Promotion Plan</a> 中科院办的开源之夏) 和实验室的完蛋项目里三线作战来回捣腾焦头烂额 😶，这也是我博客一直没有更新的原因。三大战役之一终于收官了，这才忍不住来更新一下博客，只是想告诉大家我没有太监(:</p><p>这页博客主要内容其实是我想说说这次 GSOC —— 也是我第一次参加开源项目 —— 的感受，想看我的 GSOC 项目的具体内容可以参考<a href="https://summerofcode.withgoogle.com/programs/2023/projects/M7qsJ2mB">这个链接</a>，想要参考我项目提案(Proposal)的可以<a href="https://alrisha.cn/2023/09/3959450b.html">看这里</a>，想直接看我做了啥东西出来的可以直接看<a href="https://github.com/apache/skywalking-python/blob/master/docs/en/setup/advanced/AsyncEnhancement.md">这个文档</a>，不想看我下面逼逼赖赖的可以输入组合技 <code>CTRL + W</code>。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/09/05/S29re3GxmcIVLDO.png" alt="gsoc-completion-certificate.png"></p><h2 id="在这之前"><a href="#在这之前" class="headerlink" title="在这之前"></a>在这之前</h2><p>最开始了解开源，其实是在 2022 年末，看到实验室看到学长参加 OSPP 拿了个优秀学员（他的博客 👉 <a href="https://siegelion.cn/">https://siegelion.cn/</a> ，技术力真的很强），然后想着 wow, cooooooollllll! 给数万用户用的开源项目里留下自己的代码真的太拉风了。要是出去工作，突然有一天同事问你：诶，这个库的这个代码 author 怎么是你？我：🕶</p><p>那么时间最近的开源活动其实就是 GSOC(<a href="https://summerofcode.withgoogle.com/">Google Summer of Code</a>) 了，实际上 GSOC 是最早的学生开源活动，是国内 OSPP, GLCC 的祖师爷，而且谷歌的背书也是全球通用的。不过相应的，GSOC 的申请难度不低，并且最大的问题就在于沟通 —— 你很大概率会碰上完全不会中文，甚至是非英语母语的 Mentor(项目导师)。而沟通恰恰是完成一个开源项目的关键，没有沟通别说技术指导、项目规划、社区要求了，甚至连 ddl 都没法准确的通知你。所以其实网络上很多人建议国内的开源新手先通过 OSPP、GLCC 这些活动上手，除非你的英语能力高强、或是能够找到国人 Mentor 指导的项目。</p><p>我在一开始申请的时候就是由于上述的原因，其实是抱着试试的心态申请的，做好了颗粒无收的准备。既然死猪不怕开水烫，那我想我直接去找那些最有名的 Org 的项目报吧。我大概浏览了一遍，GSOC 的组织机构中，国人社区比较多的都集中在 Apache 和 CNCF 这俩里头。但是国人社区国人导师的项目，不用想竞争肯定非常激烈，并且绝大多数项目单单那高大上的名字和眼花缭乱的技术栈就让我望而却步。根据我自己的技术栈积累和一次超短期实习经历（这篇<a href="https://alrisha.cn/2023/01/a0c66ae9.html">博客</a>的来由），我找到了 <code>Apache SkyWalking</code> 社区的 <strong>Python Agent Performance Enhancement Plan</strong> 这个项目。<code>Apache SkyWalking</code> 是<a href="https://github.com/wu-sheng">吴晟</a>老师创建的开源社区，而这个项目不仅适合我的技术能力，它的 Mentor 还是美国东部时区的，这样我的竞争对手就会少了一些（无论是来自国内还是国外的）。我费劲心思，集百度谷歌 deepl 各家翻译之所长，洋洋洒洒地写了一封全英文邮件给这位 Mentor，结果第二天一看回信我就傻眼了：</p><blockquote><p>都是中国人，咱们讲中国话。</p></blockquote><h2 id="我都做了些什么"><a href="#我都做了些什么" class="headerlink" title="我都做了些什么"></a>我都做了些什么</h2><p>实际上，我的邮件是 2 月份发出去的，就是在 GSOC 组委会正在确定项目组织机构的时候。这个时间段其实比正常的申请时间要早一点，我觉得这也是我能侥幸中选的原因之一，因为我早早把坑给占好了。实际上后来还有个印度哥们也想来报这个项目，但是那个时候我已经开始在社区里做项目准备工作了。</p><p>Proposal 我也构思了不少时间，参考了 github 上一些往届学生的例子，当然最后会交给 Mentor 润色，不过 95%都是要靠自己完成的，<a href="https://alrisha.cn/2023/09/3959450b.html">看这里</a>。Proposal 主要还是要表达出对项目的理解、希望采用的技术方案并最好有实践例子、项目的时间安排等，篇幅完全不是最重要的。之所以专门提了一下 Proposal 的重要性，是因为后来我的 Mentor 告诉我 SkyWalking 社区 10 个项目最后只有 6 个被选上，其它的都被 Google 毙掉了，即使贡献者已经和 Mentor 商量好了（这种情况在 OSPP 基本不会发生）。</p><p>其实我第一个给开源社区贡献的代码，并不是这个项目的代码。而是在社区混脸熟的时候找到了一个 bug ，顺手给修复了(<a href="https://github.com/apache/skywalking-python/pull/300">PR 见此</a>)。这个 PR 实际上给了我很多好处，第一个就是让我的 Mentor 觉得“孺子可教也”，然后也能让社区里的其它人，比如吴晟老师，对我的名字也有了印象，毕竟后面他们 review 我的项目代码的时候还指望他们手下留情 😂。不过这个 PR 最重要的，还是帮助我成功申请到了我 OSPP 的项目，这个是后话了，希望一两个月后还能贴个博客谈谈。</p><p>关于时间安排方面，上面的完成证明说的是 5 月末开始，实际上我 4 月份就正式开始做项目内容了，大约 6 月中旬的时候我已经基本完成了所有的功能点，我和 Mentor 之间的合作主要就集中在这个时间段。不得不说，我没有这么尽心尽责的 Mentor ，我的项目不会完成的这么顺利。技术层面上，我做的工作可以通过我的这个<a href="https://github.com/apache/skywalking-python/blob/master/docs/en/setup/advanced/AsyncEnhancement.md">技术文档</a>来做总结，这里来罗列一下我遇到的主要的难点和解决方案吧：</p><p>首先是<strong>AsyncIO 协程的跨线程调用</strong>。Python asyncio 实际上是基于 <code>eventloop</code> 这一模型实现的单线程异步库。也就是说运行 eventloop 的线程必然不可能是 SkyWalking Python agent 的主线程，否则用户甚至都无法访问 agent 的 API。然而，用户的监控数据仍然需要通过 API 传递到 agent 核心队列中再依次上报给 SkyWalking 后端。在原先的 Python 线程模型中，由于 Python 的队列是线程安全的，因此只需要调用队列的 <code>get()/put()</code> 即可。而现在，则需要数据流向从 <code>主线程-&gt;队列-&gt;处理线程-&gt;上报线程</code> 变更到 <code>主线程-&gt;队列-&gt; eventloop 线程-&gt;处理协程-&gt;上报协程</code>。</p><p>为此，我将全局通用的队列更改为 eventloop 线程专用的 <code>asyncio.Queue</code>，而在主线程和 eventloop 线程之间的队列生产&#x2F;消费，则直接采用<code>run_coroutine_threadsafe()</code> 方法将协程任务投递到 eventloop 线程中。这样就能够保证数据的安全性，同时也不会阻塞主线程。这里我和 Mentor 其实讨论了很久，因为这个方案的实现并不是很优雅，跨线程调用协程似乎有悖于<strong>Performance Enhancement</strong>这一主题。我们还考虑过使用协程与线程同时安全的队列 <a href="https://github.com/aio-libs/janus">janus</a> 等，但是最终还是采用了这个方案，因为这个方案的实现成本最低，而且也不会影响到用户的使用。</p><p>然后就是<strong>监测 Python agent 的性能瓶颈</strong>。这一块就是完完全全的让我学到新东西了，Mentor 先让我了解通过 <a href="https://github.com/sumerc/yappi">yappi</a> 解析 Python 程序的性能瓶颈，然后再通过 <a href="https://github.com/wg/wrk">WRK</a> 等测试工具对接口进行压力测试，这里真的非常感谢 Mentor 的指导。我的性能优化 30% 的结论一部分就是根据这里得出来的，当然其实在这之中我们还发现了一个新问题：除了 IO 耗时，agent 内部的 UUID 生成器也是耗时的主要瓶颈。由于它不是我的项目内部的需求，这里就只让 Mentor 记录下来了，如果看到这的你想要抓住机会贡献代码，那就是现在 😀。</p><h2 id="接下来？"><a href="#接下来？" class="headerlink" title="接下来？"></a>接下来？</h2><p>GSOC 2023 算是告一段落了，但我开源的脚步已经迈开并且不会停下。最近开题、实验室项目和 OSPP 已经让我分身乏术了，GSOC 的这个好消息算是给我来了针强心剂。希望一两个月后的 OSPP 结项能再写个杂谈出来吧 💪。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Open Source </tag>
            
            <tag> Google Summer of Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSOC 2023 - Python Agent Performance Enhancement Plan 项目提案</title>
      <link href="/2023/09/3959450b.html"/>
      <url>/2023/09/3959450b.html</url>
      
        <content type="html"><![CDATA[<center><h1 id="Apache-SkyWalking-Python-Agent-Performance-Enhancement-Plan"><a href="#Apache-SkyWalking-Python-Agent-Performance-Enhancement-Plan" class="headerlink" title="Apache SkyWalking - Python Agent Performance Enhancement Plan"></a>Apache SkyWalking - Python Agent Performance Enhancement Plan</h1><h2 id="Proposal-for-Google-Summer-of-Code-2023"><a href="#Proposal-for-Google-Summer-of-Code-2023" class="headerlink" title="Proposal for Google Summer of Code 2023"></a>Proposal for Google Summer of Code 2023</h2></center><h2 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h2><h3 id="Personal-Information"><a href="#Personal-Information" class="headerlink" title="Personal Information"></a>Personal Information</h3><ul><li><strong>Name</strong>: ***</li><li><strong>Email</strong>: ***</li><li><strong>Github</strong>: <a href="https://github.com/FAWC438">@FAWC438</a></li><li><strong>Blog</strong>: <a href="https://alrisha.cn/">alrisha.cn</a> ( in Chinese )</li><li><strong>Location</strong>: China</li><li><strong>Timezone</strong>: GMT+8</li><li><strong>University</strong>: <a href="https://en.wikipedia.org/wiki/Beijing_University_of_Posts_and_Telecommunications">Beijing University of Posts and Telecommunications</a></li><li><strong>Degree in progress</strong>: Master of Computer Science and Technology</li></ul><h3 id="Why-Me"><a href="#Why-Me" class="headerlink" title="Why Me"></a>Why Me</h3><p>My primary programming languages are Python, Java and Go, with Python being my best. I am interested in microservices and cloud-native, especially for cloud-native observability.</p><p>Even though I’m new to open source, I’m passionate about code. I often write small programs using different technology stacks and upload them to my Github repository. This year is the first time I learned about Google Summer of Code, and I think participating in this event will definitely allow me to get more technically advanced and create cooler code!</p><p>I had experience with <a href="https://github.com/open-telemetry/opentelemetry-python">OpenTelemetry</a> during one of my previous corporate internships, and since OpenTelemetry’s Python agent implementation is very similar to Skywalking’s Python agent, I believe I was able to quickly become familiar with Skywalking’s Python agent code architecture and operating principles.</p><p>I’m also familiar with the async concept. I am currently pursuing a Master’s degree in Computer Science and Technology at the <a href="https://scs.bupt.edu.cn/info/1247/2656.htm">Information Networking Center</a> at Beijing University of Posts and Telecommunications. In my daily projects, I often need to implement large-scale network IO tasks, which gives me some experience with parallel programming.</p><h2 id="Project-Description"><a href="#Project-Description" class="headerlink" title="Project Description"></a>Project Description</h2><ul><li><strong>Project Name</strong>: <a href="https://issues.apache.org/jira/browse/COMDEV-502">Apache SkyWalking - Python Agent Performance Enhancement Plan</a></li><li><strong>Mentor</strong>: <a href="https://github.com/Superskyyy">@Superskyyy</a>, <a href="https://github.com/kezhenxu94">@kezhenxu94</a></li><li><strong>Abstract</strong>: Currently, SkyWalking Python agent is implemented with the Threading module to provide data reporters. Yet with the growth of the Python agent, it is now fully capable and requires more resources than when only tracing was supported.</li><li><strong>Goal</strong>:<ul><li>Deprecate or provide an alternative implementation of data reporters (Trace&#x2F;Log&#x2F;Meter), maybe also for profilers.</li><li>The alternative implementation should also work for gRPC&#x2F;HTTP&#x2F;Kafka using corresponding async clients.</li><li>A simple but reliable performance test job in CI&#x2F;local.</li></ul></li></ul><h2 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h2><h3 id="Familiarity-with-the-Skywalking-Ecosystem"><a href="#Familiarity-with-the-Skywalking-Ecosystem" class="headerlink" title="Familiarity with the Skywalking Ecosystem"></a>Familiarity with the Skywalking Ecosystem</h3><ul><li>Build from source and run Skywalking Python agent, make dev environment and dependencies ready on my machine.</li><li>Try to finish the task in <a href="https://github.com/apache/skywalking/issues/10447">issue#10447</a>, currently waiting for mentor to reproduce the problem with my code.</li></ul><h3 id="Investigate-Asynchronous-Protocol-API-Implementations"><a href="#Investigate-Asynchronous-Protocol-API-Implementations" class="headerlink" title="Investigate Asynchronous Protocol API Implementations"></a>Investigate Asynchronous Protocol API Implementations</h3><h4 id="For-gRPC"><a href="#For-gRPC" class="headerlink" title="For gRPC"></a>For gRPC</h4><p>The more clear solution is to use the official <a href="https://grpc.github.io/grpc/python/grpc_asyncio.html">grpc.aio</a>, which obviously has the best support.</p><h4 id="For-Kafka"><a href="#For-Kafka" class="headerlink" title="For Kafka"></a>For Kafka</h4><p><a href="https://github.com/confluentinc/confluent-kafka-python">confluent kafka</a> and <a href="https://github.com/aio-libs/aiokafka">aiokafka</a> can both be used for asynchronous api.</p><ul><li>confluent kafka has a more active community, but currently does not support out-of-the-box use of asynio and requires <a href="https://www.confluent.io/blog/kafka-python-asyncio-integration/">more code</a> to implement asynchronous functionality.</li><li>aiokafka’s API is more convenient and intuitive to use, and it seamlessly supports the asyncio library. But it has a relatively small community and may not have an advantage in terms of performance.</li></ul><p>Here is a simple benchmark of the two libraries (Skywalking Python agent always plays a role of kafka <strong>producer</strong>):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> confluent_kafka <span class="keyword">import</span> KafkaException</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> aiokafka <span class="keyword">import</span> AIOKafkaProducer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> confluent_kafka</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AIOProducer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, configs, loop=<span class="literal">None</span></span>):</span><br><span class="line">        self._loop = loop <span class="keyword">or</span> asyncio.get_event_loop()</span><br><span class="line">        self._producer = confluent_kafka.Producer(configs)</span><br><span class="line">        self._cancelled = <span class="literal">False</span></span><br><span class="line">        self._poll_thread = Thread(target=self._poll_loop)</span><br><span class="line">        self._poll_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_poll_loop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self._cancelled:</span><br><span class="line">            self._producer.poll(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        self._cancelled = <span class="literal">True</span></span><br><span class="line">        self._poll_thread.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce_with_callback</span>(<span class="params">self, topic, value, on_delivery=<span class="literal">None</span></span>):</span><br><span class="line">        result = self._loop.create_future()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">ack</span>(<span class="params">err, msg</span>):</span><br><span class="line">            <span class="keyword">if</span> err:</span><br><span class="line">                self._loop.call_soon_threadsafe(result.set_exception, KafkaException(err))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._loop.call_soon_threadsafe(result.set_result, msg)</span><br><span class="line">            <span class="keyword">if</span> on_delivery:</span><br><span class="line">                self._loop.call_soon_threadsafe(on_delivery, err, msg)</span><br><span class="line">        self._producer.produce(topic, value, on_delivery=ack)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DATA_SIZE = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_confluent</span>():</span><br><span class="line">    producer = AIOProducer(&#123;<span class="string">&quot;bootstrap.servers&quot;</span>: <span class="string">&quot;localhost:9094&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(DATA_SIZE):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># Produce messages</span></span><br><span class="line">            <span class="keyword">await</span> producer.produce_with_callback(<span class="string">&quot;test-topic&quot;</span>, <span class="string">&quot;message&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    producer.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send_aio</span>():</span><br><span class="line">    producer = AIOKafkaProducer(bootstrap_servers=<span class="string">&#x27;localhost:9094&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> producer.start()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(DATA_SIZE):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># Produce messages</span></span><br><span class="line">           <span class="keyword">await</span> producer.send_and_wait(<span class="string">&quot;test-topic&quot;</span>, <span class="string">b&quot;message&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">await</span> producer.stop()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">await</span> producer.stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_normal</span>(<span class="params">on_delivery=<span class="literal">None</span></span>):</span><br><span class="line">    producer = confluent_kafka.Producer(&#123;<span class="string">&quot;bootstrap.servers&quot;</span>: <span class="string">&quot;localhost:9094&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(DATA_SIZE):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># Produce messages</span></span><br><span class="line">            producer.poll(<span class="number">0</span>)</span><br><span class="line">            producer.produce(<span class="string">&quot;test-topic&quot;</span>, <span class="string">&quot;message&quot;</span>, on_delivery=on_delivery)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    producer.flush()</span><br><span class="line"></span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">asyncio.run(send_confluent())</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;confluent_kafka async: <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span> seconds&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">asyncio.run(send_aio())</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;aiokafka async: <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span> seconds&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ack</span>(<span class="params">err, msg</span>):</span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cnt = cnt + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">send_normal(ack)</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;confluent_kafka sync: <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span> seconds&quot;</span>)</span><br></pre></td></tr></table></figure><p>The result is:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">confluent_kafka async: 27.60 seconds</span><br><span class="line">aiokafka async: 3.66 seconds</span><br><span class="line">confluent_kafka <span class="built_in">sync</span>: 0.03 seconds</span><br></pre></td></tr></table></figure><p>Let me explain this result in detail.</p><p>In confluent kafka, the main blocking operations are the <a href="https://docs.confluent.io/platform/current/clients/confluent-kafka-python/html/index.html#confluent_kafka.Producer.poll">poll()</a>&#x2F;<a href="https://docs.confluent.io/platform/current/clients/confluent-kafka-python/html/index.html#confluent_kafka.Producer.flush">flush()</a> functions, which are used to receive callback events for messages produced by the producer (see this <a href="https://github.com/confluentinc/confluent-kafka-python/issues/137#issuecomment-282427382">issue</a>). To enable confluent kafka to run on the asyncio model, the official example (and the code I wrote) implements the asyncio interface by binding the <code>poll()</code> operation to an additional thread and making the <code>produce()</code> operation mandatory for the callback function <code>ack()</code>. This results in <strong>having to execute a callback function involving a cross-thread call after each production data</strong>, which I think is the main reason why confluent kafka performs very poorly in the asyncio model.</p><p>In addition, aiokafka performs normally under asynchronous tasks, but I also found that confluent kafka performs exceptionally well under the traditional synchronous model (aiokafka does not have an interface for synchronous tasks).</p><p>On the one hand, this is because my callback function is relatively simple, on the other hand, I set the timeout parameter of the <code>poll()</code> function to 0, which means that the producer will not have any waits for the callback of the sent information. In my case it worked fine, but in more heavy workloads, this is likely to cause confluent kafka’s local buffer queue to overflow and cause catastrophic consequences such as data loss. I actually ran into this problem while working on <a href="https://github.com/apache/skywalking/issues/10447">issue#10447</a>. If we try to slightly increase the <code>poll()</code> timeout parameter in the synchronous task, for example, set it to <code>0.1</code> (seconds), we can see what the result is:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confluent_kafka <span class="built_in">sync</span>: 27.92 seconds</span><br></pre></td></tr></table></figure><p>As expected, its performance plummeted.</p><p>So in summary, aiokafka seems to be <strong>better</strong> than confluent kafka in all aspects in terms of support for the asyncio model</p><h4 id="For-HTTP"><a href="#For-HTTP" class="headerlink" title="For HTTP"></a>For HTTP</h4><p><a href="https://github.com/encode/httpx">httpx</a> and <a href="https://github.com/aio-libs/aiohttp">aiohttp</a> can both be used for asynchronous api.</p><p>There is a <a href="https://oxylabs.io/blog/httpx-vs-requests-vs-aiohttp">related blog</a> for reference.</p><ul><li>httpx is a very comprehensive python networking library that greatly extends python’s traditional requests and other libraries to support many new features, including, of course, asyncio asynchronous support, which we need in particular. Its API is almost similar to that of the traditional requests library, so it’s less difficult to get started and has a more active community. However, its powerful and comprehensive features maybe also its downside, as its performance for asynchronous tasks does not seem to be as good as the aiohttp library, which focuses on asynchronous optimization.</li><li>The aiohttp library is another available option. It is focused on optimizing python’s asynchronous network io performance and does not have many additional feature extensions. Given that the goal of this project is performance optimization rather than feature extensions, aiohttp is probably the better choice.</li></ul><p>Here is a simple benchmark of the two libraries (Windows WSL platform, 12-core Intel CPU):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">REQUEST_NUMBER = <span class="number">1000</span></span><br><span class="line">TARGET_HTTP_URL = <span class="string">&quot;http://10.3.242.223:9999/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">httpx_test</span>():</span><br><span class="line">    httpx_client = httpx.AsyncClient()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Send 100 asynchronous GET requests using HTTPX</span></span><br><span class="line">        start_time = time.perf_counter()</span><br><span class="line">        tasks = [httpx_client.get(TARGET_HTTP_URL) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(REQUEST_NUMBER)]</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        end_time = time.perf_counter()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;HTTPX: <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span> seconds&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">await</span> httpx_client.aclose()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">aiohttp_test</span>():</span><br><span class="line">    aiohttp_client = aiohttp.ClientSession()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Send 100 asynchronous GET requests using AIOHTTP</span></span><br><span class="line">        start_time = time.perf_counter()</span><br><span class="line">        tasks = [aiohttp_client.get(TARGET_HTTP_URL) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(REQUEST_NUMBER)]</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        end_time = time.perf_counter()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;AIOHTTP: <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span> seconds&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">await</span> aiohttp_client.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># asyncio.run(main())</span></span><br><span class="line">asyncio.run(httpx_test())</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">asyncio.run(aiohttp_test())</span><br></pre></td></tr></table></figure><p>I deployed the flask service on port 9999 on a server on the campus LAN and made asynchronous requests to port 9999 locally via httpx and aiohttp respectively. The results are as follows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTPX: 2.75 seconds</span><br><span class="line">AIOHTTP: 1.47 seconds</span><br></pre></td></tr></table></figure><p>So far it looks like aiohttp has a real performance advantage, as mentioned in that <a href="https://oxylabs.io/blog/httpx-vs-requests-vs-aiohttp">blog</a>. However, after I set the <code>TARGET_HTTP_URL</code> parameter to a domain name on the Internet, the result is the exact <strong>opposite</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 requests https://www.baidu.com</span></span><br><span class="line">HTTPX: 0.41 seconds</span><br><span class="line">AIOHTTP: 1.07 seconds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 100 requests https://www.microsoft.com</span></span><br><span class="line">HTTPX: 3.76 seconds</span><br><span class="line">AIOHTTP: 4.42 seconds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 100 requests https://www.bupt.edu.cn</span></span><br><span class="line">HTTPX: 0.38 seconds</span><br><span class="line">AIOHTTP: 1.10 seconds</span><br></pre></td></tr></table></figure><p>Also, httpx is more stable. When I use a proxy or access some URLs that are very slow to respond, httpx always returns correctly, while aiohttp is sometimes slower or wrong.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 100 requests https://google.github.io/gsocguides/ Frist try</span></span><br><span class="line">HTTPX: 1.25 seconds</span><br><span class="line">AIOHTTP: 0.95 seconds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 100 requests https://google.github.io/gsocguides/ Second try</span></span><br><span class="line">HTTPX: 1.18 seconds</span><br><span class="line">AIOHTTP: 1.77 seconds</span><br></pre></td></tr></table></figure><p>I guess this is probably because httpx is optimized for production deployments, e.g. in terms of DNS or retransmission policies, while aiohttp does not do a good job in this area and lacks stability.</p><p>In addition, aiohttp <a href="https://docs.aiohttp.org/en/latest/http_request_lifecycle.html">needs more codes</a> in implementation, at this point httpx is more convenient.</p><p>In summary, aiohttp has a performance advantage over httpx, but this is in theory. In a broader network environment, httpx is more stable, has better availability, and has smoother performance (aiohttp’s performance fluctuates more). And httpx requires less code than aiohttp, which can also increase code readability and development efficiency. Finally, httpx additionally supports many new features not supported by aiohttp, such as http&#x2F;2.0, which may also benefit the Skywalking Python agent for future expansion.</p><p>However, given that the main goal of this proposal is just IO performance improvement, the choice between these two options needs to be explored in more depth.</p><h2 id="Investigate-queues-used-between-both-synchronous-and-asynchronous-code"><a href="#Investigate-queues-used-between-both-synchronous-and-asynchronous-code" class="headerlink" title="Investigate queues used between both synchronous and asynchronous code"></a>Investigate queues used between both synchronous and asynchronous code</h2><p>Due to the highly invasive nature of making asyncio changes, code refactoring will be a recursive process, which may result in python agent users being overly aware of async code. For this, we may need a bridge to properly buffer the difference between synchronous code and asynchronous code, instead of turning all the code into asynchronous implementation. It’s a good idea to retrofit on the queue.</p><p>A more suitable option is to use the <a href="https://github.com/aio-libs/janus">janus</a> queue. It is simple enough, light enough, and can meet the current requirements. <a href="https://github.com/dano/aioprocessing">aioprocessing</a>‘s queue is also an alternative, but it is more complex and has many features we don’t use</p><p>It must be made clear that janus still has limit with usability. For example, in a thread where there is no asyncio event loop, we can’t create janus queues directly (see this <a href="https://github.com/aio-libs/janus/issues/448">issue</a>).</p><p>In addition, using a cross-synchronous-asynchronous queue will definitely cause performance loss. janus’s <a href="https://github.com/aio-libs/janus/issues/419">issue#419</a> mentions this problem. The reason is probably that the underlying implementation is basically based on calling <code>asyncio.run_in_executor()</code> , which leads to the overhead of internal threads.</p><p>Therefore, it is also necessary to use asyncio queue when implementing asyncio refactoring. Once it is confirmed that no thread safety issues will be raised, asyncio queue is clearly our first choice.</p><h2 id="Plan"><a href="#Plan" class="headerlink" title="Plan"></a>Plan</h2><ol><li><p><strong>Provide asyncio implementation of data reporters and protocol clients</strong></p><ul><li>Replace the Threading module of Trace&#x2F;Log&#x2F;Meter with asyncio.</li><li>Replace the protocol(gRPC&#x2F;Kafka&#x2F;HTTP) client implementation so that it supports the new concurrent model.</li><li>If the above tasks go well, the next refactoring may also be done for profilers. (Optional)</li><li>Considering that asyncio <a href="https://github.com/python/cpython/issues/66197">cannot support fork</a>, additional multi-processing work may be required to make the Python agent run on an independent process. (Optional)</li></ul></li></ol><blockquote><p><strong>Extra info:</strong> According to <a href="https://github.com/python/cpython/issues/66285#issuecomment-1322336873">this issue</a>, asyncio will fully support <code>fork()</code> in Python 3.12</p></blockquote><ol start="2"><li><p><strong>Provide a simple but reliable performance test</strong></p><ul><li>The performance test should be able to test the performance of the new implementation and compare the performance of the new implementation with the performance of the old implementation.</li><li>If I find that some asyncio implementations are even difficult to surpass the previous thread implementation, I will focus on optimizing my code and consult my mentor; if the performance is still not satisfactory, I may still need to keep the old implementation.</li></ul></li><li><p><strong>Keep in Touch</strong></p><p>I will keep in touch with my mentor and the community through the mailing list and some instant messaging tools such as WeChat. If I run into a problem that I really have trouble solving on my own or have questions about Skywalking Python’s architecture and concepts, I’m very proactive in asking mentor questions.</p></li><li><p><strong>Output</strong></p><ul><li>Submit a PR to Apache Skywalking’s code repository.</li><li>Improve the relevant documentation.</li><li>Provide relevant quantitative data for performance optimization, such as the results of benchmark tests.</li></ul></li></ol><h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><blockquote><p>Depending on the progress of the project and the requirements of the mentor, this part may undergo some changes after coding officially begins.</p></blockquote><ul><li><strong>now to May 4: before Accepted GSoC contributor projects announced</strong><ul><li>Learn more about the Skywalking ecosystem</li><li>Try to submit the code related to <a href="https://github.com/apache/skywalking/issues/10447">issue#10447</a> to PR</li><li>Learn which modules to focus on for improvement or refactoring in the Skywalking python agent. Run and test some of the threaded models in the code in my local environment by converting them to asyncio models</li><li>Before introducing the asyncio model, try replacing the protocol client implementation</li></ul></li><li><strong>May 4 to May 29: before Coding officially begins</strong><ul><li>Rough replacement of data reports from the threaded model to the asyncio model(Rough version, may lack usability)</li><li>Complete the basic replacement of the protocol client</li></ul></li><li><strong>May 29 to July 14: before Midterm evaluation</strong><ul><li>Iteratively optimize my code to further improve its usability&#x2F;performance</li><li>Complete some of the usability and performance testing, further discussion with Mentor may be required on what metrics are needed for testing</li><li>If the above tasks go well, a further asynchronous modification of the profilers module and multi-process refactoring is also possible</li></ul></li><li><strong>July 14 to August 21: before Final week</strong><ul><li>Complete the final replacement of the protocol client</li><li>Complete the final replacement of the data reporter</li><li>Complete the final performance testing</li><li>Code style and quality review, write documentation under the guidance of mentor</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Open Source </tag>
            
            <tag> Google Summer of Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos 单实例集群 Docker Compose 部署问题</title>
      <link href="/2023/05/412bacf1.html"/>
      <url>/2023/05/412bacf1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos-单实例集群-docker-compose-部署问题"><a href="#Nacos-单实例集群-docker-compose-部署问题" class="headerlink" title="Nacos 单实例集群 docker compose 部署问题"></a>Nacos 单实例集群 docker compose 部署问题</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 Linux 环境下通过 Docker Compose 部署 Nacos + Grafana + Prometheus 单实例集群，研究其监控功能时，遇到了无法部署的问题。我按照官方文档的以下指令在 CentOS 服务器部署 Nacos 集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/nacos-group/nacos-docker.git</span><br><span class="line"><span class="built_in">cd</span> nacos-docker</span><br><span class="line">docker-compose -f example/standalone-derby.yaml up</span><br></pre></td></tr></table></figure><p>我在自己 Windows 环境中进行部署非常正常。但我随后在 Linux 服务器上部署，集群在启动时报出了如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">nacos-standalone  | 2023-05-08 21:28:05,238 ERROR Error starting Tomcat context. Exception: org.springframework.beans.factory.UnsatisfiedDependencyException. Message: Error creating bean with name <span class="string">&#x27;basicAuthenticationFilter&#x27;</span> defined <span class="keyword">in</span> class path resource [com/alibaba/nacos/prometheus/filter/PrometheusAuthFilter.class]: Unsatisfied dependency expressed through method <span class="string">&#x27;basicAuthenticationFilter&#x27;</span> parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;nacosAuthConfig&#x27;</span> defined <span class="keyword">in</span> URL [jar:file:/home/nacos/target/nacos-server.jar!/BOOT-INF/lib/nacos-plugin-default-impl-2.2.2.jar!/com/alibaba/nacos/plugin/auth/impl/NacosAuthConfig.class]: Unsatisfied dependency expressed through constructor parameter 3; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;nacosUserDetailsServiceImpl&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;userPersistService&#x27;</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;embeddedUserPersistServiceImpl&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;databaseOperate&#x27;</span>; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="string">&#x27;standaloneDatabaseOperateImpl&#x27;</span>: Invocation of init method failed; nested exception is java.lang.RuntimeException: com.alibaba.nacos.api.exception.runtime.NacosRuntimeException: errCode: 500, errMsg: load derby-schema.sql error.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看起来，似乎是集群的 derby 持久化层出现了问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>实际上， github issue 中已经有很多人提出了这个问题，官方的回复在 Nacos 主仓库中的 <a href="https://github.com/alibaba/nacos/issues/9742">issue#9742</a> 有说明。这个问题的原因是因为 Nacos 的持久化层 Derby 数据库需要从磁盘加载，但还未等到 Derby 加载完成，Nacos 就开始执行 SQL 语句，导致 Derby 加载失败。这种问题往往出自于<strong>磁盘读写速度过慢，或是磁盘空间不足</strong>。我的 Windows PC 使用 SSD ，因此从来没有出现这个问题。但我使用的 Linux 服务器装载的是 HDD ，几乎总是会产生这样的错误。</p><p>解决方案也在 <a href="https://github.com/alibaba/nacos/issues/9742">issue#9742</a> 给出了，需要将环境变量 <code>db.pool.config.connectionTimeout</code> 改为 60000 (默认值是 30000)</p><p>另外，<a href="https://nacos.io/zh-cn/docs/monitor-guide.html">官方文档</a>指出，如果要使用集群中的 Grafana 和 Prometheus ，需要将 Nacos 中的 <code>/home/nacos/conf/application.properties</code> 映射到本地。然后在里面修改 <code>management.endpoints.web.exposure.include=*</code>。实际上直接在 <code>standalone-derby.yaml</code> 中添加也可以，更加方便，省去了管理配置文件的麻烦。</p><h2 id="完整的-docker-compose-yml"><a href="#完整的-docker-compose-yml" class="headerlink" title="完整的 docker-compose.yml"></a>完整的 docker-compose.yml</h2><p>修改后的 <code>example/standalone-derby.yaml</code> 如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:$&#123;NACOS_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nacos-standalone</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_POOL_CONFIG_CONNECTIONTIMEOUT=60000</span> <span class="comment"># 增加 derby 数据库等待时间</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE=*</span> <span class="comment"># 开启所有的监控端点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PREFER_HOST_MODE=hostname</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./standalone-logs/:/home/nacos/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9848:9848&quot;</span></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prom/prometheus:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./prometheus/prometheus-standalone.yaml:/etc/prometheus/prometheus.yml</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不要在 Linux 文件 IO 任务上使用协程</title>
      <link href="/2023/03/f67fbd68.html"/>
      <url>/2023/03/f67fbd68.html</url>
      
        <content type="html"><![CDATA[<p>在一项网络 IO 繁重的 Python 项目中，我大量使用了 gevent 的协程模型加速网络 IO ，效果比 Python 传统的线程池好很多。然而在后续数据预处理的部分遇到了问题。</p><p>我的项目结构是一个经典的单 provider 、多 consumer 模型，provider 负责读取一个超大文件（大于 8 Gb）并写入队列，然后多个 consumer 从队列读取数据并进行处理。如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">provider</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;&lt;file path&gt;&#x27;</span>, w) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            q.put(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    data = q.get()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">tasks = [gevent.spwan(provider)] + [gevent.spwan(consumer) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(works_num)]</span><br><span class="line">gevent.joinall(tasks)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然而在运行的时候，程序总是阻塞在文件读操作，即 <code>provider</code> 上。也就是说，必须等待文件读入队列这个事件结束后，消费者才能从队列获取数据进行处理，完全无法满足并行（边读边处理）的需要。</p><p>经过调研，我发现在 Linux 系统下，和网络 IO 不同，文件 IO 一直是 ready 状态，不存在不可达或需要等待的问题。因此 Linux 会使一个文件 IO <strong>线程</strong>不停进行 write&#x2F;read 。由于这个文件 IO 的过程阻塞了执行的线程，进而全部阻塞了该线程中的所有协程。这就是我遇到了读取&#x2F;写入一个文件，却导致所有协程阻塞的原因。</p><p>一篇<a href="https://www.remlab.net/op/nonblock.shtml">文章</a>指出，如果要实现文件 IO ，不得不至少实现多线程，没有其它选择——即使我们必须要面对 Python 臭名昭著的 GIL 锁。</p><p>gevent 的一个 <a href="https://github.com/gevent/gevent/issues/1070">issue</a> 也说明了为何不支持非阻塞式的文件 IO。</p><p>我将程序改为线程池实现后，就成功解决了这个问题，实现了边读边处理的并行需求。</p><blockquote><p>参考文章 <a href="https://blog.csdn.net/u014609111/article/details/118181367">https://blog.csdn.net/u014609111/article/details/118181367</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coroutine </tag>
            
            <tag> File IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基准测试工具 Wrk 的使用</title>
      <link href="/2023/03/e050e0b4.html"/>
      <url>/2023/03/e050e0b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="基准测试工具-Wrk-的使用"><a href="#基准测试工具-Wrk-的使用" class="headerlink" title="基准测试工具 Wrk 的使用"></a>基准测试工具 Wrk 的使用</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>wrk is a modern HTTP benchmarking tool capable of generating significant load when run on a single multi-core CPU.</p></blockquote><p><a href="https://github.com/wg/wrk">Wrk</a> 是一个轻便、高性能的、基于 C 编写的 HTTP 基准测试工具。使用它能轻松对 Web 端口进行一系列压力测试。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Wrk 只能在类 Unix 系统下安装，Windows 用户建议使用 WSL。以下以 <strong>Ubuntu</strong> 为例。</p><h3 id="编译工具-x2F-环境安装"><a href="#编译工具-x2F-环境安装" class="headerlink" title="编译工具&#x2F;环境安装"></a>编译工具&#x2F;环境安装</h3><p>确保安装以下包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">sudo apt update gcc <span class="comment"># 可选</span></span><br><span class="line">sudo apt install libssl-dev</span><br><span class="line">sudo apt install make</span><br><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><h3 id="安装-Wrk"><a href="#安装-Wrk" class="headerlink" title="安装 Wrk"></a>安装 Wrk</h3><p>在希望安装 wrk 的目录中，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/wg/wrk.git</span><br><span class="line"><span class="built_in">cd</span> wrk</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>make 操作耗时相对较长，需要耐心等待。完全安装完成后，在 wrk 目录下就能看见一个叫做 <code>wrk</code> 的可执行文件。此时即安装完成</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="命令一览"><a href="#命令一览" class="headerlink" title="命令一览"></a>命令一览</h3><p>查看 wrk 帮助信息，了解能够使用的指令及其含义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost wrk]<span class="comment"># ./wrk</span></span><br><span class="line">Usage: wrk &lt;options&gt; &lt;url&gt;</span><br><span class="line">  Options:</span><br><span class="line">    -c, --connections &lt;N&gt;  Connections to keep open</span><br><span class="line">    -d, --duration    &lt;T&gt;  Duration of <span class="built_in">test</span></span><br><span class="line">    -t, --threads     &lt;N&gt;  Number of threads to use</span><br><span class="line"></span><br><span class="line">    -s, --script      &lt;S&gt;  Load Lua script file</span><br><span class="line">    -H, --header      &lt;H&gt;  Add header to request</span><br><span class="line">        --latency          Print latency statistics</span><br><span class="line">        --<span class="built_in">timeout</span>     &lt;T&gt;  Socket/request <span class="built_in">timeout</span></span><br><span class="line">    -v, --version          Print version details</span><br><span class="line"></span><br><span class="line">  Numeric arguments may include a SI unit (1k, 1M, 1G)</span><br><span class="line">  Time arguments may include a time unit (2s, 2m, 2h)</span><br><span class="line">[root@localhost wrk]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>在一个开源项目中，我用 wrk 来测试 kafka 的两种 Python 客户端的性能。我使用命令 <code>./wrk -t36 -c4000 -d30s --latency http://&lt;server host&gt;/cat</code> 在相同环境下对两个采用不同 kafka 客户端的 Python FastAPI 端口进行压力测试。</p><ul><li><code>-t</code>: 由于是网络 IO 密集型测试，我采用服务器 CPU 核心数量（12 个）三倍的线程数量</li><li><code>-c</code>: 一般来说，HTTP 连接数为线程数量的 100 倍，此处我简单设置为 4000 个 HTTP 连接。</li><li><code>-d</code>: 我将测试持续时间设置为 30 秒</li><li><code>--latency</code>: 输出响应时间&#x2F;延迟的分部情况</li></ul><p>我分别得到了以下两个输出：</p><p><em><strong>kafka-python</strong></em>: 一个纯 Python 编写的 kafka 客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost wrk]<span class="comment"># ./wrk -t36 -c4000 -d30s --latency http://10.3.242.223:8087/cat</span></span><br><span class="line">Running 30s <span class="built_in">test</span> @ http://10.3.242.223:8087/cat</span><br><span class="line">  36 threads and 4000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.41s   336.86ms   1.87s    72.58%</span><br><span class="line">    Req/Sec    44.25     68.59   570.00     89.08%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.58s</span><br><span class="line">     75%    1.62s</span><br><span class="line">     90%    1.86s</span><br><span class="line">     99%    1.86s</span><br><span class="line">  16667 requests <span class="keyword">in</span> 30.05s, 2.65MB <span class="built_in">read</span></span><br><span class="line">  Socket errors: connect 0, <span class="built_in">read</span> 5861, write 0, <span class="built_in">timeout</span> 15241</span><br><span class="line">Requests/sec:    554.71</span><br><span class="line">Transfer/sec:     90.47KB</span><br><span class="line">[root@localhost wrk]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><em><strong>confluent-kafka-python</strong></em>: 一个基于 C kafka 库的 Python kafka 客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost wrk]<span class="comment"># ./wrk -t36 -c4000 -d30s --latency http://10.3.242.223:8086/cat</span></span><br><span class="line">Running 30s <span class="built_in">test</span> @ http://10.3.242.223:8086/cat</span><br><span class="line">  36 threads and 4000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.20s   426.34ms   1.98s    60.69%</span><br><span class="line">    Req/Sec    98.17    145.79     0.89k    87.40%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.16s</span><br><span class="line">     75%    1.56s</span><br><span class="line">     90%    1.79s</span><br><span class="line">     99%    1.92s</span><br><span class="line">  39687 requests <span class="keyword">in</span> 30.05s, 6.32MB <span class="built_in">read</span></span><br><span class="line">  Socket errors: connect 0, <span class="built_in">read</span> 3444, write 0, <span class="built_in">timeout</span> 19562</span><br><span class="line">Requests/sec:   1320.81</span><br><span class="line">Transfer/sec:    215.41KB</span><br><span class="line">[root@localhost wrk]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>可以看到，尽管二者在响应延迟上相差无几。但在网络吞吐量上， confluent-kafka-python 的性能是 kafka-python 的二倍以上。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Benchmarking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas 中判断某个元素是否存在的问题</title>
      <link href="/2023/02/2bf1425.html"/>
      <url>/2023/02/2bf1425.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas-中判断某个元素是否存在的问题"><a href="#Pandas-中判断某个元素是否存在的问题" class="headerlink" title="Pandas 中判断某个元素是否存在的问题"></a>Pandas 中判断某个元素是否存在的问题</h1><p>在使用 Pandas 处理数据的时候，常常需要判断某个元素在 DataFrame 或其中特定的行&#x2F;列中是否存在，下面给出一个例子以便详细说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;language&#x27;</span>: [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>], <span class="string">&#x27;number&#x27;</span>: [<span class="number">1995</span>, <span class="number">1995</span>, <span class="number">1991</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1991</span> <span class="keyword">in</span> df[<span class="string">&#x27;number&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> df[<span class="string">&#x27;number&#x27;</span>])</span><br></pre></td></tr></table></figure><p>你觉得这个程序会输出什么？答案可能让你大吃一惊</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># python pandas_test.py</span></span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>查找了相关资料后，我发现在 Pandas 中，类似 <code>1 in df[&#39;number&#39;]</code> 的输出，实际上等价于 <code>1 in df[&#39;number&#39;].index</code> ，即判断元素是否存在于索引而非数据中。那么如果要实现判断某个元素是否存在的功能，需要添加 <code>.values</code> 属性，以下代码能够输出预期的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;language&#x27;</span>: [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>], <span class="string">&#x27;number&#x27;</span>: [<span class="number">1995</span>, <span class="number">1995</span>, <span class="number">1991</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1991</span> <span class="keyword">in</span> df[<span class="string">&#x27;number&#x27;</span>].values)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> df[<span class="string">&#x27;number&#x27;</span>].values)</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># python pandas_test.py</span></span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生时代下链路追踪的最终形态：OpenTelemetry</title>
      <link href="/2023/01/a0c66ae9.html"/>
      <url>/2023/01/a0c66ae9.html</url>
      
        <content type="html"><![CDATA[<h1 id="云原生时代下链路追踪的最终形态：OpenTelemetry"><a href="#云原生时代下链路追踪的最终形态：OpenTelemetry" class="headerlink" title="云原生时代下链路追踪的最终形态：OpenTelemetry"></a>云原生时代下链路追踪的最终形态：OpenTelemetry</h1><blockquote><p>本文部分内容参考 <a href="https://opentelemetry.io/">https://opentelemetry.io/</a></p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a>分布式链路追踪</h3><p><strong>分布式链路追踪（Distributed Traces）</strong>，更常见的说法是<strong>链路追踪（Trace）</strong>，用于记录由应用程序或最终用户提出的请求在多服务架构（如微服务或 serverless 应用程序）中所传播的路径。</p><p>如果没有链路追踪，要想找出分布式系统中性能问题的原因是很困难的。</p><p>链路追踪提高了我们的应用或系统健康状况的可见性，让我们能够调试难以在本地重现的行为。链路追踪对于分布式系统来说是必不可少的，因为这些系统通常有非确定性的问题，或者过于复杂而无法在本地重现。</p><p>链路追踪使调试和理解分布式系统变得不那么困难，因为它分解了一个请求在分布式系统中流动时发生的情况。</p><p>一个链路追踪是由一个或多个 <strong>Span</strong> 组成的。第一个 Span 代表根 Span。每个根 Span 代表一个请求从开始到结束。父级 Span 下面的 Span 提供了一个更深入的背景，即在一个请求中发生了什么（或者说哪些步骤构成了一个请求）。</p><p>许多提供链路观测的后端将一个 Traces 可视化为瀑布图，看起来可能是这样的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://opentelemetry.io/img/waterfall_trace.png" alt="瀑布图"></p><p>瀑布图显示了根 Span 和其子 Span 之间的父子关系。当一个 Span 封装了另一个 Span，这也代表了一种嵌套关系。</p><h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>一个 Span 代表一个工作单位或操作单位。它跟踪一个请求所做的具体操作，描绘出在执行该操作的时间内所发生的事情。</p><p>Span 包含名称、与时间相关的数据、结构化的日志信息和其他元数据（如属性，Attributes），以提供关于它所追踪的操作的信息。</p><p>下面是一个 Span 中的信息类型的例子。</p><table><thead><tr><th align="center">Key</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">net.transport</td><td align="center">IP.TCP</td></tr><tr><td align="center">net.peer.ip</td><td align="center">10.244.0.1</td></tr><tr><td align="center">net.peer.port</td><td align="center">10243</td></tr><tr><td align="center">net.host.name</td><td align="center">localhost</td></tr><tr><td align="center">http.method</td><td align="center">GET</td></tr><tr><td align="center">http.target</td><td align="center">&#x2F;cart</td></tr><tr><td align="center">http.server_name</td><td align="center">frontend</td></tr><tr><td align="center">http.route</td><td align="center">&#x2F;cart</td></tr><tr><td align="center">http.scheme</td><td align="center">http</td></tr><tr><td align="center">http.host</td><td align="center">localhost</td></tr><tr><td align="center">http.flavor</td><td align="center">1.1</td></tr><tr><td align="center">http.status_code</td><td align="center">200</td></tr><tr><td align="center">http.user_agent</td><td align="center">Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;106.0.0.0 Safari&#x2F;537.36</td></tr></tbody></table><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="链路追踪为什么重要"><a href="#链路追踪为什么重要" class="headerlink" title="链路追踪为什么重要"></a>链路追踪为什么重要</h3><p>微服务架构使开发者能够更快、更独立地构建和发布软件，因为他们不再受制于与单体架构相关的复杂的发布流程。</p><p>随着这些分布式系统的扩展，开发人员越来越难看到自己的服务是如何依赖或影响其他服务的，特别是在部署后或停运期间，速度和准确性至关重要。</p><p>并且，链路追踪带来的可观察性使开发者和运营商二者都能进一步明确系统的状态。</p><h3 id="链路追踪的各种实践"><a href="#链路追踪的各种实践" class="headerlink" title="链路追踪的各种实践"></a>链路追踪的各种实践</h3><p>为了使一个系统可以被观察到，它必须被<strong>插桩（instrumented）</strong>。也就是说，代码必须发出跟踪、度量和日志，这些数据也被称为<strong>遥测数据</strong>。然后，这些数据必须被发送到<strong>观测者（Observability）</strong> 后端。现在有很多观测者后端，从一些开源工具（如 Jaeger 和 Zipkin）到商业 SaaS 产品。</p><p>过去，对代码进行检测的方式会有所不同，因为每个观测者后端都有自己的检测库和代理，用于向工具发送数据。</p><p>这意味着向观测者后端发送数据时没有标准化的数据格式。此外，如果一个公司选择更换观测者后端，就意味着他们必须重新对其代码进行测量，并配置新的代理，以便能够向所选择的新工具发射遥测数据。</p><p>由于缺乏标准化，最终的结果是缺乏数据的可移植性，并给用户带来了维护插桩库的负担。</p><p>认识到标准化的需要，云计算社区走到一起，两个开源项目诞生了。OpenTracing（云原生计算基金会（CNCF）项目）和 OpenCensus（谷歌开源社区项目）。</p><ul><li><p><strong>OpenTracing</strong> 提供了一个供应商中立的 API，用于将遥测数据发送到观测者后端；不过，它依赖于开发者实现自己的库来满足规范。</p></li><li><p><strong>OpenCensus</strong> 提供了一套特定语言的库，开发者可以用它来检测他们的代码，并将其发送到他们支持的任何一个后端。</p></li></ul><h3 id="OpenTelemetry-的诞生"><a href="#OpenTelemetry-的诞生" class="headerlink" title="OpenTelemetry 的诞生"></a>OpenTelemetry 的诞生</h3><p>为了拥有一个单一的标准，OpenCensus 和 OpenTracing 在 2019 年 5 月被合并为 OpenTelemetry（简称 OTel）。作为一个 CNCF 的孵化项目，OpenTelemetry 吸取了两个项目的精华，并去其糟粕。</p><p>OTel 的目标是提供一套标准化的、厂商无关的 SDK、API 和工具，用于提取、转换和发送数据到观测者后端。</p><h3 id="OpenTelemetry-能做什么"><a href="#OpenTelemetry-能做什么" class="headerlink" title="OpenTelemetry 能做什么"></a>OpenTelemetry 能做什么</h3><ul><li>每种编程语言都有一个单一的、与供应商无关的插桩库，支持自动和手动插桩。</li><li>提供一个单一的供应商中立的采集器二进制文件，可以以各种方式部署。</li><li>一个端到端的实现，以生成、发送、收集、处理和导出遥测数据。</li><li>完全控制你的数据，能够通过配置将数据并行地发送到多个目的地。</li><li>开放标准的语义约定，以确保供应商的数据收集不受影响</li><li>能够平行地支持多种上下文传播格式，以确保随着标准的发展，程序代码能够顺利迁移。</li><li>无论你在链路中处于什么位置，都能保证你的下游链路对你可见。</li></ul><p>由于支持各种开源和商业协议、格式和上下文传播机制，以及为 OpenTracing 和 OpenCensus 项目提供兼容，在项目中采用 OpenTelemetry 是很容易的。</p><p>不过，与 Jaeger 、 Zipkin 等不同。OpenTelemetry 并不提供观测后端，它更类似于一种统一的 API ，用于给不同的观测后端提供数据。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>以阿里云作为观测者（Observability）后端，OpenTelemetry 为遥测接口。实现一个如下图所示的链路追踪：</p><center><p><em>拓扑图</em></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/01/29/fBDAjmePxlHKgUG.png" alt="topo.png"></p><p><em>节点列表</em></p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2023/01/29/Qk3pRxSA6TIZyOV.png" alt="Severs.png"></p><table><thead><tr><th align="center">Node Name</th><th align="center">Language</th><th align="center">Instrumentation</th></tr></thead><tbody><tr><td align="center">otlp-server</td><td align="center">Golang</td><td align="center">Manual</td></tr><tr><td align="center">otlp-client</td><td align="center">Golang</td><td align="center">Manual</td></tr><tr><td align="center">otlp-flask</td><td align="center">Python</td><td align="center">Auto</td></tr><tr><td align="center">otlp-spring</td><td align="center">Java</td><td align="center">Auto</td></tr><tr><td align="center">otlp-php</td><td align="center">PHP</td><td align="center">Auto(not complete)</td></tr></tbody></table></center><p>作为链路追踪的部署者（即运维角度），一个链路追踪在企业部署最大的阻力实际上在于其相关代码是否具有侵入性（即实现链路追踪是否需要大幅度更改生产环境源代码），通俗点讲就是开发给不给运维面子，因为本质上链路追踪是一种“苦开发、乐运维”的技术。除非在特细插桩粒度且由 <em>运维开发</em> 进行部署这种特殊情况，否则基本都应考虑自动插桩功能。</p><p>然而，截至至本文撰写时（2023.1.29），Golang 的自动插桩功能还未实现，而 PHP 的自动插桩功能存在很大问题，使用起来基本上和手动无异。因此在此特别说明，下文还将具体讨论。</p><blockquote><p>实际上 Golang 和 C++ 的 OpenTelemetry 手动插桩功能已经非常完善了，但是仍然迟迟没有推出自动插桩插件。参考 OpenTelemetry 的 Java 自动插桩是基于 JVM 代理的字节码注入、Python 自动插桩是基于其解释性语言特性，我有理由怀疑在处理这两个语言的编译器上 OpenTelemetry 团队正遇到了不小困难。此处欢迎指正</p></blockquote><h3 id="Client-节点"><a href="#Client-节点" class="headerlink" title="Client 节点"></a>Client 节点</h3><p>Client 节点是一个利用 Go 编写的节点，只具有发送 HTTP 请求的功能。它是链路的起点。该节点源代码参考了 OpenTelemetry 的<a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/examples/demo">官方示例</a></p><p>该代码向 Server 节点的 7080 端口的 <code>/hello</code> 路由以<strong>一定时间间隔</strong>发送 HTTP Get 请求。</p><p>由于 Golang 的原因，此处采用手动插桩的方式，因此代码量较大，且配置步骤较多。不过可以看出插桩的自定义范围也很广。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright The OpenTelemetry Authors</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//       http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">// limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample contains a simple client that periodically makes a simple http request</span></span><br><span class="line"><span class="comment">// to a server and exports to the OpenTelemetry service.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/baggage&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/propagation&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/sdk/resource&quot;</span></span><br><span class="line">sdkTrace <span class="string">&quot;go.opentelemetry.io/otel/sdk/trace&quot;</span></span><br><span class="line">semConv <span class="string">&quot;go.opentelemetry.io/otel/semconv/v1.4.0&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ClientServiceName = <span class="string">&quot;otlp-demo-client&quot;</span></span><br><span class="line"><span class="keyword">const</span> TraceInstrumentationName = <span class="string">&quot;otlp-demo-tracer&quot;</span></span><br><span class="line"><span class="keyword">const</span> DefaultServerEndpoint = <span class="string">&quot;http://0.0.0.0:7080/hello&quot;</span></span><br><span class="line"><span class="keyword">const</span> otelAgentAddr, xtraceToken = <span class="string">&quot;tracing-analysis-dc-hz.aliyuncs.com:8090&quot;</span>, <span class="string">&quot;&lt;你的阿里云 grpc token&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initializes an OTLP exporter, and configures the corresponding trace and</span></span><br><span class="line"><span class="comment">// metric providers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initProvider</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// grpc 方式</span></span><br><span class="line">headers := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Authentication&quot;</span>: xtraceToken&#125;</span><br><span class="line">traceClient := otlptracegrpc.NewClient(</span><br><span class="line">otlptracegrpc.WithInsecure(),</span><br><span class="line">otlptracegrpc.WithEndpoint(otelAgentAddr),</span><br><span class="line">otlptracegrpc.WithHeaders(headers), <span class="comment">// 鉴权信息</span></span><br><span class="line">otlptracegrpc.WithDialOption(grpc.WithBlock()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// http 方式</span></span><br><span class="line"><span class="comment">//traceClientHttp := otlptracehttp.NewClient(</span></span><br><span class="line"><span class="comment">//otlptracehttp.WithEndpoint(&quot;tracing-analysis-dc-hz.aliyuncs.com&quot;),</span></span><br><span class="line"><span class="comment">//otlptracehttp.WithURLPath(&quot;&lt;你的阿里云 HTTP 接入点&gt;&quot;),</span></span><br><span class="line"><span class="comment">//otlptracehttp.WithInsecure())</span></span><br><span class="line"><span class="comment">//otlptracehttp.WithCompression(1)</span></span><br><span class="line"></span><br><span class="line">traceExp, err := otlptrace.New(ctx, traceClient)</span><br><span class="line">handleErr(err, <span class="string">&quot;Failed to create the collector trace exporter&quot;</span>)</span><br><span class="line"></span><br><span class="line">res, err := resource.New(ctx,</span><br><span class="line">resource.WithFromEnv(),</span><br><span class="line">resource.WithProcess(),</span><br><span class="line">resource.WithTelemetrySDK(),</span><br><span class="line">resource.WithHost(),</span><br><span class="line">resource.WithAttributes(</span><br><span class="line"><span class="comment">// the service name used to display traces in backends</span></span><br><span class="line">semConv.ServiceNameKey.String(ClientServiceName),</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">handleErr(err, <span class="string">&quot;failed to create resource&quot;</span>)</span><br><span class="line"></span><br><span class="line">bsp := sdkTrace.NewBatchSpanProcessor(traceExp)</span><br><span class="line">tracerProvider := sdkTrace.NewTracerProvider(</span><br><span class="line">sdkTrace.WithSampler(sdkTrace.AlwaysSample()),</span><br><span class="line">sdkTrace.WithResource(res),</span><br><span class="line">sdkTrace.WithSpanProcessor(bsp),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set global propagator to traceContext (the default is no-op).</span></span><br><span class="line">otel.SetTextMapPropagator(propagation.TraceContext&#123;&#125;)</span><br><span class="line">otel.SetTracerProvider(tracerProvider)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;OTEL init success&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cxt, cancel := context.WithTimeout(ctx, time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">if</span> err := traceExp.Shutdown(cxt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">otel.Handle(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErr</span><span class="params">(err <span class="type">error</span>, message <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;%s: %v&quot;</span>, message, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;client start&quot;</span>)</span><br><span class="line">shutdown := initProvider()</span><br><span class="line"><span class="keyword">defer</span> shutdown()</span><br><span class="line"></span><br><span class="line">tracer := otel.Tracer(TraceInstrumentationName)</span><br><span class="line"></span><br><span class="line">method, _ := baggage.NewMember(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;repl&quot;</span>)</span><br><span class="line">client, _ := baggage.NewMember(<span class="string">&quot;client&quot;</span>, <span class="string">&quot;cli&quot;</span>)</span><br><span class="line">bag, _ := baggage.New(method, client)</span><br><span class="line"></span><br><span class="line">defaultCtx := baggage.ContextWithBaggage(context.Background(), bag)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">ctx, span := tracer.Start(defaultCtx, <span class="string">&quot;ExecuteRequest&quot;</span>)</span><br><span class="line">makeRequest(ctx)</span><br><span class="line">span.End()</span><br><span class="line">time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">demoServerAddr, ok := os.LookupEnv(<span class="string">&quot;DEMO_SERVER_ENDPOINT&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">demoServerAddr = DefaultServerEndpoint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trace an HTTP client by wrapping the transport</span></span><br><span class="line">client := http.Client&#123;</span><br><span class="line">Transport: otelhttp.NewTransport(http.DefaultTransport),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure we pass the context to the request to avoid broken traces.</span></span><br><span class="line">req, err := http.NewRequestWithContext(ctx, <span class="string">&quot;GET&quot;</span>, demoServerAddr, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">handleErr(err, <span class="string">&quot;failed to http request&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All requests made with this client will create spans.</span></span><br><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err := res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Server-节点"><a href="#Server-节点" class="headerlink" title="Server 节点"></a>Server 节点</h3><p>Server 节点也是一个利用 Go 编写的节点，同时具有发送和接收 HTTP 请求的功能。它是链路的关键中继点。该节点源代码同样参考了 OpenTelemetry 的<a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/examples/demo">官方示例</a></p><p>该代码持续监听 7080 端口，同时向 Flask 节点（ <a href="http://localhost:5000/test">http://localhost:5000/test</a> ）、PHP 节点（ <a href="http://localhost:8083/">http://localhost:8083/</a> ）和 Spring 节点（ <a href="http://localhost:5638/test">http://localhost:5638/test</a> ）发送请求。请求以一定间隔发送。</p><p>与 Client 节点类似，此处采用手动插桩的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright The OpenTelemetry Authors</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//       http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">// limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample contains a simple http server that exports to the OpenTelemetry agent.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/codes&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/attribute&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/propagation&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/sdk/resource&quot;</span></span><br><span class="line">sdktrace <span class="string">&quot;go.opentelemetry.io/otel/sdk/trace&quot;</span></span><br><span class="line">semconv <span class="string">&quot;go.opentelemetry.io/otel/semconv/v1.4.0&quot;</span></span><br><span class="line"><span class="string">&quot;go.opentelemetry.io/otel/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rng = rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// SpanNameVariety SpanName 发散程度（多少个不同值）</span></span><br><span class="line"><span class="keyword">const</span> SpanNameVariety = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AttrValueVariety 属性值发散程度（多少个不同值）</span></span><br><span class="line"><span class="keyword">const</span> AttrValueVariety = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AttrMaxLen AttrMinLen tag value 长度范围</span></span><br><span class="line"><span class="keyword">const</span> AttrMaxLen = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> AttrMinLen = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SpanNameMaxLen SpanNameMinLen span name 长度范围</span></span><br><span class="line"><span class="keyword">const</span> SpanNameMaxLen = <span class="number">64</span></span><br><span class="line"><span class="keyword">const</span> SpanNameMinLen = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ServerServiceName = <span class="string">&quot;otlp-server&quot;</span></span><br><span class="line"><span class="keyword">const</span> TraceInstrumentationName = <span class="string">&quot;otlp-demo-tracer&quot;</span></span><br><span class="line"><span class="keyword">const</span> otelAgentAddr = <span class="string">&quot;tracing-analysis-dc-hz.aliyuncs.com:8090&quot;</span></span><br><span class="line"><span class="keyword">const</span> xtraceToken = <span class="string">&quot;&lt;你的阿里云 grpc token&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> avaAttrValue = [AttrValueVariety]<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> avaSpanName = [SpanNameVariety]<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initProvider 初始化 opentelemetry 配置。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initializes an OTLP exporter, and configures the corresponding trace and</span></span><br><span class="line"><span class="comment">// metric providers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initProvider</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 gRPC 连接阿里云</span></span><br><span class="line"></span><br><span class="line">headers := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Authentication&quot;</span>: xtraceToken&#125;</span><br><span class="line">traceClient := otlptracegrpc.NewClient(</span><br><span class="line">otlptracegrpc.WithInsecure(),</span><br><span class="line">otlptracegrpc.WithEndpoint(otelAgentAddr),</span><br><span class="line">otlptracegrpc.WithHeaders(headers), <span class="comment">// 鉴权信息</span></span><br><span class="line">otlptracegrpc.WithDialOption(grpc.WithBlock()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 http 连接阿里云</span></span><br><span class="line"><span class="comment">//traceClientHttp := otlptracehttp.NewClient(</span></span><br><span class="line"><span class="comment">//otlptracehttp.WithEndpoint(&quot;tracing-analysis-dc-hz.aliyuncs.com&quot;),</span></span><br><span class="line"><span class="comment">//otlptracehttp.WithURLPath(&quot;&lt;你的阿里云 HTTP 接入点&gt;&quot;),</span></span><br><span class="line"><span class="comment">//otlptracehttp.WithInsecure())</span></span><br><span class="line"><span class="comment">//otlptracehttp.WithCompression(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建和阿里云链路服务的连接</span></span><br><span class="line">log.Println(<span class="string">&quot;start to connect to server&quot;</span>)</span><br><span class="line">traceExp, err := otlptrace.New(ctx, traceClient)</span><br><span class="line">handleErr(err, <span class="string">&quot;Failed to create the collector trace exporter&quot;</span>)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;trace new finish&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 opentelemetry 基本信息</span></span><br><span class="line">res, err := resource.New(ctx,</span><br><span class="line">resource.WithFromEnv(),</span><br><span class="line">resource.WithProcess(),</span><br><span class="line">resource.WithTelemetrySDK(),</span><br><span class="line">resource.WithHost(),</span><br><span class="line">resource.WithAttributes(</span><br><span class="line"><span class="comment">// the service name used to display traces in backends</span></span><br><span class="line"><span class="comment">// 这是在阿里云会显示的服务名</span></span><br><span class="line">semconv.ServiceNameKey.String(ServerServiceName),</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line">handleErr(err, <span class="string">&quot;failed to create resource&quot;</span>)</span><br><span class="line">log.Println(<span class="string">&quot;resource new finish&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置追踪数据和数据出口（阿里云）之间的联系</span></span><br><span class="line">bsp := sdktrace.NewBatchSpanProcessor(traceExp) <span class="comment">// 将数据出口绑定到 SpanProcessor</span></span><br><span class="line">tracerProvider := sdktrace.NewTracerProvider(</span><br><span class="line">sdktrace.WithSampler(sdktrace.AlwaysSample()),</span><br><span class="line">sdktrace.WithResource(res),</span><br><span class="line">sdktrace.WithSpanProcessor(bsp), <span class="comment">// 将 SpanProcessor 绑定到 TracerProvider</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set global propagator to traceContext (the default is no-op).</span></span><br><span class="line"><span class="comment">// 配置 opentelemetry 全局变量</span></span><br><span class="line">otel.SetTextMapPropagator(propagation.TraceContext&#123;&#125;)</span><br><span class="line">otel.SetTracerProvider(tracerProvider) <span class="comment">// 设定全局 TracerProvider</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cxt, cancel := context.WithTimeout(ctx, time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">if</span> err := traceExp.Shutdown(cxt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">otel.Handle(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handleErr 输出错误信息，希望错误体现在阿里云链路追踪上，见 https://opentelemetry.io/docs/instrumentation/go/getting-started/#bonus-errors</span></span><br><span class="line"><span class="comment">// 一般用以下两个方法标记错误</span></span><br><span class="line"><span class="comment">// span.RecordError(err)</span></span><br><span class="line"><span class="comment">// span.SetStatus(codes.Error, err.Error())</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErr</span><span class="params">(err <span class="type">error</span>, message <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;%s: %v&quot;</span>, message, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initTraceDemoData 初始化测试用的随机数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTraceDemoData</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(avaAttrValue); i++ &#123;</span><br><span class="line"><span class="comment">//avaAttrValue[i] = common.GenStrWithRandomLen(AttrMinLen, AttrMaxLen)</span></span><br><span class="line">avaAttrValue[i] = <span class="string">&quot;AttrValue &quot;</span> + strconv.Itoa(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(avaSpanName); i++ &#123;</span><br><span class="line"><span class="comment">// avaSpanName[i] = common.GenStrWithRandomLen(SpanNameMinLen, SpanNameMaxLen)</span></span><br><span class="line">avaSpanName[i] = <span class="string">&quot;SpanName &quot;</span> + strconv.Itoa(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 opentelemetry 和链路追踪后端（阿里云）进行连接</span></span><br><span class="line">shutdown := initProvider()</span><br><span class="line"><span class="keyword">defer</span> shutdown()</span><br><span class="line"></span><br><span class="line"><span class="comment">//meter := global.Meter(&quot;demo-server-meter&quot;)</span></span><br><span class="line">serverAttribute := attribute.String(<span class="string">&quot;server-attribute&quot;</span>, <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;start to gen chars for trace data&quot;</span>)</span><br><span class="line"><span class="comment">// 随机生成用于测试的数据</span></span><br><span class="line">initTraceDemoData()</span><br><span class="line">fmt.Println(<span class="string">&quot;gen trace data done&quot;</span>)</span><br><span class="line"><span class="comment">// 声明链路追踪的名字</span></span><br><span class="line">tracer := otel.Tracer(TraceInstrumentationName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a handler wrapped in OpenTelemetry instrumentation</span></span><br><span class="line"><span class="comment">// 建立一个 http 请求的处理函数</span></span><br><span class="line"><span class="comment">// 在这个处理函数中，先休眠随机的时间</span></span><br><span class="line">handler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">//  random sleep to simulate latency</span></span><br><span class="line"><span class="keyword">var</span> sleep <span class="type">int64</span></span><br><span class="line"><span class="keyword">switch</span> modulus := time.Now().Unix() % <span class="number">5</span>; modulus &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">sleep = rng.Int63n(<span class="number">2000</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">sleep = rng.Int63n(<span class="number">15</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">sleep = rng.Int63n(<span class="number">917</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">sleep = rng.Int63n(<span class="number">87</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">sleep = rng.Int63n(<span class="number">1173</span>)</span><br><span class="line">&#125;</span><br><span class="line">ctx := req.Context()</span><br><span class="line">span := trace.SpanFromContext(ctx)  <span class="comment">// 获得自己在当前链路中的节点信息</span></span><br><span class="line">span.SetAttributes(serverAttribute) <span class="comment">// 设置自己的节点属性</span></span><br><span class="line"></span><br><span class="line">actionChild(tracer, ctx, sleep) <span class="comment">// 生成自己的子 span</span></span><br><span class="line">connectFlask(tracer, ctx)       <span class="comment">// 向 Python Flask 客户端发送请求</span></span><br><span class="line">connectPhp(tracer, ctx)         <span class="comment">// 向 PHP 客户端发送请求</span></span><br><span class="line">connectSpring(tracer, ctx)      <span class="comment">// 向 Java Spring 客户端发送请求</span></span><br><span class="line"></span><br><span class="line">_, err := w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">wrappedHandler := otelhttp.NewHandler(handler, <span class="string">&quot;/hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// serve up the wrapped handler</span></span><br><span class="line">http.Handle(<span class="string">&quot;/hello&quot;</span>, wrappedHandler)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:7080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// actionChild 生成一个链路事件，即一个子 span</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">actionChild</span><span class="params">(tracer trace.Tracer, ctx context.Context, sleep <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">_, subSpan := tracer.Start(ctx, <span class="string">&quot;back-end subSpan&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> subSpan.End()</span><br><span class="line">time.Sleep(time.Duration(sleep) * time.Millisecond)</span><br><span class="line"><span class="comment">// 此处用于测试 span 错误</span></span><br><span class="line">errTest := fmt.Errorf(<span class="string">&quot;测试：span 发生错误&quot;</span>)</span><br><span class="line"><span class="comment">// fmt.Println(&quot;测试：span 发生错误&quot;)</span></span><br><span class="line">subSpan.RecordError(errTest)</span><br><span class="line">subSpan.SetStatus(codes.Error, errTest.Error())</span><br><span class="line"><span class="comment">// subSpan.SetStatus(codes.Ok, &quot;success&quot;)</span></span><br><span class="line">serverAttribute := attribute.String(<span class="string">&quot;attr1&quot;</span>, <span class="string">&quot;attr for test&quot;</span>)</span><br><span class="line">subSpan.SetAttributes(serverAttribute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectSpring</span><span class="params">(tracer trace.Tracer, ctx context.Context)</span></span> &#123;</span><br><span class="line">_, subSpan := tracer.Start(ctx, <span class="string">&quot;backend-connect-spring&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> subSpan.End()</span><br><span class="line"></span><br><span class="line">client := http.Client&#123;</span><br><span class="line">Transport: otelhttp.NewTransport(http.DefaultTransport),</span><br><span class="line">&#125;</span><br><span class="line">req, err := http.NewRequestWithContext(ctx, <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:5638/test&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">handleErr(err, <span class="string">&quot;failed to http request&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err := res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subSpan.SetStatus(codes.Ok, <span class="string">&quot;success&quot;</span>)</span><br><span class="line">serverAttribute := attribute.String(<span class="string">&quot;attr_test&quot;</span>, <span class="string">&quot;Go_to_Java&quot;</span>)</span><br><span class="line">subSpan.SetAttributes(serverAttribute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectPhp</span><span class="params">(tracer trace.Tracer, ctx context.Context)</span></span> &#123;</span><br><span class="line">_, subSpan := tracer.Start(ctx, <span class="string">&quot;backend-connect-php&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> subSpan.End()</span><br><span class="line"></span><br><span class="line">client := http.Client&#123;</span><br><span class="line">Transport: otelhttp.NewTransport(http.DefaultTransport),</span><br><span class="line">&#125;</span><br><span class="line">req, err := http.NewRequestWithContext(ctx, <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8083/&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">handleErr(err, <span class="string">&quot;failed to http request&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err := res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subSpan.SetStatus(codes.Ok, <span class="string">&quot;success&quot;</span>)</span><br><span class="line">serverAttribute := attribute.String(<span class="string">&quot;attr_test&quot;</span>, <span class="string">&quot;Go_to_Php&quot;</span>)</span><br><span class="line">subSpan.SetAttributes(serverAttribute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectFlask</span><span class="params">(tracer trace.Tracer, ctx context.Context)</span></span> &#123;</span><br><span class="line">_, subSpan := tracer.Start(ctx, <span class="string">&quot;backend-connect-flask&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> subSpan.End()</span><br><span class="line"></span><br><span class="line">client := http.Client&#123;</span><br><span class="line">Transport: otelhttp.NewTransport(http.DefaultTransport),</span><br><span class="line">&#125;</span><br><span class="line">req, err := http.NewRequestWithContext(ctx, <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:5000/test&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">handleErr(err, <span class="string">&quot;failed to http request&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err := res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subSpan.SetStatus(codes.Ok, <span class="string">&quot;success&quot;</span>)</span><br><span class="line">serverAttribute := attribute.String(<span class="string">&quot;attr_test&quot;</span>, <span class="string">&quot;Go_to_Python&quot;</span>)</span><br><span class="line">subSpan.SetAttributes(serverAttribute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flask-节点"><a href="#Flask-节点" class="headerlink" title="Flask 节点"></a>Flask 节点</h3><p>采用 Python Flask Web 框架编写的节点。该节点监听 5000 端口，并同样请求 Spring 节点的 5638 端口。由于采用了无侵入的插桩方式，其代码与原业务代码几乎没有任何区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(<span class="string">&#x27;http://localhost:5638/test&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(r.text)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello World, this is Python Flask server ! The information &#123;0&#125; is from Java Spring server.&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            r.text)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.InvalidSchema <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello World, this is Python Flask server !&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据<a href="https://opentelemetry.io/docs/instrumentation/python/automatic/">官方文档</a>，通过 pip 下载 OpenTelemetry 的 Python 代理。然后，按照如下指令运行（ Windows PowerShell 环境） Flask 项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">h_name = hostname</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面一条指令用于告诉阿里云该 Python 程序运行的设备主机名/IP</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这条指令需要单独运行</span></span><br><span class="line"></span><br><span class="line">opentelemetry-instrument `</span><br><span class="line">--traces_exporter otlp_proto_grpc  `</span><br><span class="line">--metrics_exporter none `</span><br><span class="line">--resource_attributes host.name=$h_name `</span><br><span class="line">--service_name otlp-flask `</span><br><span class="line">--exporter_otlp_endpoint http://tracing-analysis-dc-hz.aliyuncs.com:8090 `</span><br><span class="line">--exporter_otlp_headers &quot;&lt;你的阿里云 grpc token&gt;&quot; `</span><br><span class="line">--exporter_otlp_insecure true `</span><br><span class="line">python app_pure.py</span><br></pre></td></tr></table></figure><h3 id="Spring-节点"><a href="#Spring-节点" class="headerlink" title="Spring 节点"></a>Spring 节点</h3><p>采用 Java Spring Boot 框架编写的节点。该节点监听 5638 端口。由于采用了无侵入的插桩方式，其代码就是一个完整的 Spring 项目，<strong>无需添加任何额外的 Maven 依赖</strong>。</p><p>其基本依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web-services<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Controller 编写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jzyx.otlp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtlpController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Java Spring Return OK!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>application.properties 如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Java-Spring-Server</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">5638</span></span><br></pre></td></tr></table></figure><p>然后，通过 Maven 将其构建为一个 jar 包 <code>otlp-0.0.1-SNAPSHOT.jar</code> ，再从<a href="https://opentelemetry.io/docs/instrumentation/java/automatic/">官方文档</a>下载 OpenTelemetry 的 Java 代理 <code>opentelemetry-javaagent.jar</code> 。二者放在同一目录后（建议在 Linux 环境中，Windows 环境我测试后容易出问题），执行以下命令运行项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">     -Dotel.service.name=otlp-spring \</span><br><span class="line">     -Dotel.traces.exporter=otlp \</span><br><span class="line">     -Dotel.metrics.exporter=none \</span><br><span class="line">     -Dotel.exporter.otlp.headers=Authentication=&lt;你的阿里云 grpc token&gt; \</span><br><span class="line">     -Dotel.exporter.otlp.endpoint=http://tracing-analysis-dc-hz.aliyuncs.com:8090 \</span><br><span class="line">     -jar otlp-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h3 id="PHP-节点"><a href="#PHP-节点" class="headerlink" title="PHP 节点"></a>PHP 节点</h3><p>在<a href="https://opentelemetry.io/docs/instrumentation/php/automatic/">官方文档</a>中，PHP 语言是支持自动插桩的。然而，在本文使用（2023.1）时，PHP 的自动插桩插件实际上版本只迭代到第三版，存在诸多不足，甚至在可用性方面都存在问题。<a href="https://opentelemetry.io/docs/instrumentation/php/automatic/">官方文档</a>或 <a href="https://github.com/open-telemetry/opentelemetry-php-instrumentation">Github 仓库</a>中的示例代码也很让人困惑，以我入门级别的 PHP 水平，并不能依据这些例子编写出没有侵入性的插桩代码——这已经稍微可以说明这个自动插桩功能对非开发的运维人员来说是较为失败的了。</p><p>在安装 PHP 的 OpenTelemetry 自动插桩插件后，我只能把 PHP 源代码修改为类似手动插桩的样子才能令 PHP 的遥测信息能够被阿里云监测。即便如此，还是存在着阿里云无法在整条链路中监测出 PHP 节点的情况，导致 PHP 节点在链路拓扑中呈现被<a href="#%E7%9B%AE%E7%9A%84">“孤立”的情况</a>。</p><p>如果有相关经验的朋友可以告知我要如何解决上述这些问题。接下来我讲继续介绍这个并不完美的“自动”插桩 PHP 节点的具体实践。</p><blockquote><p>以下操作都在 Linux 环境（WSL）中执行</p></blockquote><p>由于插件需要 PHP 8.0+ 环境，且安装过程较为繁琐。因此使用 PHP 官方镜像安装自动插桩插件并生成 PHP 容器，Dockerfile 如下：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> php:<span class="number">8.2</span>.<span class="number">1</span>-fpm</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -sSLf \</span></span><br><span class="line"><span class="language-bash">        -o /usr/local/bin/install-php-extensions \</span></span><br><span class="line"><span class="language-bash">        https://github.com/mlocati/docker-php-extension-installer/releases/latest/download/install-php-extensions &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> +x /usr/local/bin/install-php-extensions &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    install-php-extensions open-telemetry/opentelemetry-php-instrumentation@main</span></span><br></pre></td></tr></table></figure><p>在该 Dockerfile 目录下，直接运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t php-otel .</span><br></pre></td></tr></table></figure><p>这样就生成了带有 OpenTelemetry 自动插桩插件的 php 8.2.1-fpm 镜像。</p><p>在进行下一步之前，先在本地创建卷映射目录，以我创建的为例：</p><ul><li><code>/home/lgh/php/nginx/www/</code>: 存放一个 <code>index.php</code> 文件，还可以在该目录本地直接运行 <code>pickle</code> 、 <code>composer</code> 等工具来配置 php 插件或包，无需进入容器再安装</li><li><code>/home/lgh/php/nginx/conf/conf.d/</code>: 存放一个 <code>otel-test-php.conf</code> 文件，即 nginx 配置文件，内容如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  localhost;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">  root   /usr/share/nginx/html;</span><br><span class="line">  index  index.html index.htm index.php;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">  root   /usr/share/nginx/html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ~ \.php$ &#123;</span><br><span class="line">  fastcgi_pass   php:9000;</span><br><span class="line">  fastcgi_index  index.php;</span><br><span class="line">  fastcgi_param  SCRIPT_FILENAME  /var/www/html/$fastcgi_script_name;</span><br><span class="line">  include        fastcgi_params;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>fastcgi 是针对 fpm 镜像使用的</p></blockquote><p>然后，需要使用以下指令生成一个配置好的 php 容器 <code>otel_php</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name=otel_php \</span><br><span class="line">-v /home/lgh/php/nginx/www:/var/www/html \</span><br><span class="line">-e OTEL_PHP_AUTOLOAD_ENABLED=<span class="literal">true</span> \</span><br><span class="line">-e OTEL_SERVICE_NAME=otlp-php \</span><br><span class="line">-e OTEL_TRACES_EXPORTER=otlp \</span><br><span class="line">-e OTEL_EXPORTER_OTLP_PROTOCOL=grpc \</span><br><span class="line">-e OTEL_METRICS_EXPORTER=none \</span><br><span class="line">-e OTEL_LOGS_EXPORTER=none \</span><br><span class="line">-e OTEL_EXPORTER_OTLP_ENDPOINT=<span class="string">&quot;http://tracing-analysis-dc-hz.aliyuncs.com:8090&quot;</span> \</span><br><span class="line">-e OTEL_EXPORTER_OTLP_INSECURE=<span class="literal">true</span> \</span><br><span class="line">-e OTEL_EXPORTER_OTLP_HEADERS=<span class="string">&quot;&lt;你的阿里云 grpc token&gt;&quot;</span> \</span><br><span class="line">php-otel</span><br></pre></td></tr></table></figure><blockquote><p>可以用 <code>/bin/sh</code> 进入该容器输入 <code>php -m | grep  otel_instrumentation</code> 验证插件是否安装完毕</p></blockquote><p>然后，我们需要通过 nginx 来使得 php 能被解析，特别是对 fpm 的 php 镜像。因此还需要一个额外的 nginx 容器 <code>otel-php-nginx</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name otel-php-nginx -p 8083:80 -d \</span><br><span class="line">-v /home/lgh/php/nginx/www:/usr/share/nginx/html:ro \</span><br><span class="line">-v /home/lgh/php/nginx/conf/conf.d:/etc/nginx/conf.d:ro \</span><br><span class="line">--<span class="built_in">link</span> otel_php:php \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>接下来，在 <code>/home/lgh/php/nginx/www/index.php</code> 中输入 php 代码，在浏览器的 <code>http://localhost:8083/</code> 就能看出结果。但我尝试很多次，确认插件正常安装，官方的自动插桩代码仍然无法运行，因此我不得不使用 <code>composer</code> 在该目录下<a href="https://opentelemetry.io/docs/instrumentation/php/getting-started/">安装手动插桩</a>的依赖，最后获得的 php 代码是这样的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">Contrib</span>\<span class="title">Otlp</span>\<span class="title">OtlpHttpTransportFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">Contrib</span>\<span class="title">Otlp</span>\<span class="title">SpanExporter</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">SDK</span>\<span class="title">Common</span>\<span class="title">Attribute</span>\<span class="title">Attributes</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">SDK</span>\<span class="title">Common</span>\<span class="title">Time</span>\<span class="title">ClockFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">SDK</span>\<span class="title">Trace</span>\<span class="title">SpanProcessor</span>\<span class="title">BatchSpanProcessor</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">SDK</span>\<span class="title">Trace</span>\<span class="title">TracerProvider</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">SDK</span>\<span class="title">Resource</span>\<span class="title">ResourceInfo</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">SDK</span>\<span class="title">Resource</span>\<span class="title">ResourceInfoFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">SDK</span>\<span class="title">Trace</span>\<span class="title">Span</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">API</span>\<span class="title">Trace</span>\<span class="title">StatusCode</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OpenTelemetry</span>\<span class="title">Context</span>\<span class="title">Context</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$transport</span> = (<span class="keyword">new</span> <span class="title class_">OtlpHttpTransportFactory</span>())-&gt;<span class="title function_ invoke__">create</span>(<span class="string">&#x27;&lt;你的阿里云 HTTP 接入点&gt;&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line"><span class="variable">$exporter</span> = <span class="keyword">new</span> <span class="title class_">SpanExporter</span>(<span class="variable">$transport</span>);</span><br><span class="line"><span class="variable">$resource</span> = <span class="title class_">ResourceInfoFactory</span>::<span class="title function_ invoke__">merge</span>(<span class="title class_">ResourceInfo</span>::<span class="title function_ invoke__">create</span>(<span class="title class_">Attributes</span>::<span class="title function_ invoke__">create</span>([<span class="string">&#x27;service.name&#x27;</span> =&gt; <span class="string">&#x27;otlp-php&#x27;</span>, <span class="string">&#x27;host.name&#x27;</span> =&gt; <span class="title function_ invoke__">gethostname</span>()])), <span class="title class_">ResourceInfoFactory</span>::<span class="title function_ invoke__">defaultResource</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Starting OTLP+json example&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$tracerProvider</span> = <span class="keyword">new</span> <span class="title class_">TracerProvider</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BatchSpanProcessor</span>(</span><br><span class="line">        <span class="variable">$exporter</span>,</span><br><span class="line">        <span class="title class_">ClockFactory</span>::<span class="title function_ invoke__">getDefault</span>()</span><br><span class="line">    ),</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="variable">$resource</span>,</span><br><span class="line">);</span><br><span class="line"><span class="variable">$tracer</span> = <span class="variable">$tracerProvider</span>-&gt;<span class="title function_ invoke__">getTracer</span>(<span class="string">&#x27;otlp-demo-tracer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">OpenTelemetry\Instrumentation\<span class="title function_ invoke__">hook</span>(</span><br><span class="line">    <span class="title class_">DemoClass</span>::<span class="variable language_">class</span>,</span><br><span class="line">    <span class="string">&#x27;run&#x27;</span>,</span><br><span class="line">    <span class="built_in">static</span> function (DemoClass <span class="variable">$demo</span>, <span class="keyword">array</span> <span class="variable">$params</span>, <span class="keyword">string</span> <span class="variable">$class</span>, <span class="keyword">string</span> <span class="variable">$function</span>, ?<span class="keyword">string</span> <span class="variable">$filename</span>, ?<span class="keyword">int</span> <span class="variable">$lineno</span>) <span class="keyword">use</span> ($<span class="title">tracer</span>) &#123;</span><br><span class="line">        $<span class="title">tracer</span>-&gt;<span class="title">spanBuilder</span>($<span class="title">class</span>)</span><br><span class="line">            -&gt;<span class="title">startSpan</span>()</span><br><span class="line">            -&gt;<span class="title">activate</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> (<span class="params">DemoClass <span class="variable">$demo</span>, <span class="keyword">array</span> <span class="variable">$params</span>, <span class="variable">$returnValue</span>, ?<span class="built_in">Throwable</span> <span class="variable">$exception</span></span>) <span class="keyword">use</span> (<span class="params"><span class="variable">$tracer</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$scope</span> = <span class="title class_">Context</span>::<span class="title function_ invoke__">storage</span>()-&gt;<span class="title function_ invoke__">scope</span>();</span><br><span class="line">        <span class="variable">$scope</span>?-&gt;<span class="title function_ invoke__">detach</span>();</span><br><span class="line">        <span class="variable">$span</span> = <span class="title class_">Span</span>::<span class="title function_ invoke__">fromContext</span>(<span class="variable">$scope</span>-&gt;<span class="title function_ invoke__">context</span>());</span><br><span class="line">        <span class="variable">$exception</span> &amp;&amp; <span class="variable">$span</span>-&gt;<span class="title function_ invoke__">recordException</span>(<span class="variable">$exception</span>);</span><br><span class="line">        <span class="variable">$span</span>-&gt;<span class="title function_ invoke__">setStatus</span>(<span class="variable">$exception</span> ? <span class="title class_">StatusCode</span>::<span class="variable constant_">STATUS_ERROR</span> : <span class="title class_">StatusCode</span>::<span class="variable constant_">STATUS_OK</span>);</span><br><span class="line">        <span class="variable">$span</span>-&gt;<span class="title function_ invoke__">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;running&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $root = $span = $tracer-&gt;spanBuilder(&#x27;root&#x27;)-&gt;startSpan();</span></span><br><span class="line"><span class="comment">// // do some work here</span></span><br><span class="line"><span class="comment">// $root-&gt;end();</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$demo_fun</span> = <span class="keyword">new</span> <span class="title class_">DemoClass</span>();</span><br><span class="line"><span class="variable">$demo_fun</span>-&gt;<span class="title function_ invoke__">run</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> PHP_EOL . <span class="string">&#x27;OTLP+json example complete!  &#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>);</span><br><span class="line"><span class="variable">$tracerProvider</span>-&gt;<span class="title function_ invoke__">shutdown</span>();</span><br></pre></td></tr></table></figure><p>看起来实际上最后还是回到手动插桩了……而且效果还不好</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>可以看出，在本次使用的各种语言中，OpenTelemetry 对 Python 和 Java 的支持最好；Go 的支持也不差，但改进空间也很大；PHP 的支持最不好，这可能和其社区较小有关。</p><p>然而，本次实践没有评估接入链路追踪对应用链路的性能影响，可能需要进一步更贴近生产规模的实验才能进一步说明。</p><p>同时，本次实践没有使用 OpenTelemetry 官方推荐的 OpenTelemetry Collector 方式，即独立部署一个 OpenTelemetry Collector 节点采集各个待观测节点的遥测信息，然后再上报给观测者后端（阿里云）。<a href="https://opentelemetry.io/docs/collector/">官方推荐</a>在任何生产情况下采用这种方式，这也是未来我可能对 OpenTelemetry 进一步调研的方向。</p><p>OpenTelemetry 可以说是链路追踪的未来，但它不能代表链路追踪的当下。如果急切需要稳定高可用的链路追踪方案，选择 Jaeger 与 Zipkin 等开源方案也未尝不可。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><a href="https://github.com/rfyiamcool/notes/blob/main/ntp_cause_message_latency.md">节点时间不同步造成的 trace 高时延假象</a>，一文中提到的现象同时也存在于本次实践中，在部署链路追踪或诊断链路时需要注意这方面的配置问题。</li><li>实际上，阿里云提供了有关<a href="https://help.aliyun.com/product/90275.html">链路追踪相关的文档</a>，但其内容相对较老，与 OpenTelemetry 官方文档相比，后者的参考价值更大一些。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Traces </tag>
            
            <tag> Distributed System </tag>
            
            <tag> DevOps </tag>
            
            <tag> OpenTelemetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个函数实现 Python 超大文件的流式下载与断点续传</title>
      <link href="/2023/01/3c91fb98.html"/>
      <url>/2023/01/3c91fb98.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个函数实现-Python-超大文件的流式下载与断点续传"><a href="#一个函数实现-Python-超大文件的流式下载与断点续传" class="headerlink" title="一个函数实现 Python 超大文件的流式下载与断点续传"></a>一个函数实现 Python 超大文件的流式下载与断点续传</h1><p>在做项目的时候有了超大文件连续高速下载这个需求，然后上网查了不少资料。最后总结并在项目中不断迭代，实现了这个函数。</p><p>函数接口非常简单，性能却出人意料的好，因此这个函数无论是用在项目里，还是平时写写脚本下点大东西都非常好用。</p><p>这个函数主要的亮点是在于信号量 <code>signal</code> 的使用。<code>requests</code> 库的 <code>timeout</code> 参数实际上是<a href="https://requests.readthedocs.io/en/latest/user/advanced/#timeouts">针对请求阶段的超时进行处理</a>，<strong>不能通过设置 <code>timeout</code> 限制整个请求下载过程的时间</strong> 。而我们在下载大文件时，往往有这样的需求：当一个大文件下载时间过长（例如超过 10 分钟），我们更倾向于放弃此次下载，转而重新开始一次新的下载。因此，我们需要一个能够限制整个下载过程的时间的方法。</p><p>为此，我采用了 Python 的 <code>signal</code> 模块，通过设置信号量 <code>signal.alarm()</code> 来限制整个下载过程的时间。当下载时间超过设定值时，会抛出 <code>TimeoutException</code> 异常，从而中断下载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_timeout</span>(<span class="params">signum, frame</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Raise an TimeoutException.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is intended for use as a signal handler.</span></span><br><span class="line"><span class="string">    The signum and frame arguments passed to this are ignored.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># # Raise TimeoutException with system default timeout message</span></span><br><span class="line">    <span class="comment"># raise TimeoutException()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以像上面一样抛出异常，也可以在此自定义放弃下载后的行为</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getUrlContent</span>(<span class="params">url, file_path, max_try=<span class="number">10</span>, download_max_time_sec=<span class="number">600</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    下载文件，支持断点续传和流式下载</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        url - 下载地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        file_path - 文件存储路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        max_try - 最大重试次数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        download_max_time_sec - 下载最大时间，超过此时间则放弃下载</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int - 1为正常退出，0为超过最大重试次数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 重试计数</span></span><br><span class="line">    repeat_time = <span class="number">0</span></span><br><span class="line">    frist_repeat_time = <span class="number">6</span></span><br><span class="line">    <span class="comment"># 第一次请求是为了得到文件总大小</span></span><br><span class="line">    total_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> frist_repeat_time &gt; <span class="number">0</span> <span class="keyword">and</span> total_size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> requests.get(url, stream=<span class="literal">True</span>) <span class="keyword">as</span> r1:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> r1:</span><br><span class="line">                    logger.error(<span class="string">f&#x27;Get file length error: <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                total_size = <span class="built_in">int</span>(r1.headers[<span class="string">&#x27;Content-Length&#x27;</span>])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> total_size == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;File length is 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&#x27;Request file length error: <span class="subst">&#123;e&#125;</span>, retrying remaining <span class="subst">&#123;frist_repeat_time&#125;</span> times&#x27;</span>)</span><br><span class="line">            frist_repeat_time -= <span class="number">1</span></span><br><span class="line">            gevent.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&#x27;开始下载文件 <span class="subst">&#123;url&#125;</span> ,文件大小: <span class="subst">&#123;total_size&#125;</span> bytes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    temp_size = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 如果文件已经存在，我此处的策略是删除后重新下载</span></span><br><span class="line">    <span class="comment"># 可以根据实际需求进行修改</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">        subprocess.Popen([<span class="string">&#x27;rm&#x27;</span>, <span class="string">&#x27;-rf&#x27;</span>, file_path])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过信号量控制整个下载的用时（而非请求超时）</span></span><br><span class="line">    signal.signal(signal.SIGALRM, _timeout)</span><br><span class="line">    signal.alarm(download_max_time_sec)   <span class="comment"># 限制最多下载 download_max_time_sec 秒</span></span><br><span class="line">    <span class="comment"># 开始下载</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> repeat_time &lt; max_try:</span><br><span class="line">            <span class="keyword">if</span> repeat_time &gt; <span class="number">0</span>:</span><br><span class="line">                temp_size = os.path.getsize(file_path) <span class="keyword">if</span> os.path.exists(file_path) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 文件大小一致，跳出循环s</span></span><br><span class="line">            <span class="keyword">if</span> temp_size &gt;= total_size:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            repeat_time += <span class="number">1</span></span><br><span class="line">            logger.info(<span class="string">&quot;第[%d]次下载文件 %s ,已经下载数据大小 (bytes): [%d],应下载数据大小 (bytes): [%d]&quot;</span> %</span><br><span class="line">                        (repeat_time, url, temp_size, total_size))</span><br><span class="line">            <span class="comment"># 重新请求网址，加入新的请求头的</span></span><br><span class="line">            <span class="comment"># 核心部分，这个是请求下载时，从本地文件已经下载过的后面下载</span></span><br><span class="line">            headers = &#123;<span class="string">&quot;Range&quot;</span>: <span class="string">f&quot;bytes=<span class="subst">&#123;temp_size&#125;</span>-<span class="subst">&#123;total_size&#125;</span>&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> requests.get(url, stream=<span class="literal">True</span>, headers=headers, timeout=(<span class="number">12</span>, <span class="number">60</span>)) <span class="keyword">as</span> r:</span><br><span class="line">                    <span class="comment"># &quot;ab&quot;表示追加形式写入文件</span></span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;ab&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        <span class="keyword">if</span> repeat_time != <span class="number">1</span>:</span><br><span class="line">                            f.seek(temp_size)</span><br><span class="line">                        <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">1024</span> * <span class="number">64</span>):</span><br><span class="line">                            <span class="keyword">if</span> chunk:</span><br><span class="line">                                temp_size += <span class="built_in">len</span>(chunk)</span><br><span class="line">                                f.write(chunk)</span><br><span class="line">                                f.flush()</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.Timeout <span class="keyword">as</span> e:</span><br><span class="line">                logger.warn(<span class="string">&#x27;Timeout&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ChunkedEncodingError <span class="keyword">as</span> e:</span><br><span class="line">                logger.warn(<span class="string">&#x27;Chunked_encoding_error&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">                logger.warn(<span class="string">&#x27;Connection_error&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logger.error(<span class="string">&quot;流式传输失败，未知错误：%s&quot;</span> % e)</span><br><span class="line">    <span class="keyword">except</span> TimeoutException <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;下载时间超过设定值 <span class="subst">&#123;download_max_time_sec&#125;</span> 秒，下载失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;下载失败，未知错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 取消信号量</span></span><br><span class="line">        signal.alarm(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过 Docker 部署 n2n</title>
      <link href="/2023/01/6d2cdefd.html"/>
      <url>/2023/01/6d2cdefd.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何通过-docker-部署-n2n"><a href="#如何通过-docker-部署-n2n" class="headerlink" title="如何通过 docker 部署 n2n"></a>如何通过 docker 部署 n2n</h1><p>在以往，部署 n2n 往往需要通过 make 进行源码编译，或是通过包管理器下载安装。安装过程繁琐且难以迁移，配置也容易造成混乱</p><p>我在 docker hub 上找到了一个制作水平很高的 <a href="https://hub.docker.com/r/yingftf/n2n">n2n v2.9 docker</a>，仅仅只有 7 MB 且运行良好。下面介绍如何通过这个镜像实现 n2n 的 docker 部署。</p><h2 id="镜像获取与测试"><a href="#镜像获取与测试" class="headerlink" title="镜像获取与测试"></a>镜像获取与测试</h2><p>首先需要下载镜像，通过以下代码将镜像从 docker hub 下载到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push yingftf/n2n</span><br></pre></td></tr></table></figure><p>运行以下指令就能在不运行容器的情况下测试镜像是否可用及其 n2n 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --network host yingftf/n2n supernode -h</span><br><span class="line"></span><br><span class="line">docker run --<span class="built_in">rm</span> --cap-add=NET_ADMIN --cap-add=NET_RAW --device=/dev/net/tun --network host yingftf/n2n edge -h</span><br></pre></td></tr></table></figure><h2 id="n2n-的容器化部署"><a href="#n2n-的容器化部署" class="headerlink" title="n2n 的容器化部署"></a>n2n 的容器化部署</h2><p>在 docker hub 页面上，作者介绍了通过映射卷操作配置文件部署的方法。但经过我的测试这个方法很不稳定，容器很可能无法启动。因此这里只介绍通过 docker 指令部署 n2n 的方法。</p><p>各位也可以参考 <a href="https://github.com/ntop/n2n/">n2n 官方仓库文档</a>。</p><h3 id="配置-supernode"><a href="#配置-supernode" class="headerlink" title="配置 supernode"></a>配置 supernode</h3><p>直接输入以下指令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always --network host  --name supernode yingftf/n2n supernode -p 8990 -f -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上 docker 指令等价于以下指令</span></span><br><span class="line"></span><br><span class="line">supernode -l 8990 -f -v</span><br></pre></td></tr></table></figure><p>检查 <code>docker ps</code>，发现名为 <code>supernode</code> 的容器处于运行状态则说明部署完成</p><h3 id="配置-edge"><a href="#配置-edge" class="headerlink" title="配置 edge"></a>配置 edge</h3><blockquote><p>即使是部署了 supernode 的主机，也必须部署一个 edge 。也就是说，这个主机会同时运行两个容器</p></blockquote><p>在每一个将要部署 edge 的主机上输入以下指令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always --cap-add=NET_ADMIN --cap-add=NET_RAW --device=/dev/net/tun --network host  --name edge0 yingftf/n2n edge -a 10.10.2.1 -c mynetwork -k nic1234 -l &#123;supernode 的公网 IP&#125;:8990 -r -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上 docker 指令等价于以下指令，</span></span><br><span class="line"><span class="comment"># 其中 `10.10.2.1` 是你可以自定义的该 edge 节点的 n2n 内网 IP；</span></span><br><span class="line"><span class="comment"># `mynetwork` 是你可以自定义的 n2n 网络名称；</span></span><br><span class="line"><span class="comment"># `nic1234` 是你可以自定义的 n2n 密钥；</span></span><br><span class="line"><span class="comment"># `&#123;supernode 的公网 IP&#125;` 是你部署 supernode 的主机的公网 IP。</span></span><br><span class="line"></span><br><span class="line">edge -a 10.10.2.1 -c mynetwork -k nic1234 -l &#123;supernode 的公网 IP&#125;:8990 -r -f</span><br></pre></td></tr></table></figure><p>检查 <code>docker ps</code>，发现名为 <code>edge0</code> 的容器处于运行状态则说明部署完成。</p><h2 id="检查-n2n-连接是否建立"><a href="#检查-n2n-连接是否建立" class="headerlink" title="检查 n2n 连接是否建立"></a>检查 n2n 连接是否建立</h2><p>在 supernode 主机(10.10.2.1)上检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(base) [root@iz2zeid7airzi8dw94q5l4z ~]<span class="comment"># ping 10.10.2.3</span></span><br><span class="line">PING 10.10.2.3 (10.10.2.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.10.2.3: icmp_seq=1 ttl=64 time=10.0 ms</span><br><span class="line">64 bytes from 10.10.2.3: icmp_seq=2 ttl=64 time=9.25 ms</span><br><span class="line">64 bytes from 10.10.2.3: icmp_seq=3 ttl=64 time=9.02 ms</span><br><span class="line">64 bytes from 10.10.2.3: icmp_seq=4 ttl=64 time=9.63 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.10.2.3 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3003ms</span><br><span class="line">rtt min/avg/max/mdev = 9.028/9.492/10.051/0.400 ms</span><br><span class="line">(base) [root@iz2zeid7airzi8dw94q5l4z ~]<span class="comment"># ssh root@10.10.2.3</span></span><br><span class="line">root@10.10.2.3<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">Last login: Tue Jan 17 05:45:36 2023 from 10.38.26.180</span></span><br><span class="line"><span class="string">(env-3.7) (base) [root@localhost ~]#</span></span><br></pre></td></tr></table></figure><p>Ping 和 SSH 均能连接，说明 n2n 连接成功建立</p><p>然后在 edge 主机(10.10.2.3)执行同样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(env-3.7) (base) [root@localhost home]<span class="comment"># ping 10.10.2.1</span></span><br><span class="line">PING 10.10.2.1 (10.10.2.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.10.2.1: icmp_seq=1 ttl=64 time=11.3 ms</span><br><span class="line">64 bytes from 10.10.2.1: icmp_seq=2 ttl=64 time=10.0 ms</span><br><span class="line">64 bytes from 10.10.2.1: icmp_seq=3 ttl=64 time=9.66 ms</span><br><span class="line">64 bytes from 10.10.2.1: icmp_seq=4 ttl=64 time=9.69 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.10.2.1 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3004ms</span><br><span class="line">rtt min/avg/max/mdev = 9.667/10.194/11.333/0.682 ms</span><br><span class="line">(env-3.7) (base) [root@localhost home]<span class="comment"># ssh root@10.10.2.1</span></span><br><span class="line">root@10.10.2.1<span class="string">&#x27;s password:</span></span><br><span class="line"><span class="string">Last login: Tue Jan 17 20:20:28 2023 from 120.36.171.227</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Welcome to Alibaba Cloud Elastic Compute Service !</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(base) [root@iz2zeid7airzi8dw94q5l4z ~]#</span></span><br></pre></td></tr></table></figure><p>至此， n2n 的容器化部署和连接建立全部完成。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> N2N </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用 Screen 运行后台任务</title>
      <link href="/2023/01/579e41c9.html"/>
      <url>/2023/01/579e41c9.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何利用-Screen-运行后台任务"><a href="#如何利用-Screen-运行后台任务" class="headerlink" title="如何利用 Screen 运行后台任务"></a>如何利用 Screen 运行后台任务</h1><p>在很多文档中，建议我们使用以下方法后台运行代码以便 ssh 退出后服务器仍然能继续执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> &lt;cmd&gt; &amp;</span><br><span class="line">or</span><br><span class="line"><span class="built_in">nohup</span> &lt;cmd&gt; &amp; &gt;&gt; outfile.out</span><br></pre></td></tr></table></figure><p>然而，这有两个缺点</p><ol><li><code>nohup</code> 后台运行会在 <code>nohup.out</code> 或是你所指定的重定向文件中，实时打印程序的标准输出和标准错误输出。它的大小是无限量增长的，但一旦直接删除了 <code>nohup.out</code> ，该任务进程就再也无法输出任何内容。更重要的是，项目中已经有了一个独立的较为成熟的日志系统，<code>nohup.out</code> 的内容对我们来说实际上几乎没有作用</li><li>停止 <code>nohup</code> 任务很不直观，需要 <code>ps -def | grep &quot;&lt;target_file_name&gt;&quot;</code> 找到 pid ，然后 <code>kill</code> 掉</li></ol><p>因此，可以使用大部分 linux 自带的 <code>screen</code> 指令来实现后台运行任务，无视 ssh 的退出。</p><blockquote><p>咱们服务器这个版本的 CentOS 属于那些小部分的 linux :)，因此先需要执行 <code>yum install screen -y</code></p></blockquote><h2 id="screen-基本用法"><a href="#screen-基本用法" class="headerlink" title="screen 基本用法"></a>screen 基本用法</h2><blockquote><p>详细用法见<a href="https://www.runoob.com/linux/linux-comm-screen.html">菜鸟教程</a></p></blockquote><p><code>screen</code> 本质上可以理解为在终端上再套一个终端。使用以下代码新建一个叫做 <code>test</code> 的虚拟终端:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>执行后，终端会变成像执行 <code>clear</code> 后的样子。实际上这已经进入了虚拟终端 <code>test</code> ，这时候你可以直接像普通终端一样操作这个终端，例如，可以直接通过<code>cd</code> 指令打开项目文件，然后用 <code>python keepRunning.py</code> 指令执行一个叫 <code>keepRunning.py</code> 的持续运行的程序。</p><p>然后，你可以通过键盘操作 <code>Ctrl + A + D</code> ，这样你就能从“虚拟世界”返回“现实世界”。在现实的终端中，你会看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]<span class="comment"># screen -S test</span></span><br><span class="line">[detached from 143098.<span class="built_in">test</span>]</span><br><span class="line">[root@localhost home]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这说明你回到了最初的终端，而刚才你所打开的虚拟终端 <code>test</code> 中执行的命令也同样在执行着。</p><blockquote><p>尽管如此比喻，但 screen 指令完全不涉及任何虚拟化技术，也即几乎没有任何性能损失。可以理解为一个可以后台运行的新终端，文件系统、CPU 等资源还是照样调用。实际上，screen 是一个非常古老的、由 GUN 编写的 linux 程序，它诞生的时候虚拟化的概念还远远没有成熟</p></blockquote><p>为了确认虚拟终端还在后台运行，你可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]<span class="comment"># screen -ls</span></span><br><span class="line">There is a screen on:</span><br><span class="line">        143098.<span class="built_in">test</span>     (Detached)</span><br><span class="line">1 Socket <span class="keyword">in</span> /var/run/screen/S-root.</span><br><span class="line"></span><br><span class="line">[root@localhost home]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这说明你的虚拟终端 <code>test</code> (PID: 143098) 正在后台运行</p><p>如何返回这个终端？你可以使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这样你就能回到这个终端继续你的工作了，此时 <code>keepRunning.py</code> 可能已经运行了好几轮。而退出终端同样使用快捷键 <code>Ctrl + A + D</code> 。</p><p>如何彻底关闭这个终端的进程呢？当然可以使用 <code>kill</code> ，但我建议你直接通过 <code>screen -r</code> 进入虚拟终端，然后出入 <code>exit</code> 和回车，屏幕会这么显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]<span class="comment"># screen -r test</span></span><br><span class="line">[screen is terminating]</span><br><span class="line">[root@localhost home]<span class="comment"># screen -ls</span></span><br><span class="line">No Sockets found <span class="keyword">in</span> /var/run/screen/S-root.</span><br><span class="line"></span><br><span class="line">[root@localhost home]<span class="comment">#</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将 Python 项目打包为 Docker</title>
      <link href="/2023/01/2b71833f.html"/>
      <url>/2023/01/2b71833f.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何将-Python-项目打包为-Docker"><a href="#如何将-Python-项目打包为-Docker" class="headerlink" title="如何将 Python 项目打包为 Docker"></a>如何将 Python 项目打包为 Docker</h1><h2 id="编写-requirement-txt"><a href="#编写-requirement-txt" class="headerlink" title="编写 requirement.txt"></a>编写 requirement.txt</h2><p>在封装打包为 docker 镜像前，需要确定 Python 项目所需要的 pip 依赖，并且<strong>必须确定该依赖的包的版本</strong>。浏览各个 .py 文件，检查 <code>import</code> 语句后的包是否非 Python 自带。以 <code>requests</code> 为例，确定项目引用了 <code>requests</code> 后，在控制台输入 <code>pip list | grep requests</code> 即可查看其版本。</p><blockquote><p>请注意，并非每个 Python 包版本都能用该方法查询。例如 <code>import yaml</code> 指代的就是 PyYAML 包，然而 “yaml” 和 “PyYAML” 二者没有一个字母是相同的。在这种情况下，只能直接输入 <code>pip list</code> 手动查看包版本</p></blockquote><p>确认了第三方包及其版本后，编写 <code>requirement.txt</code> ，下方是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PyYAML==6.0</span><br><span class="line">requests==2.28.1</span><br></pre></td></tr></table></figure><h2 id="整理项目文件夹"><a href="#整理项目文件夹" class="headerlink" title="整理项目文件夹"></a>整理项目文件夹</h2><p>将项目文件全部复制到一个新的文件夹中，此处我取名为 <code>/docker</code> 文件夹。复制时需要注意：</p><ul><li>清空 <code>/data</code> 、<code>/config</code> 、<code>/logs</code> 文件夹</li><li>无需复制 <code>/doc</code> 、<code>/test</code> 和 <code>README.md</code></li><li>在 <code>/docker</code> 新建一个 <code>Dockerfile</code></li></ul><blockquote><p>一般来说，Python 项目的配置文件都放在根目录，然而为了使得 Docker 能映射卷到宿主机以在宿主机配置程序，此处仍然需要将配置文件放在专门的目录里</p></blockquote><p>文件树如下（README.md 也可以删除）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bgpdump</span><br><span class="line">├── config</span><br><span class="line">├── data</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── logs</span><br><span class="line">├── README.md</span><br><span class="line">├── requirements.txt</span><br><span class="line">├── setup.py</span><br><span class="line">└── src</span><br></pre></td></tr></table></figure><blockquote><p>bgpdump 作为欲使用的工具，需要先行编译后放入，否则构建镜像时可能没有编译它的环境</p></blockquote><h2 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h2><p>Dockerfile 内容编写如下：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>.<span class="number">10</span>-slim</span><br><span class="line"><span class="comment"># 将 python 添加进环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/bin:$PATH</span><br><span class="line"><span class="comment"># 对于时间敏感的项目，需要添加时区环境变量。此处为亚洲，上海</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 将项目文件复制到工作文件夹</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /BGP_Collector</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /BGP_Collector</span></span><br><span class="line"><span class="comment"># 安装依赖（通过清华源）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn</span></span><br></pre></td></tr></table></figure><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>在确保已经通过 <code>cd</code> 打开 <code>/docker</code> 的前提下，控制台运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t bgp_collector ./</span><br></pre></td></tr></table></figure><p>构建完成后通过 <code>docker images</code> 即可看到该镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost BGP_Collector]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY      TAG           IMAGE ID       CREATED          SIZE</span><br><span class="line">bgp_collector   latest        427714bb01cd   13 minutes ago   125MB</span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>接下来需要创建容器，直接贴出指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=<span class="string">&quot;BGP_Collector&quot;</span> -v /home/docker/BGP_Collector/config:/BGP_Collector/config -v /home/docker/BGP_Collector/logs:/BGP_Collector/logs -v /home/bgpdata/ripe:/BGP_Collector/data --privileged=<span class="literal">true</span> bgp_collector /bin/sh</span><br></pre></td></tr></table></figure><ul><li><strong>-itd:</strong> 后台交互模式运行并分配一个伪终端</li><li><strong>–name:</strong> 容器名</li><li><strong>-v {host_dir}:{container_dir}:</strong> 将宿主机和容器之间的特定文件进行映射，请注意，是以宿主机文件为准，即原来复制到镜像的文件都会被宿主机目录的文件替换</li><li><strong>–privileged&#x3D;true:</strong> 以最高权限运行容器，因为涉及数据卷的操作</li><li><strong>bgp_collector:</strong> 采用的镜像名</li><li><strong>&#x2F;bin&#x2F;sh:</strong> 执行的脚本，通俗的讲就是在内部控制台启动 bash</li></ul><h2 id="运行容器中的-Python-程序"><a href="#运行容器中的-Python-程序" class="headerlink" title="运行容器中的 Python 程序"></a>运行容器中的 Python 程序</h2><p>接下来需要进入正在运行的容器。与 <code>docker exec</code> 相比，我更推荐简洁的 <code>docker attach BGP_Collector</code> 进入容器。</p><p>在容器中的终端（一个精简的 Debian 内核系统）运行你的程序，例如 <code>python setup.py -d</code> 。你能看到它能正常运行，然后，使用快捷键 <code>Ctrl + P + Q</code> 即可不停止程序和容器运行而退出容器。如果需要返回这个正在运行的容器，直接输入 <code>docker attach BGP_Collector</code> 即可。</p><blockquote><p>请勿使用 exit 退出容器，这样将直接让容器关闭</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将 Vue 项目打包为 Docker 镜像并运行容器</title>
      <link href="/2023/01/4daa3827.html"/>
      <url>/2023/01/4daa3827.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何将-Vue-项目打包为-docker"><a href="#如何将-Vue-项目打包为-docker" class="headerlink" title="如何将 Vue 项目打包为 docker"></a>如何将 Vue 项目打包为 docker</h1><blockquote><p>本文在安装了 Docker 的 Linux 或 WSL 环境下可用</p></blockquote><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="Vue-配置"><a href="#Vue-配置" class="headerlink" title="Vue 配置"></a>Vue 配置</h3><p>首先需要在 Vue 项目的 <code>.env</code> 文件中配置项目路径，以保证建项目后资源路径正确。同时特别关注配置的端口号，接下来将用 Nginx 监听该端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># port 端口号</span><br><span class="line">VITE_PORT = 8888</span><br><span class="line"></span><br><span class="line"># open 运行 npm run dev 时自动打开浏览器</span><br><span class="line">VITE_OPEN = false</span><br><span class="line"></span><br><span class="line"># public path 配置线上环境路径（打包）、本地通过 http-server 访问时，请置空即可</span><br><span class="line">VITE_PUBLIC_PATH = ./</span><br></pre></td></tr></table></figure><p>然后，在 Vue 项目目录输入 <code>npm run bulid</code> ，随后会生成 <code>dist</code> 文件夹，内容是 Vue 项目的静态文件，拷贝该文件到你喜欢的任意目录文件夹下。下文假设该文件夹叫做 <code>/docker-bulid</code></p><h3 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>在 <code>docker-bulid</code> 文件夹中新建 <code>nginx.conf</code> 文件，内容配置如下</p><blockquote><p>注意，Nginx 监听的端口号必须与你在 Vue 项目中配置的一致</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user nginx;</span></span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">    <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">    <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8888</span> default_server; <span class="comment"># 让 Nginx 监听你的 Vue 项目所配置的那个端口</span></span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">8888</span> default_server;<span class="comment"># IPv6: 让 Nginx 监听你的 Vue 项目所配置的那个端口</span></span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="section">location</span> = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dockerfile-配置"><a href="#Dockerfile-配置" class="headerlink" title="Dockerfile 配置"></a>Dockerfile 配置</h3><p>在 <code>docker-bulid</code> 文件夹中新建 <code>Dockerfile</code> 文件，内容配置如下</p><blockquote><p>注意，<strong>Dockerfile</strong> 一定不要写错，”D”是大写，”f”是小写，且没有文件扩展后缀</p></blockquote><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像使用Nginx</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="comment"># 作者</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer==<span class="string">&quot;lgh&quot;</span></span></span><br><span class="line"><span class="comment"># 添加时区环境变量，亚洲，上海</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt; /etc/timezone \</span></span><br><span class="line"><span class="language-bash"><span class="comment"># 将前端dist文件中的内容复制到nginx目录</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./dist/  /usr/share/nginx/html/</span></span><br><span class="line"><span class="comment"># 用本地的nginx配置文件覆盖镜像的Nginx配置</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5438</span></span><br></pre></td></tr></table></figure><h3 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h3><p>最后，你的 <code>docker-bulid</code> 文件夹应该是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-bulid</span><br><span class="line">├── dist</span><br><span class="line">│   ├── assets</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   └── index.html</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── nginx.conf</span><br></pre></td></tr></table></figure><h2 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h2><p>请保证已经用 <code>systemctl start docker</code> 指令开启了 docker，通过 <code>systemctl status docker</code> 可以确认</p><p>通过 <code>cd</code> 指令确保控制台在 <code>docker-bulid</code> 目录下，输入指令 <code>sudo docker build -t my_project ./</code> 以生成镜像。其中，<code>my_project</code> 是镜像名，<code>./</code> 是 Dockerflie 所在的目录。以下是一个运行的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost vue_project]<span class="comment"># docker build -t vue_project ./</span></span><br><span class="line">Sending build context to Docker daemon  8.062MB</span><br><span class="line">Step 1/6 : FROM nginx</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">3f4ca61aafcd: Pull complete</span><br><span class="line">50c68654b16f: Pull complete</span><br><span class="line">3ed295c083ec: Pull complete</span><br><span class="line">40b838968eea: Pull complete</span><br><span class="line">88d3ab68332d: Pull complete</span><br><span class="line">5f63362a3fa3: Pull complete</span><br><span class="line">Digest: sha256:0047b729188a15da49380d9506d65959cce6d40291ccfb4e039f5dc7efd33286</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:latest</span><br><span class="line"> ---&gt; 1403e55ab369</span><br><span class="line">Step 2/6 : LABEL maintainer==<span class="string">&quot;lgh&quot;</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 8839c3da3940</span><br><span class="line">Removing intermediate container 8839c3da3940</span><br><span class="line"> ---&gt; 7bf71c93c97e</span><br><span class="line">Step 3/6 : ENV TimeZone=Asia/Shanghai</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 100ad607f2a4</span><br><span class="line">Removing intermediate container 100ad607f2a4</span><br><span class="line"> ---&gt; 6a31f88af644</span><br><span class="line">Step 4/6 : COPY ./dist/  /usr/share/nginx/html/</span><br><span class="line"> ---&gt; 220ce4e38858</span><br><span class="line">Step 5/6 : COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line"> ---&gt; f8eefdf56042</span><br><span class="line">Step 6/6 : EXPOSE 5438</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> a4387c21f14a</span><br><span class="line">Removing intermediate container a4387c21f14a</span><br><span class="line"> ---&gt; 7e1f6c0fb0da</span><br><span class="line">Successfully built 7e1f6c0fb0da</span><br><span class="line">Successfully tagged vue_project:latest</span><br></pre></td></tr></table></figure><p>然后，通过 <code>docker image ls</code> 或 <code>docker images</code> 指令来查看镜像是否创建成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost vue_project]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">vue_project   latest    40037756824a   3 seconds ago   150MB</span><br><span class="line">nginx         latest    1403e55ab369   2 weeks ago     142MB</span><br></pre></td></tr></table></figure><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>上一节我们已经创建了镜像，接下来需要根据这个镜像启动容器，使用以下命令以 vue_project 镜像启动一个容器：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="keyword">run</span><span class="language-bash"> -itd -p 5438:80 --name=<span class="string">&quot;vue_test&quot;</span> vue_project:latest</span></span><br></pre></td></tr></table></figure><ul><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>-d:</strong> 后台运行容器，并返回容器 ID；</li><li><strong>-p:</strong> 指定端口映射，格式为：<code>主机(宿主)端口:容器端口</code></li><li><strong>–name&#x3D;”{str}”:</strong> 为容器指定一个名称；</li></ul><p>运行完毕后控制台会返回一个容器 id ，可使用指令 <code>docker ps -a</code> 查看所有容器的基本情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost vue_project]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE                COMMAND                  CREATED         STATUS         PORTS                                             NAMES</span><br><span class="line">3f69524fd34a   vue_project:latest   <span class="string">&quot;/docker-entrypoint.…&quot;</span>   7 seconds ago   Up 5 seconds   5438/tcp, 0.0.0.0:5438-&gt;80/tcp, :::5438-&gt;80/tcp   vue_test</span><br></pre></td></tr></table></figure><p>在这个例子中，我们用 docker 将 5438 端口映射到了 Nginx 代理的 80 端口上。因此容器确认运行以后，浏览器访问运行该容器的服务器的 5438 端口即可访问这个 Vue 生成的网页。</p><p>至此，Vue 项目的 docker 部署过程久结束了。</p><h1 id="如何更新镜像"><a href="#如何更新镜像" class="headerlink" title="如何更新镜像"></a>如何更新镜像</h1><p>最好的更新容器方式是使用 docker hub 或自建 docker 仓库，通过和 git 类似的 push&#x2F;pull 模式进行版本控制。但是有时时间紧迫或环境不支持，可用以下方式更新容器内容。下文同样以上一节的项目为例。</p><h2 id="停止容器并删除旧的容器-x2F-镜像"><a href="#停止容器并删除旧的容器-x2F-镜像" class="headerlink" title="停止容器并删除旧的容器&#x2F;镜像"></a>停止容器并删除旧的容器&#x2F;镜像</h2><blockquote><p>以下操作需要按照<strong>顺序执行</strong></p></blockquote><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>通过 <code>docker ps -a</code> 找到需要停止的容器 id，例子中是 3f69524fd34a ，然后运行以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stop 3f69524fd34a</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>运行以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">rm</span> 3f69524fd34a</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>通过 <code>docker images</code> 找到需要停止的镜像 id，例子中是 40037756824a ，然后运行以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi 40037756824a</span><br></pre></td></tr></table></figure><h2 id="替换-dist-文件夹"><a href="#替换-dist-文件夹" class="headerlink" title="替换 dist 文件夹"></a>替换 dist 文件夹</h2><p>将更新后重新构建的新 <code>dist</code> 文件夹替换 <code>/docker-bulid</code> 中的旧文件夹即可，一般 <code>nginx.conf</code> 和 <code>Dockerfile</code> 无需改动</p><h2 id="重新生成镜像-x2F-容器"><a href="#重新生成镜像-x2F-容器" class="headerlink" title="重新生成镜像&#x2F;容器"></a>重新生成镜像&#x2F;容器</h2><p>参考<a href="#%E7%94%9F%E6%88%90%E9%95%9C%E5%83%8F">生成镜像</a>部分操作即可</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 2022 年</title>
      <link href="/2022/12/e123c2bd.html"/>
      <url>/2022/12/e123c2bd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>三个词总结我的 2022，大概就是 <strong>游戏</strong>、<strong>旅行</strong>和<strong>成长</strong></p></blockquote><p>今天是 2022 年的最后一天，每年的这个时候我都会感慨时光荏苒、日月如梭，但也仅此而已 <del>，随后很快就投入无尽快乐的游戏中</del>。但今年对我而言也算是充满意义的一年（正面负面都有），再加上刚好有了博客这个载体，还是决定在这个博客里浅浅记录一下我的 2022 。</p><p>封面图是沙漠里的绿洲（只要不拍人， <del>特别是拍自己，</del> 我还是对自己的拍照技术有点自信的）</p><h2 id="年初：荒废于玩乐，奔波于疫情"><a href="#年初：荒废于玩乐，奔波于疫情" class="headerlink" title="年初：荒废于玩乐，奔波于疫情"></a>年初：荒废于玩乐，奔波于疫情</h2><p>自从保研资格到手后，我和一起末位保研的舍友 L 携手开始了摆烂生活。整整 2022 年上半年，都是游戏、游戏、游戏然后睡觉。实际上无论是从同龄的保研人还是往届的学长学姐的经验来说，这都是找多段实习的一个黄金时间，从现在的我看来它确确实实是被我自己浪费了。但说非常后悔，那也不太至于，因为这种毫无顾虑为所欲为的放空生活真的很快乐。当时的我总有一种感觉，这样的时光可能一辈子都不会再有了，那么及时行乐又有何不可？</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/12/31/4H95XgMflEuSDa1.png" alt="屏幕截图_20221231_135430.png"></p><p>我真正后悔的事情，是没能及时和我的亲人告别。2 月份寒假结束的时候，我家乡这里的疫情有明显转坏的趋势，家人都劝我趁着窗口期，赶紧回北京。但在北京没落脚几天，家中便传来祖母过世的噩耗，彼时疫情已经开始肆虐，办丧事的亲人们几乎被全部隔离，我也无从再见祖母最后一面。过年时还在为子女们膝下承欢而笑容满面的祖母，如今却突然天人两隔，而我就只能用我的一篇吊唁文在他乡草草与她告别。这是我一辈子也无法弥补的遗憾。</p><p>临近年中，毕业论文也顺利完成了，实验室也没有新的活要我干。本来我以为这个暑假也会和之前的几个月一样沉溺于游戏和吃喝玩乐，直到室友 L 的一通电话打来，彻底改变了我半年以来生活的单调色彩。</p><h2 id="年中：旅行、旅行、还是旅行"><a href="#年中：旅行、旅行、还是旅行" class="headerlink" title="年中：旅行、旅行、还是旅行"></a>年中：旅行、旅行、还是旅行</h2><p>还是一个非常平常的 6 月天，刚从返乡居家隔离结束的我还在阳台和老妹分享冰镇快乐水，室友 L 破天荒给我打了个电话：“去四川和青海吗？”第二天我直接提着我的行李箱和背包踏上了西部之旅。</p><h3 id="成都：最“宜居”的一线城市"><a href="#成都：最“宜居”的一线城市" class="headerlink" title="成都：最“宜居”的一线城市"></a>成都：最“宜居”的一线城市</h3><p>成都只是我们旅途的落脚点，在这里我们只计划呆上 2 天就向西北进发。但仅仅就是这两天我就能深刻体会到成都的魅力：拥有内陆城市最好的气候和高度发达的商品服务业，最重要的是，在这里街道上的男女老少都无时无刻诠释着“及时行乐”的精神。成都没有北京那种来自权力的高压氛围、也没有上海那种纸醉金迷的排外气息，它就是一个贴近每个人、满足每个人最简单欲望的城市。它可能不适合奋斗，但它确实值得停下来生活。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/12/31/3AZ8wjiRoGDMOxJ.jpg" alt="IMG20220622211626-1.jpg"></p><center>我和室友 L 在成都地铁上</center><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/12/31/29yZbGqHg3rM4mW.jpg" alt="IMG20220623211844.jpg"></p><center>现在基本见不到的人山人海</center><h3 id="青海：从来没有想过中国大地上还有这样的景色"><a href="#青海：从来没有想过中国大地上还有这样的景色" class="headerlink" title="青海：从来没有想过中国大地上还有这样的景色"></a>青海：从来没有想过中国大地上还有这样的景色</h3><p>如标题所述，这次西北之旅可以说是充满震撼的，多说无益，放几张图就知道了</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/12/31/kEINayYADBLeH6p.jpg" alt="IMG20220625095721.jpg"></p><center>满山遍野的羊！</center><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/12/31/Y6fcnIFKsGbQq7z.jpg" alt="IMG20220625123310.jpg"></p><center>对沿海城市人来说青海湖就没啥看点——和看海一模一样</center><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/12/31/TkysrM6JRt5qSI1.jpg" alt="IMG20220626172342.jpg"></p><center>室友 L 和忽隐忽现的雪山</center><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/12/31/KEWSIfFcrB1VznU.jpg" alt="IMG20220627055802.jpg"></p><center>日出</center><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/12/31/F3eMCaDgdXZKJQk.jpg" alt="IMG20220627091716.jpg"></p><center>黄沙和公路</center><h3 id="开学前……"><a href="#开学前……" class="headerlink" title="开学前……"></a>开学前……</h3><p>可以说，我几乎整个 7 月份都花费在旅行上了，而在临近开学的 8 月份，我则是仍然热衷于吃喝玩乐——一样是摆烂，室外摆烂和室内摆烂的区别罢了。</p><p>可一旦走出门去，我立刻就发现一件事：我和别人的交流太少了。我的社交圈子被我自己限制在了一个非常有限的范围里，我能够好好交心的朋友少的可怜，内心的一些想法就只能这么憋在心里，这让我感到有些焦虑。</p><h2 id="下半年：不再是学生"><a href="#下半年：不再是学生" class="headerlink" title="下半年：不再是学生"></a>下半年：不再是学生</h2><p>研究生生活很快开始了。新室友人都很好，和本科的宿舍一样，我非常幸运遇到了 5 个价值观相当的室友 <del>（又一个摆烂宿舍）</del> 。我的也开始正式参与实验室科研活动。因为已经自己稍微规划了发展路线，我也开始刷题、做项目，<a href="https://alrisha.cn/">Alrisha</a> 这个博客也是这时候诞生的，我还开始学习 Docker 、 Go 等玩意来丰富我的技术栈。可以说，刚开始的研究生生活还是非常充实的，每周我都可以很明显看到自己的一点点提升。</p><p>不过就和我上文提到的那样，我的社交圈子太小了（搞不好我其实是很喜欢和人瞎扯的那种人，就是我自己没发现而已），这就让我在生活充实的同时精神开始空虚。并不是说和我那群兄弟们说话不舒服，但是就是有种精神需求没法满足的感觉。而在个人感情方面我也是苦手一枚，不要说在一个纯纯理工学校里资源本来就少了，我自己还没什么和异性交流的能力（怪不好意思的）。并且有些过往的经历还是挥之不去，剪不断理还乱。</p><p>这样的结果就是我开始不停的失眠，甚至找过心理咨询。舍友也关心过我，但也无济于事。后来我想，这样可不行啊 FAWC ，这么下去你可得寄了。于是我还是鼓起勇气来约人聊天，找人谈心。一顿操作后才惊觉：什么嘛，这原来也不是那么难的事情。</p><p>上面讲了一堆废话，总结起来就是人际交往不要太自闭，不然真的会自闭的 ( : 。这样波澜不惊的生活和打工人一般的实验室经历，更是让我深刻意识到了我已经慢慢失去了“学生”这个身份给我的伪装和保护，有些时候不靠自己还就只能吃闷亏。</p><h2 id="2023-？"><a href="#2023-？" class="headerlink" title="2023 ？"></a>2023 ？</h2><p>然后，转眼就到了 2022 年的最后一天。</p><p>最近实验室又让我接了一个新项目，而我也在家乡这里找到了一个<a href="https://alrisha.cn/2022/12/c3cd6382.html">假期小实习</a>，国内防控也基本放开了。看起来非常忙碌的寒假，和还从来没阳过决赛圈吃鸡的我也不知道接下来会怎么样。总之还是一步步走吧，毕竟就和我上面提到的一样，为所欲为的摆烂生活可能再也回不来了。</p><p>哎呀，写了这么多，回过头来看其实 2022 年过的也不是那么快嘛（笑</p><blockquote><p><strong>最后，祝看到这篇文章的朋友们 2023 新年快乐！</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game </tag>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极致游戏 IT运维 日常实习面经</title>
      <link href="/2022/12/c3cd6382.html"/>
      <url>/2022/12/c3cd6382.html</url>
      
        <content type="html"><![CDATA[<p>之前投了简历大概3天后 HR 才和我联系，安排了一个没课的上午面试。我提前半小时在飞书等，面试官很准时就到了，其本人应该也是极致的运维工程师。</p><h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><ol><li>自我介绍</li><li>你的项目经历很多，有落地实践的项目吗？<ul><li>这是我第一次实习并且实验室几乎没有横向所以我说的没有，但实际上其实那个空教室查询软件还是能说说的，毕竟当时还是部署到酷安上了，只能说自己太老实了</li></ul></li><li>本科是网络工程，有做过相关的项目吗？<ul><li>说了一下简历没有写上的一个 DNS 服务器，当时用的字典树写的域名解析，效果还不错。不过我只是参与者，那个项目 Leader 是个大牛，现在去了人大高瓴。</li></ul></li><li>对Linux系统的特点做个基本阐述，举出和Windows的差别？<ul><li>这个问题我觉得太泛了，我就回答了一下多线程是不同的，比如 Linux 用的主要是 Fork() 效率高一些，Windows 则是用的不同的方法（具体什么方法一时想不出来），这也是 Redis 弃用 Windows 的主要原因之一。</li><li>感觉面试官对我这个回答不太满意 QAQ</li></ul></li><li>常用的 Linux 指令有哪些？<ul><li>top 用来看CUP负载, netstat 来看端口占用。</li><li>让我惊讶的是没有在这方面深问下去了，我本来准备了不少这方面内容</li></ul></li><li>TCP 和 UDP 的区别和应用场景&#x2F;TCP 和 Http 的关系。<ul><li>网上有很多完整的答案，我也有准备所以答得还可以。</li></ul></li><li>简历里有NLP经历，说一下这个分类器是怎么实现的。<ul><li>详见我的<a href="https://github.com/FAWC438/Text-Classification">项目文档</a></li></ul></li><li>NLP 里预训练有什么作用?<ul><li>这个问题让我大吃一惊，我实在想不明白运维为啥要面这个知识。我只能粗略回答一下能让文本特征更显著，提高训练效果，节省训练时间。</li><li>面试官对这个回答显然不太满意。</li></ul></li><li>微服务方面服务发现负载均衡你是怎么做的？<ul><li>这方面我比较熟悉，说的比较多，回答也比较全。但是我觉得面试官对这个问题本身就不太感兴趣。</li></ul></li></ol><h2 id="聊天环节"><a href="#聊天环节" class="headerlink" title="聊天环节"></a>聊天环节</h2><ol><li>我们这里可能有 NLP 相关的需求，看到你的简历有这方面的经验，你能不能做这方面的工作？<ul><li>我人晕晕的，这是运维要干的吗，你们算法岗的兄弟们工资是白给的？再说我简历写了是网络和分布式微服务方向而不是 NLP ，这不是强人所难吗。难怪问我这么多 NLP 的问题。</li><li>幸好最近有在研究图神经网络，扯了一堆有的没的表示我的 NLP 技术还能进一步学习（大寄特寄回答）</li></ul></li><li>是福建本地人吗？</li><li>实习时间？</li><li>对在这的运维工作有什么期望？<ul><li>学习为主（钱和HR谈就好了）</li></ul></li><li>反问：工作时间？<ul><li>965</li></ul></li><li>反问：食宿？<ul><li>实习可能提供宿舍，吃饭问题自己解决</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试官态度还是很温和的，而且问题都是非常简单的问题，甚至没有任何算法方面的问题。但是问题的方向却很奇怪，总觉得他们是在招一个算法开发岗而不是运维（那为啥给我运维的面试啊）。而且我简历明明写的网络方向，他却硬是要问我 NLP 。有点担心这里的运维是不是传说中的那种全能背锅侠……</p><p>面完之后告诉我三天后出结果，好吧只能心怀期待等待了，到时候会在下文更新进展。</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internship </tag>
            
            <tag> Operation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两步解决 SSH 免密码登陆服务器</title>
      <link href="/2022/11/5ebced8a.html"/>
      <url>/2022/11/5ebced8a.html</url>
      
        <content type="html"><![CDATA[<p>在 VSCode 上使用 SSH 登陆我们实验室的服务器的时候需要每次都输入密码。虽然很早之前就知道可以配置 SSH 公钥实现免密登陆，但是当时我被<strong>配置公钥</strong>这几个字唬住了，以为是一件很繁琐的事情。这次硬着头皮配置了一下没想到这么简单，只需要两步就能够彻底消灭 SSH 的密码。</p><h2 id="两步实现"><a href="#两步实现" class="headerlink" title="两步实现"></a>两步实现</h2><h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><p>我生成的是 rsa 算法的公钥，比较方便，如果有需要也可以更改为别的加密算法。</p><p>在 Windows 的终端中直接输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>弹出的提示全部按回车跳过即可。</p><p>执行完毕后将会在当前用户根目录的 <code>.ssh</code> 文件夹（在 Windows 下是 <code>C:\Users\%在这里替换为你的用户名%\.ssh</code>）中生成文件名为 <code>id_rsa.pub</code> 的 rsa 公钥。</p><blockquote><p>如果你需要连接多个 SSH 服务器或是以前已经配置过公钥了，就无需执行这步生成新的公钥，直接使用第一次配置的 <code>.pub</code> 文件就行了</p></blockquote><h3 id="将公钥发送给服务器"><a href="#将公钥发送给服务器" class="headerlink" title="将公钥发送给服务器"></a>将公钥发送给服务器</h3><p>输入以下指令将上一步生成的公钥发送给服务器。在这里， Windows 下的文件路径正反斜杠不敏感：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp C:/Users/%在这里替换为你的用户名%/.ssh/id_rsa.pub %服务器用户名%@%服务器的ip%:~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>例如，我可以输入 <code>scp C:/Users/alrisha/.ssh/id_rsa.pub root@10.127.55.11:~/.ssh/authorized_keys</code> ，这表明我将我的公钥通过 scp 指令传送到地址为 <code>10.127.55.11</code> 的服务器的 root 用户的 <code>/.ssh/authorized_keys</code> 文件夹，并且告诉服务器我是 root 用户。</p><p>这一步需要你最后输入服务器 SSH 的密码。成功后无论在终端还是 VSCode 中都无需密码就能登陆服务器了。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无需指定Windows IP ，一劳永逸的 WSL2 代理服务器配置</title>
      <link href="/2022/11/661de524.html"/>
      <url>/2022/11/661de524.html</url>
      
        <content type="html"><![CDATA[<p>为了复现一篇论文的实验结果，我需要在 Linux 环境下配置深度学习的开发环境，为此需要配置 WSL 的网络代理以实现科学上网。</p><p>网络上绝大部分教程都是获取 Windows 主机的 IP 并通过配置全局变量进行代理的方式，这种方式配置最大的问题是一旦网络环境改变， IP 地址也会发生改变，还需要重新配置。不过文章<a href="https://www.cnblogs.com/aobaxu/p/16257287.html">WSL2 中访问 Windows 的代理的最简易方案</a>中则提到了一种利用 Windows 自带的 mDNS 实现建议配置的方法，经过测试在 Win 11 的 WSL2 上稳定可用。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>首先，需要得到你的代理工具的端口并打开其局域网功能，在代理工具中一般都能查看。我使用的是 <a href="https://github.com/Fndroid/clash_for_windows_pkg">Clash</a> ，其默认端口为 <code>7890</code> 。</p></li><li><p>你还需要找到你的主机名称（电脑名称），推荐以下两种方法</p><ul><li>Win 11 下打开 <code>设置\系统\系统信息\设备规格</code> ，设备名称即为主机名称</li><li>控制台输入 <code>systeminfo</code> ，输出的主机名即为主机名称</li></ul></li></ul><h2 id="测试-mDNS-是否可用"><a href="#测试-mDNS-是否可用" class="headerlink" title="测试 mDNS 是否可用"></a>测试 mDNS 是否可用</h2><p>在 WSL 中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;你的主机名&gt;.<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>能够收到返回包则继续接下来的步骤，否则说明你的 Windows 版本不支持 mDNS 。</p><h2 id="修改全局变量配置代理"><a href="#修改全局变量配置代理" class="headerlink" title="修改全局变量配置代理"></a>修改全局变量配置代理</h2><p>用以下命令打开 <code>.bashrc</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim .bashrc</span><br></pre></td></tr></table></figure><p>使用 vim 在第一行插入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HTTP_PROXY=<span class="string">&quot;http://&lt;你的主机名&gt;.local:&lt;端口&gt;&quot;</span></span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=<span class="string">&quot;http://&lt;你的主机名&gt;.local:&lt;端口&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>这里我的端口就是 <code>7890</code> ，主机号就是前文查到的字符串。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>自此， WSL 的代理就一劳永逸配置好了，重启也不用担心失效了。为了测试是否成功，在 Windows 主机中打开代理工具。再打开 WSL ，输入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget google.com</span><br></pre></td></tr></table></figure><p>成功通过代理返回 HTML 则说明代理成功了。</p><blockquote><p>不建议使用 <code>ping</code> 测试，因为有些网页不允许被 <code>ping</code> 通。因此使用 <code>wget</code> 即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2 启动报错：参考的对象类型不支持尝试的操作</title>
      <link href="/2022/10/52023eef.html"/>
      <url>/2022/10/52023eef.html</url>
      
        <content type="html"><![CDATA[<p>最近需要安装 Redis ，在 Windows 上官方推荐使用 WSL (Windows Subsystem for Linux)。然而在打开我好几周没开过的 WSL 后发现直接报错无法进入：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/25/meidkcaLb3JGsEu.png" alt="屏幕截图 2022-10-25 162842.png"></p><p><code>参考的对象类型不支持尝试的操作</code> 这个错误真是让人摸不着头脑……百度了一下很快就有解决方案了，为了节省下次再遇到这个问题的时间，直接一劳永逸的记录一下吧。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>该问题报错原因及其讨论见 <a href="https://github.com/microsoft/WSL/issues/4177#issuecomment-641984962">github-issue</a></p><ol><li><a href="www.proxifier.com/tmp/Test20200228/NoLsp.exe">下载</a>可执行文件 <code>NoLsp.exe</code> （需要科学上网）</li><li>管理员身份运行控制台（<code>右键点击 win 键 -&gt; 终端（管理员）</code>最直观）</li><li>控制台输入 <code>.\NoLsp.exe C:\windows\system32\wsl.exe</code></li><li>输出字符串 <code>Success!</code> 说明修复成功</li></ol><p>然后就可以打开 WSL 在 Windows 下尽情享用 Linux 啦！ <del>什么牛头人战士发言</del></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RFC 9234 ：一种新的 BGP 路由泄露防御与检测方法</title>
      <link href="/2022/10/73c1232.html"/>
      <url>/2022/10/73c1232.html</url>
      
        <content type="html"><![CDATA[<p>最近在 IETF 数据库上看近期的互联网草案和 RFC 文档。我特别关注到了 <a href="https://datatracker.ietf.org/doc/rfc9234/">RFC 9234 - Route Leak Prevention and Detection Using Roles in UPDATE and OPEN Messages</a> 这篇文档。该文档在今年（2022年）5月份才正式被赋予 RFC 编号，算是一篇很新的文档。这篇文档描述了通过对 BGP 的 <code>Open</code> 和 <code>Update</code> 两种报文新字段属性的设计，实现域间路由泄露的检测与防御。对于 BGP 这个已经成熟了数年的协议来说，有一份新的 RFC 文档已经非常难能可贵了，更何况是对报文本身的修改。恰巧我的本科毕业设计和实验室里一位学姐的研究方向都是这方面的内容，同时也为了方便我的组会汇报，在这里记录一下我对这篇文档的粗略介绍。<del>其实基本上就是翻译……</del></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>路由泄露是指 BGP 前缀的传播违反了对 BGP 拓扑关系的预期。例如将从一个 provider 学到的路由宣布给另一个 provider ；或是将从一个 peer 学到的路由宣布给另一个 peer 或宣布给其直接的 provider。这往往是 BGP 路由配置错误或缺失，导致自治域系统（autonomous systems, AS）之间缺乏协调的结果。</p><p>现有的路由泄露防御方案基本依赖于运营商的人工配置，无法检查本地 AS 和目标 AS 的配置是否一致，也不存在定义两个 eBGP （External BGP）宣告者之间商业关系的协议。</p><p>RFC 9234 规定了一种带内的方法来预防和检测路由泄露以取代上述由网络管理员驱动的基于配置的泄露解决方法。这个方法增强了 BGP <code>Open</code> 报文的功能，使得 eBGP 会话能够达成一种商业关系协议，BGP 路由路径将会根据这个特点进行标记，从而能防止与检测路由泄露。</p><p>该方法使用了一个新的属性参数 <code>BGP Role</code> ，该参数通过在 BGP <code>Open</code> 报文中的 <code>Capabilities</code> 字段（见<a href="https://datatracker.ietf.org/doc/rfc5492/">RFC 5492</a>）进行配置。</p><blockquote><p>RFC 5492 指出， <code>Capabilities</code> 字段是一个<strong>可选</strong>字段，它的一个重要特点之一是：当收到带有该字段 <code>Open</code> 报文的 BGP 路由器不支持 <code>Capabilities</code> 字段描述的功能时，将会把该功能忽略并正常建立 BGP 连接</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+</span><br><span class="line">| Capability Code (1 octet)    |</span><br><span class="line">+------------------------------+</span><br><span class="line">| Capability Length (1 octet)  |</span><br><span class="line">+------------------------------+</span><br><span class="line">| Capability Value (variable)  |</span><br><span class="line">~                              ~</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>同时，该方法还定义了一个可选的、具有传递性的 BGP <code>Path Attribute</code> （在 <code>Update</code> 报文中的一个字段），名为 <code>Only to Customer (OTC)</code> 。该参数能防止 AS 创建泄露报文，并能检测出 AS Path 中的路由泄露。</p><p>本文所述方法仅适用于 IPv4 和 IPv6 的单播路由通告。</p><blockquote><p><strong>必须知识</strong>：RFC 9234 假定读者已经理解 BGP 5种基本报文的数据结构</p></blockquote><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>下文中，“ <em>本地AS</em> ”和“ <em>远端AS</em> ”用于指代 eBGP 会话的两端。 <em>本地AS</em> 指要执行所述协议操作的 AS ， <em>远端AS</em> 指 eBGP 会话另一端的 AS 。</p><p>本文还定义了以下对等关系术语：</p><table><thead><tr><th align="center">角色</th><th align="center">路由规则</th></tr></thead><tbody><tr><td align="center">Provider</td><td align="center"><strong>可能会</strong>向 Customer 传播任何可用路由</td></tr><tr><td align="center">Customer</td><td align="center"><strong>可能会</strong>将从自身的 Customer 那里学到的或是本地产生的路由传播到一个 Provider 。所有其它路线都<strong>无法</strong>传播</td></tr><tr><td align="center">Route Server (RS)</td><td align="center"><strong>可能会</strong>向 RS-Client 传播任何可用路由</td></tr><tr><td align="center">Route Server Client (RS-Client)</td><td align="center"><strong>可能会</strong>将从自身的 Customer 那里学到的或是本地产生的路由传播到一个 RS 。所有其它路线都<strong>无法</strong>传播</td></tr><tr><td align="center">Peer</td><td align="center"><strong>可能会</strong>将从自身的 Customer 那里学到的或是本地产生的路由传播到另一个 peer 。所有其它路线都<strong>无法</strong>传播</td></tr></tbody></table><p>违反上述路由规则可能会导致路由泄露。</p><p>特别的，如果本地 AS 和远端 AS 有一个以上的对等角色，就应当被视为<strong>复杂对等关系</strong>。比如一对 AS 之间部分前缀是 Provider2Customer 关系，另一部分前缀是 Peer2Peer 关系。</p><!-- 下文将提到， OTC 属性用于识别 AS 从其 peer ， provider 或 RS 收到的路由。 --><h2 id="BGP-Role"><a href="#BGP-Role" class="headerlink" title="BGP Role"></a>BGP Role</h2><p>BGP Role 描述了建立连接的 eBGP speaker 之间的关系，本地 AS 如果是下表描述的任何一个角色，都应当在 eBGP 报文中配置 BGP Role，除非 eBGP 连接之间是<strong>复杂对等关系</strong>。</p><table><thead><tr><th align="center">本地 AS 角色</th><th align="center">具体描述</th></tr></thead><tbody><tr><td align="center">Provider</td><td align="center">本地 AS 是远端 AS 的 Provider</td></tr><tr><td align="center">Customer</td><td align="center">本地 AS 是远端 AS 的 Customer</td></tr><tr><td align="center">Route Server (RS)</td><td align="center">本地 AS 是一个 RS ，远端 AS 是其 RS-Client</td></tr><tr><td align="center">Route Server Client (RS-Client)</td><td align="center">本地 AS 是一个 RS-Client ，远端 AS 是其 RS</td></tr><tr><td align="center">Peer</td><td align="center">本地 AS 和远端 AS 之间是 Peer</td></tr></tbody></table><p>BGP Role 通过 <code>Update</code> 报文的 <code>Capabilities</code> 字段确认其内容。</p><h3 id="BGP-Role-编码"><a href="#BGP-Role-编码" class="headerlink" title="BGP Role 编码"></a>BGP Role 编码</h3><p>BGP Role 在 Capabilities 字段的编码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------+</span><br><span class="line">|              Code: 9                |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">|         Length: 1 (octet)           |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| Value: integer (speaker&#x27;s BGP Role) |</span><br><span class="line">~                                     ~</span><br><span class="line">+-------------------------------------+</span><br></pre></td></tr></table></figure><p>其中，BGP Role 与 Value 字段的对应关系如下：</p><table><thead><tr><th align="center">Value</th><th align="center">（本地 AS） BGP Role</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">Provider</td></tr><tr><td align="center">1</td><td align="center">RS</td></tr><tr><td align="center">2</td><td align="center">RS-Client</td></tr><tr><td align="center">3</td><td align="center">Customer</td></tr><tr><td align="center">4</td><td align="center">Peer</td></tr><tr><td align="center">5-255</td><td align="center">Unassigned</td></tr></tbody></table><p>BGP Role 属性一旦在本地被配置，其 eBGP speaker 必须在 BGP <code>Open</code> 报文中公布它。eBGP 路由器<strong>不能</strong>公布多种版本的 BGP Role 。下节将介绍收到多个 BGP Role 之后的错误处理。</p><h3 id="BGP-Role-正确性判断"><a href="#BGP-Role-正确性判断" class="headerlink" title="BGP Role 正确性判断"></a>BGP Role 正确性判断</h3><p>仅仅收到 BGP Role 不能保证两个 eBGP 实例之间的角色关系是正确的。下表是能够正确匹配的 BGP 角色关系：</p><table><thead><tr><th align="center">本地 AS 角色</th><th align="center">远端 AS 角色</th></tr></thead><tbody><tr><td align="center">Provider</td><td align="center">Customer</td></tr><tr><td align="center">Customer</td><td align="center">Provider</td></tr><tr><td align="center">RS</td><td align="center">RS-Client</td></tr><tr><td align="center">RS-Client</td><td align="center">RS</td></tr><tr><td align="center">Peer</td><td align="center">Peer</td></tr></tbody></table><p>如果角色不匹配， BGP speaker 必须使用 Role Mismatch <strong>Notification</strong> (code 2, subcode 11) 拒绝连接。</p><p>考虑到向后兼容，如果收到的报文缺失了 BGP Role ，BGP speaker 应当忽略这个属性并继续连接的建立。</p><p>如果一个 BGP speaker 收到了多个相同的 BGP Role ， 其 value 字段值都相同，则该 speaker 应当认为它们都是同一个 BGP Role 属性，并继续正常工作；一旦这些 BGP Role 中存在互不相同的 value ，则 BGP speaker 必须使用 Role Mismatch <strong>Notification</strong> (code 2, subcode 11) 拒绝连接。</p><blockquote><p>和 Open 、 Update 一样， Notification 也是 BGP 报文的一种，code 2 代表 Open 消息错误，其后的 subcode 11 则是在该 RFC 中定义的，针对“角色不匹配”事件设定的。该错误码已被 IANA 收录。</p></blockquote><h2 id="Only-to-Customer-OTC-属性"><a href="#Only-to-Customer-OTC-属性" class="headerlink" title="Only to Customer (OTC) 属性"></a>Only to Customer (OTC) 属性</h2><p>OTC 属性是 BGP <code>Update</code> 报文中 Path Attribute 字段的一个<strong>可选</strong>的且<strong>可传递</strong>的属性。</p><blockquote><p>Path Attribute 字段大家可能第一眼比较陌生，但是要知道的是像 AS_PATH, NEXT_HOP, LOCAL_PREF 等著名属性都在这个字段里</p></blockquote><p>OTC 属性的目的在于，一旦一个路由被 a 发送给 b，且 b 是 a 的 Customer 、 RS-Client 或 Peer 。那么在 b 要转发该路由给 c 时，OTC 属性强制保证了 c 必须是 b 的 Customer。</p><p>OTC 属性代码为35，长度为4个字节，属性值是一个 ASN ，该值由以下所述路由规则决定。</p><h3 id="OTC-属性的处理"><a href="#OTC-属性的处理" class="headerlink" title="OTC 属性的处理"></a>OTC 属性的处理</h3><ul><li><p>以下路由<strong>入口</strong>规则适用于路由器对 OTC 属性的处理</p><ol><li>如果从 Customer 或 RS-Client 处收到了带有 OTC 属性的路由，那么这就是一个路由泄露，该路由<strong>一定</strong>是不合格的</li><li>如果从 Peer （即具有 Peer 角色的远端 AS）收到具有 OTC 属性的路由，且该属性的值不等于这个远端 AS 的 ASN，那么这就是一个路由泄露，该路由<strong>一定</strong>是不合格的</li><li>如果从 Provider 、 Peer 或 RS 角色的远端 AS 收到路由，且 OTC 属性不存在，那么该路由必须被添加一个等于远端 AS 的 ASN 的值。</li></ol></li><li><p>以下路由<strong>出口</strong>规则适用于路由器对 OTC 属性的处理</p><ol><li>如果一个路由公告要发送给 Customer 、 Peer 或 RS-Client （当发送者为 RS 时），且 OTC 属性不存在，那么当公告该路由时，<strong>必须</strong>添加一个 OTC 属性，其值等于本地 AS 的 ASN。</li><li>如果一个路由已经包含了 OTC 属性，它<strong>一定</strong>不会被转发给 Provider 、 Peer 或 RS 。</li></ol></li></ul><h3 id="OTC-属性的应用"><a href="#OTC-属性的应用" class="headerlink" title="OTC 属性的应用"></a>OTC 属性的应用</h3><ul><li><p>以上路由规则能为本地 AS 提供泄露预防。在本地 AS 部署以上规则的前提下， OTC 属性的存在能向出口路由器表明该路由是从 Provider 、 Peer 或 RS 学习来的，它只能被发送到 Customer 。</p></li><li><p>如果收到了来自 Customer 、 Peer 或 RS-Client 的路由，在本地设置的 OTC 属性也提供了一种方法来在多跳以外检测 AS 的路由泄露。例如，如果一个 AS 在发送给 peer 的路由上设置了 OTC 属性，且该路由随后被一个路径上的 AS 从其 customer 那里收到，那么接受路由的 AS 会由于 OTC 的存在检测到该路由是一个路由泄露。</p></li></ul><blockquote><p>多跳外检测路由泄露是由 OTC 属性的传递性决定的</p></blockquote><ul><li>OTC 属性可以在远端 AS 的出口设置，也可以在本地 AS 的入口设置。也就是说，如果远端 AS 不支持 OTC 属性，但本地 AS 支持，那么本地 AS 根据规则也一定会将来自远端 AS 路由设置 OTC 属性，OTC 属性总是能设置为符合预期的值。这样的特性加之 OTC 属性多跳外检测路由泄露的能力，使得该路由泄露防御与检测方法可行性更高，满足在网络中部分部署的条件。</li></ul><h3 id="OTC-属性使用建议"><a href="#OTC-属性使用建议" class="headerlink" title="OTC 属性使用建议"></a>OTC 属性使用建议</h3><ul><li><p>如果报文中 OTC 属性长度值不是4，那么认为 OTC 属性是 <em>畸形</em> 的。根据 <a href="https://datatracker.ietf.org/doc/rfc7606/">RFC 7606</a> ，带有 <em>畸形</em> 属性的 <code>Update</code> 报文应使用“视同撤回”的方法处理。</p></li><li><p>上文提到的<a href="#otc-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86">OTC 属性的处理</a><strong>不建议</strong>在 <a href="https://datatracker.ietf.org/doc/rfc5065/">RFC 5065</a> 定义的 AS 联盟（Autonomous System Confederations）的自治系统之间使用。如果 OTC 被添加到 AS 联盟出口，其值<strong>必须</strong>等于 AS 联盟标识符，不能与 AS 联盟任何一个成员的 ASN 对应。</p></li><li><p>对于面向互联网的 ASN 及其背后绑定的私有 ASN，可以使用本文制定的规则。但任何内部细节都不在本文讨论范围内，在面向互联网的 AS 出口处， OTC 属性<strong>不得</strong>包含面向互联网的 ASN 以外的值。</p></li><li><p>一旦 OTC 属性被设置，<strong>必须</strong>保持不变。</p></li><li><p>所有入站和出站规则仅适用 IPv4 与 IPv6 地址族，默认情况下<strong>不得</strong>用于其它地址族。</p></li><li><p>网络操作员&#x2F;管理员<strong>不得</strong>修改本节中制定的规则。</p></li></ul><h2 id="额外考量"><a href="#额外考量" class="headerlink" title="额外考量"></a>额外考量</h2><ul><li><p><strong>不得</strong>在具有<a href="#%E6%9C%AF%E8%AF%AD">复杂对等关系</a>的 eBGP 连接上配置 BGP Role，除非能将 eBGP 的复杂对等关系连接拆分为正常对等关系连接。</p></li><li><p>运营商可能希望精确到以每个前缀为基准配置该方法，但目前还没有带内的方案来检测对每个前缀进行配置的正确性。<del>这句话原文我也看不懂啊！</del></p></li><li><p>BGP Role 或 OTC 属性的错误设置可能会导致路由错误传播。另外，本文没有规定对 OTC 属性中不正确 ASN 的特殊处理</p></li><li><p>在 <a href="https://datatracker.ietf.org/doc/rfc7705/">RFC7705</a> 定义的路由迁移的情况下，一个路由器可能能够将自己表示为几个不同 ASN 中的任意一个。不过，根据上文定义的<a href="#otc-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86">出口规则</a>，只要路由器将 OTC 值设置为其当前代表的 ASN 就不会出现问题。</p></li><li><p><a href="https://datatracker.ietf.org/doc/rfc7606/">RFC 7606</a> 的第六节提到了“视同撤回”策略可能产生的负面影响，这也同样适用于本方案的 OTC 属性。</p></li></ul><h2 id="关于该路由泄露防御与检测方法的安全考虑"><a href="#关于该路由泄露防御与检测方法的安全考虑" class="headerlink" title="关于该路由泄露防御与检测方法的安全考虑"></a>关于该路由泄露防御与检测方法的安全考虑</h2><ul><li>BGP Role 的错误配置可能会影响路由的传播。例如，如果下游（即面向 Customer ）的对等链路被错误配置为 Provider 或 Peer 角色，向这个方向传播的路由会被限制；如果一个上游 Provider 被错误配置为 Customer ，可能会导致其传播从其它 Provider 或 Peer 收到的路由。但 BGP 商业关系一般由人为制定与配置，使得这种错误配置发生的机率不大。</li><li>非常不建议将 BGP Role 严格协商机制作为默认配置，这可能会导致 eBGP 会话无法启动的情况。</li><li>删除或改变 OTC 属性值可能会成为一种新的主动路由泄露攻击的方式</li><li>不鼓励无条件在从 Customer 到 Provider 的链路上部署 OTC 属性，因为这会限制路由的传播。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文献 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RFC Document </tag>
            
            <tag> BGP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Golang 的函数类型实现接口</title>
      <link href="/2022/10/4182d7dd.html"/>
      <url>/2022/10/4182d7dd.html</url>
      
        <content type="html"><![CDATA[<p>在对 Gin 框架和 Golang net&#x2F;http 包进行源码分析对比的时候，在 net&#x2F;http.server 发现了以下让我难以理解的参数传递。作为 Golang 初学者，确实是很难理解这种将函数类型作为接口实现的多态模式。在此处记录一下以防以后踩坑。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>http 包中的服务多路复用器（ServeMux）需要确定对于一个特定 URL 来说，应当调用哪个函数来处理它发来的请求。其中有这样一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="type">string</span>, handler <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))   <span class="comment">// 请注意此行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的 <code>mux.Handle()</code> 函数原型是 <code>ServeMux.Handle()</code> ，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handle(pattern <span class="type">string</span>, handler Handler) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Handler</code> 类型是一个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HandlerFunc</code> 是一个<strong>函数</strong>类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>经常写 Python，Java 的我看到 <code>HandleFunc()</code> 函数需要调用 <code>ServeMux.Handle()</code> ，立即就会想到实现一个类，该类实现了 <code>Handler</code> 接口，即拥有一个自己的 <code>ServeHTTP(ResponseWriter, *Request)</code> 成员函数。然后将该类作为参数传入 <code>ServeMux.Handle()</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我想到的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass 实现了 Handler 接口</span></span><br><span class="line"><span class="keyword">type</span> MyClass <span class="keyword">struct</span>&#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MyClass)</span></span> ServeHTTP(ResponseWriter, *Request)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="type">string</span>, ...) &#123;</span><br><span class="line">    ...</span><br><span class="line">mux.Handle(pattern, <span class="built_in">new</span>(MyClass))   <span class="comment">// 请注意此行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然我这种想法在业务层面是不正确的，不应该把处理服务的业务耦合到通信层面的代码上。但我更无法理解的是，在经过 <code>HandlerFunc</code> 类型的类型转换后，<code>HandleFunc()</code> 函数的参数 <code>handler</code> （这个参数可能是一个有两个类型为 <code>ResponseWriter, *Request</code> 的参数的命名函数、匿名函数或闭包）竟然能够作为接口 <code>Handler</code> 的一个实现传入函数 <code>ServeMux.Handle()</code>。</p><p>再看 <code>HandlerFunc</code> 类型的定义。 <code>HandlerFunc</code> 类型是一个函数，具有和 <code>ServeHTTP()</code> 函数一样的参数。这个类型也拥有一个 <code>ServeHTTP()</code> 函数的实现（这样就实现了 <code>Handler</code> 接口），在这个实现中， <code>HandlerFunc</code> 类型自己调用了自己。</p><p>简而言之， <code>HandlerFunc</code> 这个类型的函数实现了接口 <code>Handler</code>。一个函数能够实现接口，这是我在学习 Go 以前无法想象的，我的刻板印象认为一定只有类才能实现接口。这次的发现让我对于 Go 在面向对象方面与其它语言的不同有了更深的了解。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我们知道了在 Go 中，一个函数能实现接口，但它是如何实际应用的呢？在我学长的<a href="https://siegelion.cn/2022/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E6%98%AF%E6%80%8E%E6%A0%B7%E6%9E%84%E5%BB%BAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84/#%E5%A4%84%E7%90%86%E5%99%A8%E5%87%BD%E6%95%B0">一篇博客</a>里有更详细的讲解，我引用其中的内容做出说明：</p><ul><li><p><strong>结构体实现接口</strong>：在这个例子中，用了我最熟悉的通过类（ <code>HelloHandler</code> 结构体）实现接口（ <code>Handler</code>接口，它需要实现 <code>ServeHTTP()</code> 函数 ）的方式，完成了将服务绑定到 URL <code>127.0.0.1:8080/hello</code> 上的功能。运行并访问 <code>127.0.0.1:8080/hello</code> 后浏览器会输出 <strong>Hello</strong> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HelloHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    severMux := http.NewServeMux()</span><br><span class="line">    helloHandler := &amp;HelloHandler&#123;&#125;</span><br><span class="line">    severMux.Handle(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line"></span><br><span class="line">    server := &amp;http.Server&#123;</span><br><span class="line">        Addr: <span class="string">&quot;127.0.0.1:8080&quot;</span>,</span><br><span class="line">        Handler: severMux,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数体实现接口</strong>：在该例中，不需要一个实现了 <code>Handler</code> 接口的类传入服务多路复用器，而是直接将业务函数传入 <code>severMux.HandleFunc</code> 中。代码更加简洁直观，并且实现了完全相同的功能，在访问 <code>127.0.0.1:8080/hello</code> 后仍然能输出 <strong>Hello</strong> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    severMux := http.NewServeMux()</span><br><span class="line">    severMux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, sayHello)</span><br><span class="line"></span><br><span class="line">    server := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">&quot;127.0.0.1:8080&quot;</span>,</span><br><span class="line">        Handler: severMux,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用匿名函数后代码能进一步简化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    severMux := http.NewServeMux()</span><br><span class="line">    severMux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    server := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">&quot;127.0.0.1:8080&quot;</span>,</span><br><span class="line">        Handler: severMux,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 微服务实战 - 4. Gin 框架</title>
      <link href="/2022/10/d0824a26.html"/>
      <url>/2022/10/d0824a26.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/gin-gonic/gin">Gin</a> 是一个 Golang 的 web 框架，封装使用简单，目前被广泛使用。实际上对于 Golang 而言，web 框架的依赖要远比 Python，Java 之类的要小。因为其自身的 <code>net/http</code> 足够简单，性能也非常不错。那么包括 Gin 在内的各种 Go web 框架出现的意义仅仅只是为了开发方便吗？关于这方面更深层次的探讨可以看<a href="https://zhuanlan.zhihu.com/p/435264306">这篇文章</a>，同时也可以参考我学长博客中的<a href="https://siegelion.cn/2022/05/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E6%98%AF%E6%80%8E%E6%A0%B7%E6%9E%84%E5%BB%BAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84/">相关内容</a>。</p><p>这里同时推荐一个简洁实用的 <a href="https://www.kancloud.cn/shuangdeyu/gin_book">Gin 中文文档</a>。</p><p>简而言之，在 Http 连接建立方面，Golang 原生的 <code>net/http</code> 只用了一个简单的服务多路复用器，通过匹配 URL 提供对应的请求响应服务，几乎无法处理当下规范的 <strong>RESTful</strong> Web 接口；而 Gin 框架则以 <strong>前缀树</strong> 作为数据结构，使用了多棵 <strong>路由树</strong> 来实现响应服务与对应 Http 请求的匹配，使得 Gin 框架下的 Http 通信在有更丰富的功能性的前提下，获得了更高的性能。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>创建 Gin 项目，控制台输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>在 <code>.go</code> 文件中加入依赖</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 初始化路由/初始化 web 引擎</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 做路由匹配，通过匿名函数</span></span><br><span class="line">router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">_, err := context.Writer.WriteString(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动运行，在 127.0.0.1:8080</span></span><br><span class="line">err := router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序启动后，浏览器访问 <code>127.0.0.1:8080</code> 将会输出 **hello world!**。</p><h2 id="将-Gin-框架接入-Consul-服务发现与-Go-Micro-微服务"><a href="#将-Gin-框架接入-Consul-服务发现与-Go-Micro-微服务" class="headerlink" title="将 Gin 框架接入 Consul 服务发现与 Go-Micro 微服务"></a>将 Gin 框架接入 Consul 服务发现与 Go-Micro 微服务</h2><p>通过注册到 Consul 服务发现，无论是服务前端还是微服务端都仅需要知道 Consul 服务器的信息并将服务在其上进行注册。除了服务名， Gin 服务前端和 Go-Micro 微服务端是无法相互了解的（双方都不知道对方的 ip 地址和端口号）。接下来将通过一个例子来说明这是如何实现的。</p><h3 id="Consul-服务发现"><a href="#Consul-服务发现" class="headerlink" title="Consul 服务发现"></a>Consul 服务发现</h3><p>具体配置操作详见 <a href="https://alrisha.cn/2022/10/59b8323d.html">Golang 微服务实战 - 2. Consul</a> 。在这个例子中， <strong>必须</strong> 首先启动 Consul 服务发现。在控制台中输入 <code>consul agent -dev</code> 即可。然后，在浏览器的 <code>http://127.0.0.1:8500/ui/dc1/services</code> 查看 Consul 仪表板</p><h3 id="Go-Micro-微服务"><a href="#Go-Micro-微服务" class="headerlink" title="Go-Micro 微服务"></a>Go-Micro 微服务</h3><p>在 <a href="https://alrisha.cn/2022/10/2ec7f8ee.html">Golang 微服务实战 - 3. Go-Micro 框架</a> 的基础上，修改 Go-Micro 框架服务端代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;Micro-Learning/handler&quot;</span>  <span class="comment">// 导入 handler 文件夹内容</span></span><br><span class="line">pb <span class="string">&quot;Micro-Learning/proto&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-micro/plugins/v4/registry/consul&quot;</span></span><br><span class="line"><span class="string">&quot;go-micro.dev/v4&quot;</span></span><br><span class="line"><span class="string">&quot;go-micro.dev/v4/logger&quot;</span></span><br><span class="line"><span class="string">&quot;go-micro.dev/v4/registry&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">service = <span class="string">&quot;micro-learning&quot;</span></span><br><span class="line">version = <span class="string">&quot;latest&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">consulReg := consul.NewRegistry(registry.Addrs(<span class="string">&quot;127.0.0.1:8500&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create service</span></span><br><span class="line">srv := micro.NewService()</span><br><span class="line">srv.Init(</span><br><span class="line">micro.Name(service),</span><br><span class="line">micro.Registry(consulReg), <span class="comment">// 将服务注册到 consul</span></span><br><span class="line">micro.Version(version),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register handler</span></span><br><span class="line">  <span class="comment">// handler.MicroLearning 在 hanler 文件夹下定义</span></span><br><span class="line"><span class="keyword">if</span> err := pb.RegisterMicroLearningHandler(srv.Server(), <span class="built_in">new</span>(handler.MicroLearning)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Run service</span></span><br><span class="line"><span class="keyword">if</span> err := srv.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go-Micro 框架为了符合 <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> 标准，将业务代码放在了 hanler 文件夹下，其中的业务代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go-micro.dev/v4/logger&quot;</span></span><br><span class="line"></span><br><span class="line">pb <span class="string">&quot;Micro-Learning/proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MicroLearning <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MicroLearning)</span></span> Call(ctx context.Context, req *pb.CallRequest, rsp *pb.CallResponse) <span class="type">error</span> &#123;</span><br><span class="line">logger.Infof(<span class="string">&quot;Received MicroLearning.Call request: %v&quot;</span>, req)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received MicroLearning.Call request: %v\n&quot;</span>, req)</span><br><span class="line">rsp.Msg = <span class="string">&quot;Hello &quot;</span> + req.Name</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行 <code>main.go</code> ，控制台出现如下信息说明运行成功，且服务已经注册到了 Consul。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2022-10-20 20:21:50  file=Micro-Learning/main.go:35 level=info Starting [service] micro-learning</span><br><span class="line">2022-10-20 20:21:50  file=v4@v4.9.0/service.go:96 level=info Transport [http] Listening on [::]:55163</span><br><span class="line">2022-10-20 20:21:50  file=v4@v4.9.0/service.go:96 level=info Broker [http] Connected to 127.0.0.1:55164</span><br><span class="line">2022-10-20 20:21:50  file=server/rpc_server.go:832 level=info Registry [consul] Registering node: micro-learning-160dc67a-5352-44b1-9b03-84f31f53e889</span><br></pre></td></tr></table></figure><p>在 Consul 仪表板 <code>http://127.0.0.1:8500/ui/dc1/services</code> 可以看到 <strong>micro-learning</strong> 服务已经被注册了。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/20/4nrCU2GziBOT9hg.png" alt="micro-learning 已注册到 Consul 上"></p><h3 id="Gin-服务前端"><a href="#Gin-服务前端" class="headerlink" title="Gin 服务前端"></a>Gin 服务前端</h3><p>首先，必须将 Go-Micro 微服务部分项目文件中的文件夹 <code>/proto/</code> 直接拷贝到 Gin 项目文件夹中，<strong>不能</strong>自己再重写或者重新编译 protobuf ，因为服务前端和微服务端二者要连通， protobuf 必须完全相同。虽然复制黏贴的操作看起来很蠢， <del>事实上确实如此，</del> 但在实际生产环境中一般都是服务前端直接在 <code>import</code> 中调用微服务端所在 git 仓库的 protobuf ，此处为了测试和演示方便直接使用复制黏贴即可。</p><p>在 <a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">一个简单的例子</a> 的基础上修改代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">pb <span class="string">&quot;Gin-Web/proto&quot;</span></span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-micro/plugins/v4/registry/consul&quot;</span></span><br><span class="line"><span class="string">&quot;go-micro.dev/v4&quot;</span></span><br><span class="line"><span class="string">&quot;go-micro.dev/v4/client&quot;</span></span><br><span class="line"><span class="string">&quot;go-micro.dev/v4/registry&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallRemote</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化服务发现 Consul</span></span><br><span class="line">consulReg := consul.NewRegistry(registry.Addrs(<span class="string">&quot;127.0.0.1:8500&quot;</span>))</span><br><span class="line">srv := micro.NewService()</span><br><span class="line">srv.Init(</span><br><span class="line">micro.Client(client.NewClient()),</span><br><span class="line">micro.Registry(consulReg), <span class="comment">// 将服务注册到 consul</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">microLearningService := pb.NewMicroLearningService(<span class="string">&quot;micro-learning&quot;</span>, srv.Client())</span><br><span class="line">callResponse, err := microLearningService.Call(context.TODO(), &amp;pb.CallRequest&#123;Name: <span class="string">&quot;Kevin&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">respString := callResponse.GetMsg()</span><br><span class="line">_, err = ctx.Writer.WriteString(respString)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 初始化路由/初始化 web 引擎</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 做路由匹配</span></span><br><span class="line">router.GET(<span class="string">&quot;/&quot;</span>, CallRemote)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动运行</span></span><br><span class="line">err := router.Run(<span class="string">&quot;:8090&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接运行 Gin 服务前端，在浏览器中访问 <code>http://127.0.0.1:8090/</code> ，输出 <code>Hello Kevin</code> 则说明调用成功。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 微服务实战 - 3. Go-Micro 框架</title>
      <link href="/2022/10/2ec7f8ee.html"/>
      <url>/2022/10/2ec7f8ee.html</url>
      
        <content type="html"><![CDATA[<p>Go-Micro 是分布式系统的开发框架。 由 Micro 公司开发，几经波折后发展到了 v4 版本（详见<a href="https://zhuanlan.zhihu.com/p/299548231">Go-Micro 不能用了？关于 Go-Micro 的一些说明</a>），<a href="https://github.com/go-micro/go-micro">Github 仓库地址点此</a>。请注意，现在普遍的 Go-Micro 框架并非指该仓库 <a href="https://github.com/micro/micro">https://github.com/micro/micro</a> ，该框架是一个云原生开发平台而非微服务框架。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>下文将默认安装以下所有组件</p></blockquote><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>我使用的是 go 1.9 版本，最新的 go-micro 框架版本是 4.9.0 ，因此只需要在项目的 <code>go.mod</code> 内的 <code>require</code> 项里添加如下语句即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>-micro.dev/v4 v4<span class="number">.9</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h3><p>如果需要，还可以额外安装控制台命令。可以在<a href="https://github.com/go-micro/cli">官方文档</a>中查看详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/go-micro/cli/cmd/go-micro@latest</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行输入 <code>go-micro</code> 验证是否成功安装。</p><h3 id="仪表板工具"><a href="#仪表板工具" class="headerlink" title="仪表板工具"></a>仪表板工具</h3><p>也可以安装 Go-Micro Web 仪表板，方便后续测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/go-micro/dashboard@latest</span><br></pre></td></tr></table></figure><p>直接在命令行输入 <code>dashboard</code> 启动 Go-Micro Web 仪表板。浏览器访问 <code>http://127.0.0.1:8082/</code> ，输入用户名：<strong>admin</strong>，密码：<strong>micro</strong>，即可进入仪表板</p><p>仪表板配置见<a href="https://github.com/go-micro/dashboard">官方文档</a>。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>在指定目录下，控制台输入以下指令将创建名字为 <strong>Micro-Learning</strong> 的 Go-Micro 服务端项目模板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-micro new service Micro-Learning</span><br></pre></td></tr></table></figure><blockquote><p>此处仅演示 Go-Micro 框架的服务端模板创建。关于客户端，接下来将使用另一个微服务框架 Gin 实现，因此不在此说明</p></blockquote><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>控制台输入 <code>tree /f</code> 指令，输出项目模板文件树如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">│   .dockerignore</span><br><span class="line">│   .gitignore</span><br><span class="line">│   Dockerfile</span><br><span class="line">│   go.mod</span><br><span class="line">│   main.go</span><br><span class="line">│   Makefile</span><br><span class="line">│</span><br><span class="line">├───.idea</span><br><span class="line">│       配置文件略</span><br><span class="line">│</span><br><span class="line">├───handler</span><br><span class="line">│       Micro-Learning.go</span><br><span class="line">│</span><br><span class="line">└───proto</span><br><span class="line">        Micro-Learning.proto</span><br></pre></td></tr></table></figure><ul><li>main.go: 项目的入口文件。</li><li>handler&#x2F;: 处理 grpc 实现的接口。对应实现接口的子类，都放置在 handler 中。</li><li>proto&#x2F;: 预生成的 protobuf 文件。</li><li>Dockerfile: 部署微服务使用的 Dockerfile</li><li>Makefile: 编译文件。最常用于快速编译 protobuf 文件。</li></ul><blockquote><p><strong>Tips</strong>: Windows 下如何使用 make 指令？</p><p>使用 Win 11&#x2F;Win 10 自带的 Windows 包管理工具 <strong>winget</strong> 。输入指令 <code>winget install GnuWin32.Make -l &quot;&#123;Path&#125;&quot;</code> ，运行即可安装，其中 <strong>Path</strong> 是你想安装 Make 的目录（绝对路径）。安装完成后将  <strong>Path</strong> 目录下的 <strong>bin</strong> 目录添加进环境变量，重启控制台即可使用 Make 。</p></blockquote><p>执行以下 make 指令编译环境配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make init</span><br><span class="line">make proto</span><br></pre></td></tr></table></figure><p>这两个指令将初始化必要环境并编译 protocol buffer 文件</p><h2 id="使用-consul-服务发现"><a href="#使用-consul-服务发现" class="headerlink" title="使用 consul 服务发现"></a>使用 consul 服务发现</h2><p>Go-Micro 框架默认自带服务发现：<strong>mdns</strong>，但功能不够强大，需要使用 consul 提供服务发现。在 <code>go.mod</code> 文件中添加以下 Go-Micro 框架的 consul 依赖</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/<span class="keyword">go</span>-micro/plugins/v4/registry/consul v1<span class="number">.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>在上文创建的 Go-Micro 服务端模板项目中的 <code>main.go</code> 中修改以下部分代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consul 服务发现服务器的地址，可以有多个（对应 consul 集群）</span></span><br><span class="line"><span class="comment">// 8500 是 consul 默认接口，生产环境中一般不这样使用</span></span><br><span class="line"><span class="comment">// 单机调试时记得在控制台启动 consul</span></span><br><span class="line">consulReg := consul.NewRegistry(registry.Addrs(<span class="string">&quot;127.0.0.1:8500&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create service</span></span><br><span class="line">srv := micro.NewService()</span><br><span class="line">srv.Init(</span><br><span class="line">micro.Name(service),</span><br><span class="line">micro.Registry(consulReg), <span class="comment">// 将服务注册到 consul</span></span><br><span class="line">micro.Version(version),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Micro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 函数装饰器 @functools.lru_cache</title>
      <link href="/2022/10/633fe4e4.html"/>
      <url>/2022/10/633fe4e4.html</url>
      
        <content type="html"><![CDATA[<p>在做 LeetCode <a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a>时，通过记忆化函数法解题总是超时。经过了解，问题主要出在递归调用耗时太多，在 Python 语言下需要使用函数装饰器 <code>@functools.lru_cache</code> ，该装饰器<strong>为函数提供缓存功能，当某一函数的两次调用参数均一致，则直接返回前一次调用的结果</strong>。以下是修改后的 AC 答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用函数装饰器</span></span><br><span class="line">        <span class="keyword">import</span> functools </span><br><span class="line">        <span class="comment"># @functools.lru_cache(None)</span></span><br><span class="line"><span class="meta">        @functools.cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recall</span>(<span class="params">string: <span class="built_in">str</span>, ptr_start: <span class="built_in">int</span>, ptr_end: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="keyword">if</span> ptr_start == <span class="built_in">len</span>(string):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> ptr_end &lt;= <span class="built_in">len</span>(string):</span><br><span class="line">                <span class="keyword">if</span> string[ptr_start:ptr_end] <span class="keyword">in</span> wordDict <span class="keyword">and</span> recall(string, ptr_end, ptr_end + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">                ptr_end += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> recall(s, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><p><a href="https://docs.python.org/zh-cn/3/library/functools.html">官方文档</a>是这么形容这个函数装饰器的：</p><blockquote><p><code>@functools.lru_cache(user_function)</code></p><p><code>@functools.lru_cache(maxsize=128, typed=False)</code></p><p>一个为函数提供缓存功能的装饰器，缓存 maxsize 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I&#x2F;O函数的调用时间。</p></blockquote><p>由于使用了字典存储缓存，所以被装饰函数的固定参数和关键字参数必须是可哈希的。例如 list、dict 等数据结构都无法被 hash，因此被装饰函数不能拥有这些类型的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个函数无法使用 lru_cache 装饰器，因为有不可 hash 的字典类参数 map</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recall</span>(<span class="params">string: <span class="built_in">str</span>, ptr_start: <span class="built_in">int</span>, ptr_end: <span class="built_in">int</span>, <span class="built_in">map</span>: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">bool</span>:</span><br></pre></td></tr></table></figure><p>对于缓存容量，文档有如下表述</p><blockquote><p><strong>LRU（最久未使用算法）缓存</strong>在最近的调用是即将到来的调用的最佳预测值时性能最好（例如，新闻服务器上最热门文章倾向于每天更改）。 缓存的大小限制可确保缓存不会在长期运行进程如网站服务器上无限制地增长。</p><p>如果 maxsize 设为 None，LRU 特性将被禁用且缓存可无限增长。</p></blockquote><p>这意味着，在需要 LRU 功能的业务逻辑中使用该装饰器时应当注意设置缓存大小，一般设为2的多次幂性能较高。但在刷题，设计算法时，直接传入 <code>None</code> 参数更好，因为大部分算法题不需要使用到 LRU 特性，且无限的缓存容量能保证高效处理大数据量的用例。并且官方文档指出，不考虑使用 LRU 功能的前提下，使用 <code>None</code> 参数的装饰器性能更好：</p><blockquote><p>因为它不需要移出旧值，所以比带有大小限制的 lru_cache() 更小更快。</p></blockquote><p>如果采用 3.9 版本以上的 Python 编译器，则建议使用 <code>@functools.cache</code> ，它与 <code>@functools.lru_cache(None)</code> 是等价的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Python 源码分析二分查找落点问题</title>
      <link href="/2022/10/6b048c29.html"/>
      <url>/2022/10/6b048c29.html</url>
      
        <content type="html"><![CDATA[<p>对有序数据来说，二分查找是一种简单高效的搜索方法。但即使在各种各样的背景下写过许多次的二分查找算法，二分查找的落点问题仍然常常让我感到困惑。举例来说，所谓二分查找的落点问题，就是在一个升序序列中，所查找的下标应当在目标元素的最左边还是最右边。仅需要改变 if 判断语句的一个等号结果就会大不相同。</p><p>实际上网络上已经有许多详尽的解释和参考教程解释如何在编写二分查找时精确掌控其<strong>落点</strong>。但我认为如果要加深印象，以标准库里的源码作为例子能更深入了解二分查找的基本原理。</p><h2 id="bisect-库"><a href="#bisect-库" class="headerlink" title="bisect 库"></a>bisect 库</h2><p>关于二分查找&#x2F;二分插入的 Python 官方库是 <a href="https://docs.python.org/zh-cn/3/library/bisect.html?highlight=bisect#module-bisect">bisect</a>，其<a href="https://github.com/python/cpython/blob/3.10/Lib/bisect.py">源码</a>位于 Github 上。</p><blockquote><p>bisect 库默认输入序列是升序的</p></blockquote><p>在 bisect 库中，二分插入实际上是二分查找的封装。因此以下将着重分析右落点二分查找 <code>bisect_right</code> 和左落点二分查找 <code>bisect_left</code> 。</p><p>以下的例子体现了两种函数的不同：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/3wQJhDfLOBnmzA1.png" alt=" bisect 库两种二分查找的区别"></p><h3 id="二分查找源码"><a href="#二分查找源码" class="headerlink" title="二分查找源码"></a>二分查找源码</h3><p>源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bisect_right</span>(<span class="params">a, x, lo=<span class="number">0</span>, hi=<span class="literal">None</span>, *, key=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt;= x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(i, x) will</span></span><br><span class="line"><span class="string">    insert just after the rightmost x already there.</span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;lo must be non-negative&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># Note, the comparison uses &quot;&lt;&quot; to match the</span></span><br><span class="line">    <span class="comment"># __lt__() logic in list.sort() and in heapq.</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; a[mid]:</span><br><span class="line">                hi = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; key(a[mid]):</span><br><span class="line">                hi = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bisect_left</span>(<span class="params">a, x, lo=<span class="number">0</span>, hi=<span class="literal">None</span>, *, key=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the index where to insert item x in list a, assuming a is sorted.</span></span><br><span class="line"><span class="string">    The return value i is such that all e in a[:i] have e &lt; x, and all e in</span></span><br><span class="line"><span class="string">    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(i, x) will</span></span><br><span class="line"><span class="string">    insert just before the leftmost x already there.</span></span><br><span class="line"><span class="string">    Optional args lo (default 0) and hi (default len(a)) bound the</span></span><br><span class="line"><span class="string">    slice of a to be searched.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lo &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;lo must be non-negative&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> hi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        hi = <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment"># Note, the comparison uses &quot;&lt;&quot; to match the</span></span><br><span class="line">    <span class="comment"># __lt__() logic in list.sort() and in heapq.</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> a[mid] &lt; x:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> key(a[mid]) &lt; x:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">    <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure><h3 id="为何二分查找的左右落点不同"><a href="#为何二分查找的左右落点不同" class="headerlink" title="为何二分查找的左右落点不同"></a>为何二分查找的左右落点不同</h3><p>观察源码能发现，两个函数的主要差距在如下部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bisect_right</span></span><br><span class="line"><span class="keyword">if</span> x &lt; a[mid]:                </span><br><span class="line">    hi = mid            </span><br><span class="line"><span class="keyword">else</span>:                </span><br><span class="line">    lo = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bisect_left</span></span><br><span class="line"><span class="keyword">if</span> a[mid] &lt; x:</span><br><span class="line">    lo = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hi = mid</span><br></pre></td></tr></table></figure><p>实际上二者的差异就在于，当 <code>a[mid] == x</code> 时，应当向高半区迭代还是向低半区迭代。</p><ul><li>对于希望落点在目标元素右侧的二分查找，当 <code>a[mid] == x</code> 时，应当向它的右侧查找，即 <code>lo = mid + 1</code> 。这意味着接下来的二分查找需要向比 x 更大的那些数迭代，这样就能保证 x 一定在最后结果的前面。注意到由于 + 1的缘故，查找结果并不是在最后一个目标元素上，而是指向它后一个元素。</li><li>类似的，对于希望落点在目标元素左侧的二分查找，当 <code>a[mid] == x</code> 时，应当向它的左侧查找，即 <code>hi = mid</code> 。这意味着接下来的二分查找需要向比 x 更小的那些数迭代，这样就能保证 x 一定在最后结果的后面</li></ul><h3 id="bisect-源码带来的一些提醒"><a href="#bisect-源码带来的一些提醒" class="headerlink" title="bisect 源码带来的一些提醒"></a>bisect 源码带来的一些提醒</h3><h4 id="不要忽略-mid-下标的元素"><a href="#不要忽略-mid-下标的元素" class="headerlink" title="不要忽略 mid 下标的元素"></a>不要忽略 mid 下标的元素</h4><p>注意到 bisect 库中，无论哪种二分查找，都没有出现 <code>hi = mid - 1</code> 的写法。这是因为如果二分查找中同时使用 <code>lo = mid + 1</code> 和 <code>hi = mid - 1</code> ，可能会忽略 mid 下标的元素，导致二分查找结果不正确。</p><h4 id="原始序列中如果没有目标元素-x"><a href="#原始序列中如果没有目标元素-x" class="headerlink" title="原始序列中如果没有目标元素 x"></a>原始序列中如果没有目标元素 x</h4><p>如果原始序列中没有目标元素 x ，查找结果会怎么样呢？以下示例能解释 bisect 库是怎么做的。</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/fa641u8Wx7ZCpF5.png" alt="序列中没有目标元素时的二分查找"></p><p>示例在升序序列 <code>l = [1,2,4,7,8]</code> 中查找元素6的位置。两种二分查找方法都返回了3，即元素7所在的位置。这意味着 bisect 库的二分查找在无法找到目标元素位置的时候，将在所有比目标值<strong>大</strong>的元素中，返回最接近目标元素大小的元素的下标。</p><p>这实际上是 <code>lo = mid + 1</code> 语句导致的。如果把代码改为 <code>lo = mid</code> 并且 <code>hi = mid - 1</code> ，那么在无法找到目标元素位置的时候，将在所有比目标值<strong>小</strong>的元素中，返回最接近目标元素大小的元素的下标。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>存在多个相同目标元素，结果在左在右看等号；不存在目标元素，结果在左在右看 + 1</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 微服务实战 - 2. Consul</title>
      <link href="/2022/10/59b8323d.html"/>
      <url>/2022/10/59b8323d.html</url>
      
        <content type="html"><![CDATA[<p>第二部分需要提到微服务架构中必不可少的功能：服务发现。我在先前做的 <a href="https://github.com/FAWC438/Distributed-Online-Car-Hailing-Platform">Spring Cloud 项目</a>中使用过 <a href="https://github.com/Netflix/eureka">Eureka</a> 作为服务发现框架。但现在 Eureka 已经停更一年多，且使用 Go 编写的 Consul 更适合在 Go 环境微服务分布式系统上使用。</p><p>以下列出几篇文章，这几篇文章说明了有关服务发现的相关概念，并对当下热门服务发现框架进行了一些对比：<a href="https://blog.csdn.net/jiulanhao/article/details/82494087">《什么是服务发现》</a>，<a href="https://blog.51cto.com/u_13270164/3036147">《服务发现框架Consul的使用》</a>，<a href="https://zhuanlan.zhihu.com/p/161277955?utm_id=0">深入了解服务注册与发现</a></p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>什么是 Consul ？官方网站的解释如下：</p><blockquote><p>HashiCorp Consul 是一个网络服务解决方案，使团队能够管理服务之间、本地环境、多云环境以及运行时之间的安全网络连接。Consul 提供服务发现、服务网格、流量管理和网络基础设施设备的自动更新。您可以在单个 Consul 部署实例中单独或一起使用这些功能。</p></blockquote><h3 id="安装-Consul"><a href="#安装-Consul" class="headerlink" title="安装 Consul"></a>安装 Consul</h3><p>在<a href="https://www.consul.io/downloads">官方网站</a>下载二进制文件，随后解压至你所指定的文件目录。解压完成后，仅会得到一个二进制文件<code>consul</code>（Windows 下则是<code>consul.exe</code>）。将该二进制文件所在目录添加进系统环境变量，并在控制台输入指令<code>consul</code>以检查安装是否完成。</p><h3 id="Consul-常用命令"><a href="#Consul-常用命令" class="headerlink" title="Consul 常用命令"></a>Consul 常用命令</h3><blockquote><p>全部 Consul 控制台命令详情请使用<code>consul -h</code>查看</p></blockquote><p>本项目最常用的指令是<code>consul agent</code>，其主要功能为运行一个 consul 代理。<code>consul agent</code>最常使用的功能如下：</p><ul><li><code>-h</code> 查看<code>consul agent</code>的所有额外命令</li><li><code>-bind 0.0.0.0</code> 指定 consul 所在机器的 IP 地址。默认值：0.0.0.0。注意，bind 后<strong>没有等号</strong>。</li><li><code>-http-port=8500</code> consul 自带一个 web 访问的默认端口：8500</li><li><code>-client=127.0.0.1</code> 表明哪些机器可以访问 consul ，默认为本机。0.0.0.0 则表示 所有其它机器均可访问。</li><li><code>-config-dir=path</code> 该选项用于指定service的配置文件和检查定义所在的位置。通常会指定为<code>某一个路径/consul.d</code>（通常情况下，<code>.d</code>表示一系列配置文件存放的目录）</li><li><code>-config-file</code> 指定一个要装载的配置文件。该选项可以配置多次，进而配置多个配置文件。</li><li><code>-data-dir=path</code> 该选项用于指定 agent 储存状态的数据目录，这是所有 agent 都必须的，对于 server 尤其重要，因为他们必须持久化集群的状态。</li><li><code>-dev</code> 开发者模式，该选项用于创建一个开发环境下的server节点，该参数配置下，不会有任何持久化操作，即不会有任何数据写入到磁盘。dev模式仅仅是在开发和测试环境中使用，不能用于生产环境。</li><li><code>-bootstrap-expect</code> 该选项用于通知 consul server 类型节点，指定集群的 server 节点个数，该参数是为了延迟选举启动，直到全部的节点启动完毕以后再进行启动。</li><li><code>-node=hostname</code> 该 node 选项用于指定节点在集群中的名称，该名称在集群中需要是唯一的，推荐直接使用机器的 IP。</li><li><code>-rejoin</code> consul 启动的时候，设置其所加入到的 consul 集群</li><li><code>-server</code> 以服务方式开启 consul ，允许其他的 consul 连接到开启的 consul上 （形成集群）。如果不加 -server， 表示以 “客户端” 的方式开启。不能被连接。每个数据中心（DC）的 server 数量推荐3到5个。所有的 server 节点加入到集群后要经过选举，采用 raft 一致性算法来确保数据操作的一致性。</li><li><code>-client</code> 该参数用于指定 consul 界定为 client 节点类型。</li><li><code>-ui</code> 可以使用 web 页面（进入该页面的 IP 地址与<code>-bind</code>命令有关，端口与<code>-http-port</code>命令有关）来查看服务发现的详情</li><li><code>-dc</code> dc 是 datacenter 的简称，该选项用于指定节点加入的 dc 实例。</li></ul><p>其它 consul 常用指令：</p><ul><li><code>consul members</code> 查看集群中的成员。</li><li><code>consul info</code> 查看当前 consul 的 IP 等其它信息。</li><li><code>consul join</code> 该命令的作用是将 agent 加入到 consul 的集群当中。当新启动一个 agent 节点后，往往需要指定节点需要加入到特定的 consul 集群中，此时使用 join 命令进行指定。</li><li><code>consul reload</code> 重启 consul</li><li><code>consul leave</code> 优雅的关闭 consul <del>不优雅指 ctrl + c</del>。</li></ul><h3 id="使用-Consul-注册服务"><a href="#使用-Consul-注册服务" class="headerlink" title="使用 Consul 注册服务"></a>使用 Consul 注册服务</h3><p>运行以下命令启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir=d:/code/Consul/consul_data -node=n1 -bind 127.0.0.1 -ui -rejoin -config-dir=d:/code/Consul/consul.d/ -client 0.0.0.0</span><br></pre></td></tr></table></figure><p>按以下步骤操作</p><ol><li><p>进入配置文件路径 <code>D:\code\Consul\consul_cfg</code></p></li><li><p>创建 json 文件 <code>web.json</code></p></li><li><p>在该文件中，填写服务信息。</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Faceid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;rails&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">9000</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>Json 配置文件详细配置选项参见<a href="https://www.consul.io/docs/agent/config/config-files">官方文档</a></p></blockquote></li><li><p>重新启动 consul</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir=d:/code/Consul/consul_data -node=n1 -bind 127.0.0.1 -ui -rejoin -config-dir=d:/code/Consul/consul.d/ -client 0.0.0.0</span><br></pre></td></tr></table></figure></li><li><p>查询服务</p><ol><li><p>浏览器查看：</p><p> 直接在浏览器输入<code>http://127.0.0.1:8500/</code>，进入 consul 仪表板查看</p></li><li><p>终端命令查看：</p><p> 输入如下指令：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o d:/code/Consul/test.json 127.0.0.1:8500/v1/catalog/service/Faceid</span><br></pre></td></tr></table></figure><p> 在<code>d:/code/Consul/test.json</code>文件中读取数据即可</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;57bee4ce-9f8d-b68c-3fa3-5d21f98e65aa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;n1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Datacenter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dc1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;TaggedAddresses&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;lan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lan_ipv4&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;wan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;wan_ipv4&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;NodeMeta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;consul-network-segment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceKind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Faceid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Faceid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceTags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;rails&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceWeights&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Passing&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Warning&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceMeta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServicePort&quot;</span><span class="punctuation">:</span> <span class="number">9000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceSocketPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceEnableTagOverride&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceProxy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MeshGateway&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Expose&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ServiceConnect&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;CreateIndex&quot;</span><span class="punctuation">:</span> <span class="number">40</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ModifyIndex&quot;</span><span class="punctuation">:</span> <span class="number">40</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="Consul-健康检查"><a href="#Consul-健康检查" class="headerlink" title="Consul 健康检查"></a>Consul 健康检查</h3><p>在<code>/consul.d</code>路径下新建<code>health.json</code>，该配置会每隔5秒检查名为<code>Faceid</code>的 consul 服务在端口9000上的 http 请求是否有响应，如果超过1秒没有响应，则会判断该健康检查不通过。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Faceid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;rails&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;time&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">9000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;check&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HTTP API on port 9000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:9000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5s&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1s&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后通过以下命令启动 consul ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir=d:/code/Consul/consul_data -node=n1 -bind 127.0.0.1 -ui -rejoin -config-dir=d:/code/Consul/consul.d/ -config-file d:/code/Consul/consul.d/health.json -client 0.0.0.0</span><br></pre></td></tr></table></figure><p>在<code>http://127.0.0.1:8500/</code>下的仪表板能看到服务健康状况：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/DyF3JqbkMjZSKnw.png" alt="Faceid 的服务信息"></p><p>因为我们只是在测试 consul 的功能，并没有把微服务注册上去，因此这里的<code>HTTP API on port 9000</code>健康检查一定是不通过的，因为我们没有实现任何一个微服务实例能对该 consul 服务器每5秒发送一个 http 请求。同时，<code>Faceid</code> 服务的自检查则是能够通过 consul 健康检查的。</p><blockquote><p>除了上述例子中 http 实现健康检查外，还可以使用 <strong>脚本</strong>、<strong>tcp</strong>、<strong>ttl</strong> 等方式进行健康检查。</p></blockquote><h3 id="Consul-结合-gRPC"><a href="#Consul-结合-gRPC" class="headerlink" title="Consul 结合 gRPC"></a>Consul 结合 gRPC</h3><h4 id="基本-gRPC-远程调用"><a href="#基本-gRPC-远程调用" class="headerlink" title="基本 gRPC 远程调用"></a>基本 gRPC 远程调用</h4><h5 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h5><p>GoLand 项目中新建文件夹，创建 <code>ConsulClient.go</code> 、 <code>ConsulServer.go</code> 以及文件夹 <code>pb</code>。在文件夹 <code>pb</code> 中创建 protobuf 文件，取名为 <code>pb.person.proto</code> 。内容编写如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> pb;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 添加 rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">hello</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> sayHello (Person) <span class="keyword">returns</span> (Person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用语句 <code>protoc --go-grpc_out=./ *.proto --go_out=./ *.proto</code> 进行编译，生成两个文件：</p><ul><li><code>pb.person.pb.go</code></li><li><code>pb.person_grpc.pb.go</code></li></ul><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>在 <code>ConsulServer.go</code> 中编写如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;src/src/Consul/GRPC/pb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Children <span class="keyword">struct</span> &#123;</span><br><span class="line">*pb.UnimplementedHelloServer <span class="comment">// 向前兼容，即需要兼容未来的软件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Children)</span></span> SayHello(_ context.Context, p *pb.Person) (*pb.Person, <span class="type">error</span>) &#123;</span><br><span class="line">p.Name = <span class="string">&quot;hello &quot;</span> + p.Name</span><br><span class="line"><span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册服务</span></span><br><span class="line">grpcServer := grpc.NewServer()</span><br><span class="line">pb.RegisterHelloServer(grpcServer, <span class="built_in">new</span>(Children))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听</span></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8800&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(listener net.Listener)</span></span> &#123;</span><br><span class="line">err := listener.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(listener)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定监听</span></span><br><span class="line">err = grpcServer.Serve(listener)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意到在新版 gRPC 实现接口的类中，除了需要 protobuf 中定义的接口，还需要匿名嵌入（更通俗的方法讲就是<strong>继承</strong>） protobuf 生成的结构体（类） <code>Unimplemented****Server</code> ，其中 **** 是服务名。官方文档中对此的解释是保证程序的向前兼容（ forward compatible ），即保证程序能在未来的版本迭代中保持健壮性。</p><p>通俗一点讲，当版本迭代或业务需求改变，protobuf 的内容或是提供的 gRPC 服务发生改变的时候，原本该服务的 gRPC 接口实现将全部报错；但如果所有接口实现都继承了 <code>Unimplemented****Server</code> 类，那么程序不会报错（因为父类 <code>Unimplemented****Server</code> 一定实现了该接口），而是会根据 <code>Unimplemented****Server</code> 类执行一定的错误处理和报告，保证了程序的健壮性。</p></blockquote><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>在 <code>ConsulClient.go</code> 中编写如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"><span class="string">&quot;src/src/Consul/GRPC/pb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 拨号，即找到服务地址，需要 gRPC 忽略安全策略才能保证正常运行</span></span><br><span class="line">dial, err := grpc.Dial(<span class="string">&quot;:8800&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gRPC 客户端创建</span></span><br><span class="line">grpcClient := pb.NewHelloClient(dial)</span><br><span class="line">person := pb.Person&#123;</span><br><span class="line">Name: <span class="string">&quot;Kevin&quot;</span>,</span><br><span class="line">Age:  <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程调用方法</span></span><br><span class="line">newPerson, err := grpcClient.SayHello(context.TODO(), &amp;person)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(newPerson)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行服务端，再运行客户端，看到客户端输出 <code>name:&quot;hello Kevin&quot; age:22</code> 则说明运行成功。</p><h4 id="将-gRPC-服务注册到-Consul-上"><a href="#将-gRPC-服务注册到-Consul-上" class="headerlink" title="将 gRPC 服务注册到 Consul 上"></a>将 gRPC 服务注册到 Consul 上</h4><ol><li><p>修改服务端代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/hashicorp/consul/api&quot;</span></span><br><span class="line">    <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;src/src/Consul/GRPC/pb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Children <span class="keyword">struct</span> &#123;</span><br><span class="line">    *pb.UnimplementedHelloServer <span class="comment">// 向前兼容，即需要兼容未来的软件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Children)</span></span> SayHello(_ context.Context, p *pb.Person) (*pb.Person, <span class="type">error</span>) &#123;</span><br><span class="line">    p.Name = <span class="string">&quot;hello &quot;</span> + p.Name</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="comment">// 1. 创建 Consul 对象</span></span><br><span class="line">    consulObj, err := api.NewClient(api.DefaultConfig())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 告诉consul, 即将注册的服务的配置信息</span></span><br><span class="line">    reg := api.AgentServiceRegistration&#123;</span><br><span class="line">        <span class="comment">// 服务节点 id，用于区分提供同一服务的不同服务器</span></span><br><span class="line">        ID:      <span class="string">&quot;Faceid&quot;</span>,</span><br><span class="line">        Tags:    []<span class="type">string</span>&#123;<span class="string">&quot;grpc&quot;</span>, <span class="string">&quot;consul&quot;</span>&#125;,</span><br><span class="line">        <span class="comment">// 服务名</span></span><br><span class="line">        Name:    <span class="string">&quot;grpc And Consul&quot;</span>,</span><br><span class="line">        Address: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        Port:    <span class="number">8800</span>,</span><br><span class="line">        Check: &amp;api.AgentServiceCheck&#123;</span><br><span class="line">            <span class="comment">// 该服务节点 id下，服务自健康检查的 ID</span></span><br><span class="line">            CheckID:  <span class="string">&quot;consul grpc test&quot;</span>,</span><br><span class="line">            TCP:      <span class="string">&quot;127.0.0.1:8800&quot;</span>,</span><br><span class="line">            Timeout:  <span class="string">&quot;1s&quot;</span>,</span><br><span class="line">            Interval: <span class="string">&quot;5s&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 把 gRPC 服务注册到 Consul 上</span></span><br><span class="line">    err = consulObj.Agent().ServiceRegister(&amp;reg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gRPC 操作</span></span><br><span class="line">    grpcServer := grpc.NewServer()</span><br><span class="line">    pb.RegisterHelloServer(grpcServer, <span class="built_in">new</span>(Children))</span><br><span class="line"></span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8800&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(listener net.Listener)</span></span> &#123;</span><br><span class="line">        err := listener.Close()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(listener)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;服务启动...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    err = grpcServer.Serve(listener)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>修改客户端代码</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/hashicorp/consul/api&quot;</span></span><br><span class="line">    <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">    <span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">    <span class="string">&quot;src/src/Consul/GRPC/pb&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Consul 对象</span></span><br><span class="line">    consulObj, err := api.NewClient(api.DefaultConfig())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从 consul 上获取健康的服务</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    func (h *Health) Service(service, tag string, passingOnly bool, q *QueryOptions) ([]*ServiceEntry, *QueryMeta, error)</span></span><br><span class="line"><span class="comment">    - 参数：</span></span><br><span class="line"><span class="comment">    service: 服务名。 -- 注册服务时，指定该string</span></span><br><span class="line"><span class="comment">    tag：标签名/别名。 如果有多个， 任选一个</span></span><br><span class="line"><span class="comment">    passingOnly：是否通过健康检查。 true</span></span><br><span class="line"><span class="comment">    q：额外查询参数。 通常传 nil</span></span><br><span class="line"><span class="comment">    - 返回值：</span></span><br><span class="line"><span class="comment">    ServiceEntry： 存储服务的切片。</span></span><br><span class="line"><span class="comment">    QueryMeta：额外查询返回值。 nil</span></span><br><span class="line"><span class="comment">    error： 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    services, _, err := consulObj.Health().Service(<span class="string">&quot;gRPC And Consul&quot;</span>, <span class="string">&quot;grpc&quot;</span>, <span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可在此引入负载均衡算法</span></span><br><span class="line">    ipAddr := services[<span class="number">0</span>].Service.Address + <span class="string">&quot;:&quot;</span> + strconv.Itoa(services[<span class="number">0</span>].Service.Port)</span><br><span class="line"></span><br><span class="line">    dial, err := grpc.Dial(ipAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grpcClient := pb.NewHelloClient(dial)</span><br><span class="line">    person := pb.Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;Kevin&quot;</span>,</span><br><span class="line">        Age:  <span class="number">22</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newPerson, err := grpcClient.SayHello(context.TODO(), &amp;person)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(newPerson)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过指令 <code>consul agent -dev</code> 直接以 dev 模式启动 Consul ，然后先后启动服务端与客户端。在客户端看到输出：<code>name:&quot;hello Kevin&quot;  age:22</code>，并且在 Consul 控制台中看到输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-10-15T15:19:18.385+0800 [DEBUG] agent.http: Request finished: method=GET url=/v1/health/service/gRPC%20And%20Consul?passing=1&amp;tag=grpc from=127.0.0.1:65497 latency=2.0771ms</span><br></pre></td></tr></table></figure></li></ol><p>以上，说明我们成功将 gRPC 服务注册到 Consul 上。在 <code>127.0.0.1:8800</code> 的仪表板上也能看到名字为 <code>gRPC And Consul</code> 的服务。</p><h4 id="服务注销"><a href="#服务注销" class="headerlink" title="服务注销"></a>服务注销</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/hashicorp/consul/api&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 1. 创建 consul 对象</span></span><br><span class="line">consulObj, _ := api.NewClient(api.DefaultConfig())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 注销服务</span></span><br><span class="line">consulObj.Agent().ServiceDeregister(<span class="string">&quot;Faceid&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Consul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 的拷贝机制</title>
      <link href="/2022/10/54fab998.html"/>
      <url>/2022/10/54fab998.html</url>
      
        <content type="html"><![CDATA[<p>在做 LeetCode <a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a> 的时候因为一个 Python 列表的拷贝操作导致险些超时。为此特地在此记录一下我所了解到的 Python 拷贝机制。</p><h2 id="Python-拷贝类型"><a href="#Python-拷贝类型" class="headerlink" title="Python 拷贝类型"></a>Python 拷贝类型</h2><ul><li><strong>直接赋值(&#x3D;)：</strong> 即对象的引用（可以理解为别名）。</li><li><strong>浅拷贝(copy)：</strong> 拷贝指定对象，不会拷贝对象的内部的子对象。</li><li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了目标对象及其子对象。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/449252961">Python中的深拷贝与浅拷贝</a> 这篇文章的图例很形象地描述了三种拷贝类型的差别</p><ol><li><p>直接赋值</p><p> <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/gPLUNra6VQ1ZjSF.jpg" alt="直接赋值"></p></li><li><p>浅拷贝</p><p> <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/dSjXsQbARDT5yCB.jpg" alt="浅拷贝"></p></li><li><p>深拷贝</p><p> <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/XBhSZPmWuRLzJOj.jpg" alt="深拷贝"></p></li></ol><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><p>Python 没有指针的概念，但 Python 的赋值操作就类似于新增一个指向原变量内存地址的指针。考虑操作<code>b = a</code>，这是一个赋值引用，对象 a 与 b 的变化完全同步。</p><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>对于基本数据类型（如 int），Python 实际上采用的是引用计数的机制。无论是怎样进行赋值或拷贝，只要是相同的值，就会指向同一个内存地址，实际上这时就是增加了一个引用计数。即使是直接赋值，只要值相同，也是与先前相同的内存地址。一旦值不同，内存地址就不同。因此本文主要讨论的是较为复杂的复合对象的拷贝。</p><p>Python 的部分复杂内建类型具有<code>.copy()</code>方法，该方法能返回此对象的浅拷贝。更一般的方法是在<code>copy</code>包中使用<code>copy()</code>方法创建对象的浅拷贝。同样地，对象的深拷贝需要在<code>copy</code>包中使用<code>deepcopy()</code>方法创建。</p><p><a href="https://docs.python.org/zh-cn/3/library/copy.html">Python 官方文档</a>对两种拷贝机制的解释如下：</p><blockquote><p>浅层与深层复制的区别仅与复合对象（即包含列表或类的实例等其他对象的对象）相关：</p><ul><li><strong>浅层复制</strong> 构造一个新的复合对象，然后（在尽可能的范围内）将原始对象中找到的对象的 <em>引用</em> 插入其中。</li><li><strong>深层复制</strong> 构造一个新的复合对象，然后，递归地将在原始对象里找到的对象的 <em>副本</em> 插入其中。</li></ul></blockquote><p>然而，深拷贝相对来说会引发一些额外的问题（也是我在做题时遇到的）：</p><blockquote><p>深度复制操作通常存在两个问题, 而浅层复制操作并不存在这些问题：</p><ul><li>递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环。</li><li>由于深层复制会复制所有内容，因此可能会过多复制（例如本应该在副本之间共享的数据）。</li></ul></blockquote><p>因此在使用深拷贝时应当慎重，必要时能使用浅拷贝就使用浅拷贝</p><h2 id="额外注意：列表的浅拷贝"><a href="#额外注意：列表的浅拷贝" class="headerlink" title="额外注意：列表的浅拷贝"></a>额外注意：列表的浅拷贝</h2><p><a href="#%E6%8B%B7%E8%B4%9D">前文</a>提到，作为复杂数据结构对象，<code>List</code>是具有内建函数<code>copy()</code>的，但 <a href="https://docs.python.org/zh-cn/3/library/copy.html">Python 官方文档</a>还提到了一种列表的浅拷贝方法：利用切片。如果需要深入了解 Python 切片的用法，可以<a href="https://stackoverflow.com/questions/509211/understanding-slicing">看这里</a>。官方文档原文如下：</p><blockquote><p>制作列表的浅层复制可以通过赋值整个列表的切片完成，例如，<code>copied_list = original_list[:]</code>。</p></blockquote><p>这句话仔细看较难理解。注意到 Python 中的切片操作实际上返回的不是列表对象，而是一种特殊的切片对象<code>slice</code>，在 Python <a href="https://docs.python.org/zh-cn/3/library/functions.html#slice">内建函数文档</a>中特别指出了这点:</p><blockquote><p><code>class slice(stop)</code></p><p><code>class slice(start, stop[, step])</code></p><p>返回一个 <code>slice</code> 对象，代表由 <code>range(start, stop, step)</code> 指定索引集的切片。 其中参数 <code>start</code> 和 <code>step</code> 的默认值为 <code>None</code>。切片对象具有只读数据属性 <code>start</code> 、<code>stop</code> 和 <code>step</code>，只是返回对应的参数值（或默认值）。这几个属性没有其他明确的功能；不过 NumPy 和其他第三方扩展会用到。在使用扩展索引语法时，也会生成切片对象。例如： <code>a[start:stop:step]</code> 或 <code>a[start:stop, i]</code>。 另一种方案是返回迭代器对象，可参阅 <a href="https://docs.python.org/zh-cn/3/library/itertools.html#itertools.islice">itertools.islice()</a> 。</p></blockquote><p>然而经常使用 Python 列表切片的人都知道，我们是几乎感知不到 <code>slice</code> 对象的存在的：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/HWaLrCb9FNhDQSi.png" alt="列表切片只会返回列表对象"></p><p>这也就是说在列表对象进行切片操作时，在生成<code>slice</code> 对象后立刻就将其转为了一个新的<code>List</code>对象。然而这个对象仍然和原列表对象具有共享子类&#x2F;共享部分资源的关系，否则无法解释其能够实现生成原列表对象浅拷贝的功能。</p><p>背后的原理我还不甚清楚，希望有相关知识的朋友能给出解答。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 微服务实战 - 1. 简要介绍与RPC</title>
      <link href="/2022/10/e95625c.html"/>
      <url>/2022/10/e95625c.html</url>
      
        <content type="html"><![CDATA[<p>云原生（<a href="https://learn.microsoft.com/zh-cn/dotnet/architecture/cloud-native/definition">Cloud Native</a>）方向很难避开和 Golang，即 Go 语言的接触。我的目标是对云原生技术有一个比较系统的了解，为此需要对 Go 有一定的熟练度。以我的经验来看，要从零开始了解一个语言，最快最高效的方式就是用它做一个实践项目出来。尽管已经有无数前辈提醒我，实现系统在研究生阶段属于低级产出，但我认为作为一个练手的方式，用从未接触的语言实现一个完整的可行系统还是有很大的学习意义的。</p><p>该项目来源于网络上的<a href="https://www.bilibili.com/video/BV1po4y1X7hH">相关教程</a>。在完整实现后，我应该会在另一篇文章中通过将该项目“上云”来实现对云原生关键工具 <a href="https://kubernetes.io/">Kubernetes</a> 的进一步了解。</p><p>关于 Golang 的基本语法我基本不会大篇幅说明，但在原教程中前半部分都是相关内容，需要的朋友可以进行参考。而即使是在本文中的大部分内容，在 Golang 的<a href="https://studygolang.com/pkgdoc">文档</a>中也能搜索到</p><p>将会根据实现进度实时更新，内容将分为多篇文章。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC 协议，即Remote Procedure Call Protocol （远程过程调用协议）。它主要用于远程进程通信，在 TCP&#x2F;IP 模型上属于应用层协议（ http 协议同层），其底层使用 TCP 实现。</p><p>通过 RPC 协议，进程能够<strong>像调用本地函数一样，去调用远程函数</strong>。通过 RPC 协议，能够向服务端传递函数名、函数参数。达到在客户端调用远端函数，取得返回值到本地的目标。这能够契合微服务之间高隔离性的特点，即不同的微服务都是在不同的进程甚至虚拟机（VM），运行在差异较大的生产环境中（例如不同语言编写的程序直接的通信）。</p><h3 id="RPC使用步骤"><a href="#RPC使用步骤" class="headerlink" title="RPC使用步骤"></a>RPC使用步骤</h3><ul><li><p>服务端：</p><ol><li><p>注册 rpc 服务对象，给对象绑定方法</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rpc.RegisterName(<span class="string">&quot;服务名&quot;</span>，回调对象)</span><br><span class="line"><span class="comment">// 函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span></span> RegisterName(name <span class="type">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  参1：服务名。字符串类型。</span></span><br><span class="line"><span class="comment">  参2：对应 rpc 对象。 该对象绑定方法要满足如下条件：</span></span><br><span class="line"><span class="comment">  1）方法必须是导出的，(可以理解为 Java 中的 public ），go 中的首字母大写方法。</span></span><br><span class="line"><span class="comment">  2）方法必须有两个参数，都是导出类型（type定义的类型）、內建类型（go内置类型）。</span></span><br><span class="line"><span class="comment">  3）方法的第二个参数必须是 “指针” （作为传出参数）</span></span><br><span class="line"><span class="comment">  4）方法只有一个 error 接口类型的返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例，以下方法 HelloWorld 是符合要求的被绑定函数。</span></span><br><span class="line"><span class="comment">// 注意到尽管业务上可能只关注这个函数，</span></span><br><span class="line"><span class="comment">// 但是 RegisterName/Register 方法的参数需要传入该函数所绑定的对象（即 World ）</span></span><br><span class="line"><span class="comment">// 而不是函数 HelloWorld 本身</span></span><br><span class="line"><span class="comment">// 在此例中可以把 HelloWorld 函数理解为回调函数</span></span><br><span class="line">  <span class="keyword">type</span> World stuct &#123;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(this *World)</span></span> HelloWorld (name <span class="type">string</span>, resp *<span class="type">string</span>) <span class="type">error</span> &#123; </span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  rpc.RegisterName(<span class="string">&quot;服务名&quot;</span>， <span class="built_in">new</span>(World))</span><br></pre></td></tr></table></figure></li><li><p>创建监听器</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listener, err := net.Listen()</span><br></pre></td></tr></table></figure></li><li><p>建立连接</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := listener.Accept()</span><br></pre></td></tr></table></figure></li><li><p>将连接绑定 rpc 服务。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpc.ServeConn(conn)</span><br><span class="line"><span class="comment">// 函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span></span> ServeConn(conn io.ReadWriteCloser)</span><br><span class="line"><span class="comment">// conn: 成功建立好连接的 socket</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>客户端：</p><ol><li><p>用 rpc 连接服务器。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := rpc.Dial()</span><br></pre></td></tr></table></figure></li><li><p>调用远程函数。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conn.Call(<span class="string">&quot;服务名.方法名&quot;</span>, 传入参数, 传出参数)</span><br><span class="line"><span class="comment">// 函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span></span> Call(serviceMethod <span class="type">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  serviceMethod: “服务名.方法名”</span></span><br><span class="line"><span class="comment">  args：传入参数。方法需要的数据。</span></span><br><span class="line"><span class="comment">  reply：传出参数。定义 var 变量，&amp;变量名（取地址）完成传参。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="RPC实践"><a href="#RPC实践" class="headerlink" title="RPC实践"></a>RPC实践</h3><p>编写一个简易客户端&#x2F;服务端实现RPC的函数调用</p><ul><li>服务端</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RpcObject <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(obj *RpcObject)</span></span> Hello(content <span class="type">string</span>, resp *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">*resp = <span class="string">&quot;Hello &quot;</span> + content</span><br><span class="line">    <span class="comment">// return errors.New(&quot;unknown error&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 注册RPC</span></span><br><span class="line">err := rpc.RegisterName(<span class="string">&quot;test&quot;</span>, <span class="built_in">new</span>(RpcObject))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8838&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(listener net.Listener)</span></span> &#123;</span><br><span class="line">err := listener.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(listener)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">err := conn.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定服务</span></span><br><span class="line">rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rpcConn, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8838&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(rpcConn *rpc.Client)</span></span> &#123;</span><br><span class="line">err := rpcConn.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(rpcConn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ans <span class="type">string</span></span><br><span class="line">err = rpcConn.Call(<span class="string">&quot;test.Hello&quot;</span>, <span class="string">&quot;Me&quot;</span>, &amp;ans)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先运行服务端，然后运行客户端，服务端应当输出如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Me</span><br></pre></td></tr></table></figure><blockquote><p>注意，RPC 使用了 Go 特有的 gob 序列化，因此如果需要使用 Go 与不同语言微服务应用进行 RPC 通信，需要使用通用的序列化&#x2F;反序列化方式，例如 Json</p></blockquote><p>进行如下修改，可以使用 Json 对 RPC 通信进行序列化</p><ul><li>服务端</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定服务</span></span><br><span class="line"><span class="comment">// rpc.ServeConn(conn)</span></span><br><span class="line">jsonrpc.ServeConn(conn)</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpcConn, err := rpc.Dial(&quot;tcp&quot;, &quot;:8838&quot;)</span></span><br><span class="line">   <span class="comment">// Go 序列化方式特殊，容易乱码</span></span><br><span class="line">rpcConn, err := jsonrpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8838&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="RPC封装"><a href="#RPC封装" class="headerlink" title="RPC封装"></a>RPC封装</h3><p><strong>背景</strong>：<a href="#RPC%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">上文</a>提到了， RPC 注册对象绑定的函数（例中<code>Hello()</code>）需要两个参数。然而实际使用中，<code>Hello()</code>即使只有一个或没有参数，也不会在编译时报错，却会在 RPC 对象注册位置运行时报错（猜测原因是<code>RegisterName</code>方法底层使用了反射机制）。我们需要服务端在注册对象时，在程序编译阶段就能检测出注册对象是否合法。</p><p>通过 Go 的多态，声明一个接口<code>RPCRegisterInterface</code>，绑定类（即例中<code>RpcObject</code>）必须实现该方法（即例子中的回调函数<code>Hello</code>必须符合该接口规范）。同时将 RPC 注册过程封装为函数<code>RPCRegisterService</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCRegisterInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Hello(<span class="type">string</span>, *<span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RPCRegisterService</span><span class="params">(serviceName <span class="type">string</span>, i RPCRegisterInterface)</span></span> &#123;</span><br><span class="line">err := rpc.RegisterName(serviceName, i)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册 RPC 类的过程更改如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// err := rpc.RegisterName(&quot;test&quot;, new(RpcObject))</span></span><br><span class="line"><span class="comment">// if err != nil &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(err)</span></span><br><span class="line"><span class="comment">// return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RpcObject 对象必须实现 RPCRegisterInterface 接口</span></span><br><span class="line"><span class="comment">// 否则此行函数调用在编译时报错</span></span><br><span class="line">err := RPCRegisterService(<span class="string">&quot;test&quot;</span>, <span class="built_in">new</span>(RpcObject))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端封装内容略</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>本文只说明 Go 环境下 gRPC 的安装，官方安装指引<a href="https://grpc.io/docs/languages/go/quickstart/">点此</a></p><ol><li><p>安装 Protocol Buffer 3，<a href="https://github.com/protocolbuffers/protobuf/releases">地址点此</a>。根据操作系统，而<strong>不要</strong>根据语言下载 Protocol Buffer 。解压后只有一个可执行文件，将其放在任意你喜欢的位置，并将该目录<strong>添加进环境变量</strong>。</p></li><li><p>项目中分别安装 go 的 Protocol Buffer 和 gRPC 插件</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install google.golang.org/protobuf/cmd/protoc-gen-<span class="keyword">go</span>@v1<span class="number">.28</span></span><br><span class="line"><span class="keyword">go</span> install google.golang.org/grpc/cmd/protoc-gen-<span class="keyword">go</span>-grpc@v1<span class="number">.2</span></span><br></pre></td></tr></table></figure></li><li><p>若 <code>go.mod</code> 中有以下语句则说明安装完成</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require (</span><br><span class="line">google.golang.org/grpc/cmd/protoc-gen-<span class="keyword">go</span>-grpc v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">google.golang.org/protobuf v1<span class="number">.28</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h3><p><code>protobuf</code> (Protocol Buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。竞争对手有 <code>json</code>，<code>xml</code>等。</p><h4 id="protobuf-文件示例"><a href="#protobuf-文件示例" class="headerlink" title="protobuf 文件示例"></a>protobuf 文件示例</h4><p>用一个例子说明 protobuf 的格式。创建 <code>pb.person.proto</code> 文件，文件内容如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileName: tutorial.person.proto </span></span><br><span class="line"><span class="comment">// 通常文件名建议命名格式为 包名.消息名.proto </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示正在使用proto2命令</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//包声明，tutorial 也可以声明为二级类型。</span></span><br><span class="line"><span class="comment">//例如a.b，表示a类别下b子类别</span></span><br><span class="line"><span class="keyword">package</span> tutorial; </span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器将生成一个名为person的类</span></span><br><span class="line"><span class="comment">//类的字段信息包括姓名name,编号id,邮箱email，</span></span><br><span class="line"><span class="comment">//以及电话号码phones</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;  <span class="comment">// (位置1)</span></span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;  </span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;  <span class="comment">// (位置2)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">PhoneType</span> &#123;  </span><br><span class="line"><span class="comment">//电话类型枚举值 </span></span><br><span class="line"><span class="comment">//枚举需要从0开始</span></span><br><span class="line">    MOBILE = <span class="number">0</span>;  <span class="comment">//手机号  </span></span><br><span class="line">    HOME = <span class="number">1</span>;    <span class="comment">//家庭联系电话</span></span><br><span class="line">    WORK = <span class="number">2</span>;    <span class="comment">//工作联系电话</span></span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//电话号码phone消息体</span></span><br><span class="line">  <span class="comment">//组成包括号码number、电话类型 type</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> number = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">optional</span> PhoneType type = </span><br><span class="line">          <span class="number">2</span> [default = HOME]; <span class="comment">// (位置3)</span></span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">4</span>; <span class="comment">// (位置4)</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通讯录消息体，包括一个Person类的people</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">AddressBook</span> &#123; </span><br><span class="line">  <span class="keyword">repeated</span> Person people = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h4><ul><li><strong>消息体</strong>：protobuf 中定义一个消息类型是通过关键字 <code>message</code> 字段指定的，这个关键字类似于 C++&#x2F;Java 中的 class 关键字。</li><li><strong>包声明</strong>：<code>.proto</code> 文件以 package 声明开头，这有助于防止不同项目之间命名冲突。</li><li><strong>字段规则</strong>：<ul><li><code>required</code> ：消息体中必填字段，不设置会导致编解码异常。</li><li><code>optional</code> ：消息体中可选字段，可通过 default 关键字设置默认值。</li><li><code>repeated</code> ：消息体中可重复字段，重复的值的顺序会被保留，常用于保存数组。其中，proto3 默认使用 packed 方式存储，这样编码方式比较节省内存。</li></ul></li><li><strong>标识号</strong>：在消息体的定义中，每个字段都必须要有一个唯一的标识号，标识号是 [0, 2^29 - 1] 范围内的一个整数。以 Person 为例，name&#x3D;1，id&#x3D;2, email&#x3D;3, phones&#x3D;4 中的1-4就是标识号。</li></ul><h3 id="gRPC-实战"><a href="#gRPC-实战" class="headerlink" title="gRPC 实战"></a>gRPC 实战</h3><p>详见 <a href="https://alrisha.cn/2022/10/59b8323d.html">Golang 微服务实战 - 2. Consul</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下通过 docker + frrouting 构建bgp路由拓扑</title>
      <link href="/2022/10/3959450b.html"/>
      <url>/2022/10/3959450b.html</url>
      
        <content type="html"><![CDATA[<p>实验室项目要求我要在一个 bgp 路由拓扑上做路由数据的采集，前脚刚走的学长就留了一个文档，剩下的只能让我自己来搞了。学长的文档还是挺详细的，但是拓扑构建的过程蛮复杂，在这里详细的记录一下，以防以后又要重新弄或者要交给学弟学妹的时候全忘光了</p><p>路由拓扑图如下：</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/hxUciQnC2ZDz4lb.png" alt="路由拓扑"></p><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ul><li>Windows 11</li><li>WSL2 (Ubuntu)</li><li>Docker Desktop</li><li>Frrouting (Docker image)</li><li>Open vSwitch</li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h3><p>WSL2 在 Windows 商店中直接下载 Ubuntu 即可，然后按照提示配置安装，基本不会遇到什么问题。</p><p>之所以要在这里提到 WSL 是因为我还是想在这里推广一下我们的<strong>北邮源</strong>，北邮源其实是清华源的镜像（没错，镜像的镜像），内容更新一样快但因为用的人少所以速度也非常快。如果你是 Ubuntu 22 LTS，只需要把 <code>/etc/apt/source.list</code> 中内容替换为如下内容即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">deb-src https://mirrors.bupt.edu.cn/ubuntu/ jammy main restricted</span><br><span class="line"></span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy main restricted</span><br><span class="line">deb-src https://mirrors.bupt.edu.cn/ubuntu/ jammy multiverse universe</span><br><span class="line"></span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy-updates main restricted</span><br><span class="line">deb-src https://mirrors.bupt.edu.cn/ubuntu/ jammy-updates restricted multiverse universe main</span><br><span class="line"></span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy universe</span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy-updates universe</span><br><span class="line"></span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy multiverse</span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy-updates multiverse</span><br><span class="line"></span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.bupt.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy-security main restricted</span><br><span class="line">deb-src https://mirrors.bupt.edu.cn/ubuntu/ jammy-security restricted</span><br><span class="line"></span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy-security universe</span><br><span class="line">deb https://mirrors.bupt.edu.cn/ubuntu/ jammy-security multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你也可以直接运行下面的代码，更方便的替换源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s#http://archive.ubuntu.com/#http://mirrors.bupt.edu.cn/#g&#x27;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>相信我，速度真的很快</p><h3 id="Docker-Desktop"><a href="#Docker-Desktop" class="headerlink" title="Docker Desktop"></a>Docker Desktop</h3><p>直接到<a href="https://hub.docker.com/">官网</a>下载 Windows 版本即可。然后需要在 WSL 已经安装的前提下，打开 <code>Setting - Resources - WSL Integration</code> ，打勾和开关全部拉满。</p><p>最后是 Docker 下载镜像也需要换源。网络上很多教程经常提到中科院的 Docker 源，但是现在这玩意已经变成他们校内资源了，所以还是推荐使用网易和<a href="https://cr.console.aliyun.com/">阿里云自注册</a>的 Docker 源。Docker Desktop 的换源位置在 <code>Setting - Docker Engine</code> 的 json 文件中，加入如下内容即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;https://xxxxxx.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p><strong>xxxxxx</strong> 的内容是你在阿里云中注册就能免费拿到的，还是挺靠谱的</p><h3 id="Open-vSwitch"><a href="#Open-vSwitch" class="headerlink" title="Open vSwitch"></a>Open vSwitch</h3><p>我发现网上的 Open vSwitch（以下简称 ovs）安装教程基本都是通过源码安装的，即使是学长给我的文档也是这样。源码安装不仅麻烦还得搭配各种奇怪的环境，非常费时费力。我上 Google 查一下，原来 apt 能直接傻瓜安装，真的搞不懂为什么这么多人喜欢捣鼓这东西的源码安装</p><p>在 WSL 里直接运行如下指令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openvswitch-switch</span><br></pre></td></tr></table></figure><p>然后用<code>ovs-vswitchd --version</code>检查是否安装成功就行了</p><h3 id="Frrouting"><a href="#Frrouting" class="headerlink" title="Frrouting"></a>Frrouting</h3><p>由于要搭建拓扑，需要通过 Docker 模拟多个路由器，所以只需要安装 Frrouting 的镜像就行了。而这玩意百度一搜，国内的什么简书、csdn 各大高手的教程又开始源码安装了。我反手 Google 一下，第一页就是 <a href="https://hub.docker.com/r/frrouting/frr">Docker 官网</a>，里面直接告诉我一条命令就能搞定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull frrouting/frr</span><br></pre></td></tr></table></figure><p>到此环境就配置完了，别看这部分这么简单，如果只看国内这些“大神”们的教程，能给你配一整天。</p><h2 id="拓扑环境搭建"><a href="#拓扑环境搭建" class="headerlink" title="拓扑环境搭建"></a>拓扑环境搭建</h2><p>对于一台计算机来说，只要它启动了<code>bgpd</code>守护进程，那么它即可承担 BGP 路由器的全部功能。目前 BGP 协议的开源实现主要就是 C-BGP 和 FRRouting 。每台计算机上只能跑一个 <code>bgpd</code> 进程，但使用 Docker 可以实现多机虚拟化，且 FRRouting 提供了封装好的 Docker 镜像，所以推荐使用 FRRouting 。这种情况下，一台机器上的每一个 FRRouting 的 Docker 实例就可以看做是一个独立的虚拟机，每个虚拟机上仅运行了 <code>bgpd</code> 进程及其依赖的进程。</p><p>但如果直接在一台机器上跑多个 FRRouting 的 Docker 容器的话，是无法看到 AS 路径的，因为这种情况下，所有的 Docker 实例均在同一个网段下，是可以直连通信的，无法模拟域间路由下的“多跳”环境。</p><p>这要求我们实现一个模拟域间路由下“多跳”的方式：手动将这些 AS 划分到不同的子网下。这需要使用 Open vSwitch 的网桥相关的功能。编写一个脚本文件<code>ovs.sh</code>，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Direct Connect Between Routes</span></span><br><span class="line"><span class="comment"># 使用ovs创建一个网桥/交换机 命名为brConn</span></span><br><span class="line">ovs-vsctl add-br brConn</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Prefix Block</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LINK BETWEEN AS65531 - AS65533</span></span><br><span class="line">ovs-docker add-port brConn ethTo65533 AS65531 --ipaddress=100.100.7.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65531 AS65533 --ipaddress=100.100.7.2/30</span><br><span class="line"><span class="comment"># LINK BETWEEN AS65531 - AS65534</span></span><br><span class="line">ovs-docker add-port brConn ethTo65534 AS65531 --ipaddress=100.100.8.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65531 AS65534 --ipaddress=100.100.8.2/30</span><br><span class="line"><span class="comment"># LINK BETWEEN AS65532 - AS65533</span></span><br><span class="line">ovs-docker add-port brConn ethTo65533 AS65532 --ipaddress=100.100.9.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65532 AS65533 --ipaddress=100.100.9.2/30</span><br><span class="line"><span class="comment"># LINK BETWEEN AS65532 - AS65534</span></span><br><span class="line">ovs-docker add-port brConn ethTo65534 AS65532 --ipaddress=100.100.10.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65532 AS65534 --ipaddress=100.100.10.2/30</span><br><span class="line"><span class="comment"># LINK BETWEEN AS65533 - AS65534</span></span><br><span class="line">ovs-docker add-port brConn ethTo65534 AS65533 --ipaddress=100.100.11.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65533 AS65534 --ipaddress=100.100.11.2/30</span><br><span class="line"><span class="comment"># LINK BETWEEN AS65533 - AS65535</span></span><br><span class="line">ovs-docker add-port brConn ethTo65535 AS65533 --ipaddress=100.100.12.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65533 AS65535 --ipaddress=100.100.12.2/30</span><br><span class="line"><span class="comment"># LINK BETWEEN AS65534 - AS65535</span></span><br><span class="line">ovs-docker add-port brConn ethTo65535 AS65534 --ipaddress=100.100.13.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65534 AS65535 --ipaddress=100.100.13.2/30</span><br><span class="line"><span class="comment"># LINK BETWEEN AS65536 - AS65531</span></span><br><span class="line">ovs-docker add-port brConn ethTo65531 AS65536 --ipaddress=100.100.14.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65536 AS65531 --ipaddress=100.100.14.2/30</span><br><span class="line"><span class="comment"># LINK BETWEEN AS65536 - AS65532</span></span><br><span class="line">ovs-docker add-port brConn ethTo65532 AS65536 --ipaddress=100.100.15.1/30</span><br><span class="line">ovs-docker add-port brConn ethTo65536 AS65532 --ipaddress=100.100.15.2/30</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VALID PREFIX BLOCK BETWEEN EACH AS.</span></span><br><span class="line">ovs-docker add-port brConn eth1 AS65531 --ipaddress=104.193.81.1/24</span><br><span class="line">ovs-docker add-port brConn eth1 AS65532 --ipaddress=104.193.82.1/24</span><br><span class="line">ovs-docker add-port brConn eth1 AS65533 --ipaddress=104.193.83.1/24</span><br><span class="line">ovs-docker add-port brConn eth1 AS65534 --ipaddress=104.193.84.1/24</span><br><span class="line">ovs-docker add-port brConn eth1 AS65536 --ipaddress=104.193.86.1/24</span><br></pre></td></tr></table></figure><p>这个脚本首先创建了一个网桥 brConn（可以将它简单理解为一个交换机）。第二部分内容就是使用 ovs 提供的接口，为 Docker 实例创建网卡，并将网卡全部挂接到同一个 brConn 网桥上。网卡名字为 <strong>eThTo****</strong> ，表示这个 Docker 实例中的这张网卡是为了去与哪个 Docker 进行直连通信。第三部分的内容是为 AS 设立它们的合法网络空间（或者说网络资源）。</p><p>注意到所有的网卡前缀长度均是 30 位，这意味着这个子网下只有两个 IP 地址是合法的（子网可用 2 位，最多有 4 个 IP 地址，扣除掉两位全为 0 的和两位全为 1 的非法地址），这两个 IP 地址分别作为具有直连关系的两个 AS 间的链路两端网卡的 IP 地址，这样就实现了网络隔离，换句话说，在上述拓扑示例图中，只有具有直连关系的 AS 是在同一个网段下的，可以相互通信，不具有直连关系的 AS 不再同一个网段内，不能直连通信。</p><p>接下来需要运行如下所示的<code>docker.sh</code>脚本，它启动了 6 个 FRRouting Docker 实例。默认情况下，FRRouting 的实例仅包括一个本地回路网卡和另一个 Docker 自带的网卡，这两个网卡都不是我们要用的。我们需要使用之前 ovs 创建的虚拟网卡。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Start Five Atonomous System Container</span></span><br><span class="line"><span class="comment"># 启动6个FRRouting容器</span></span><br><span class="line">docker run -itd --privileged --name AS65531 --net=none frrouting/frr /bin/bash</span><br><span class="line">docker run -itd --privileged --name AS65532 --net=none frrouting/frr /bin/bash</span><br><span class="line">docker run -itd --privileged --name AS65533 --net=none frrouting/frr /bin/bash</span><br><span class="line">docker run -itd --privileged --name AS65534 --net=none frrouting/frr /bin/bash</span><br><span class="line">docker run -itd --privileged --name AS65535 --net=none frrouting/frr /bin/bash</span><br><span class="line">docker run -itd --privileged --name AS65536 --net=none frrouting/frr /bin/bash</span><br></pre></td></tr></table></figure><p>另一个脚本是 <code>destroyAllTopo3.sh</code> ，会销毁掉 brConn 以及对应的网卡，并移除所有运行中的 Docker 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ovs-vsctl del-br brAS65531</span><br><span class="line">ovs-vsctl del-br brAS65532</span><br><span class="line">ovs-vsctl del-br brAS65533</span><br><span class="line">ovs-vsctl del-br brAS65534</span><br><span class="line">ovs-vsctl del-br brConn</span><br><span class="line">ovs-vsctl del-br br1To3</span><br><span class="line">ovs-vsctl del-br br1To4</span><br><span class="line">ovs-vsctl del-br br2To3</span><br><span class="line">ovs-vsctl del-br br2To4</span><br><span class="line">ovs-vsctl del-br br3To4</span><br><span class="line">ovs-vsctl del-br br3To5</span><br><span class="line">ovs-vsctl del-br br4To5</span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><h2 id="拓扑节点配置"><a href="#拓扑节点配置" class="headerlink" title="拓扑节点配置"></a>拓扑节点配置</h2><p>请<strong>严格</strong>按照如下顺序执行配置</p><ol start="0"><li>开启 ovs 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/share/openvswitch/scripts/ovs-ctl start</span><br></pre></td></tr></table></figure><ol><li>用 root 权限**<em>先后</em>**执行<code>docker.sh</code>和<code>ovs.sh</code>，创建出 6 个 Frrouting 实例</li><li>对于这 6 个实例（AS65531 ~ AS65536）中的每一个，使用命令<code>docker exec -it (ASN_NAME) bash</code>进入到实例中，然后对 6 个实例的每一个，执行下述命令，这三条命令会在容器中启动<code>bgpd</code>守护进程和<code>ospfd</code>守护进程。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/bgpd=no/bgpd=yes/g&#x27;</span> /etc/frr/daemons</span><br><span class="line">sed -i <span class="string">&#x27;s/ospfd=no/ospfd=yes/g&#x27;</span> /etc/frr/daemons</span><br><span class="line"><span class="built_in">nohup</span> /usr/lib/frr/frrinit.sh start &amp;</span><br></pre></td></tr></table></figure><ol start="3"><li>仍然使用<code>docker exec -it (ASN_NAME) bash</code>进入到实例中，对于 6 个实例的每一个，根据<code>ASN_NAME</code>的不同，拷贝下述命令到终端中并执行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AS65536</span></span><br><span class="line">vtysh</span><br><span class="line">config</span><br><span class="line">router bgp 65536</span><br><span class="line">neighbor 100.100.14.2 remote-as 65531</span><br><span class="line">neighbor 100.100.15.2 remote-as 65532</span><br><span class="line">network 104.193.86.1/24</span><br><span class="line">no bgp ebgp-requires-policy</span><br><span class="line">no bgp network import-check</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">write</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AS65531</span></span><br><span class="line">vtysh</span><br><span class="line">config</span><br><span class="line">router bgp 65531</span><br><span class="line">neighbor 100.100.7.2 remote-as 65533</span><br><span class="line">neighbor 100.100.8.2 remote-as 65534</span><br><span class="line">neighbor 100.100.14.1 remote-as 65536</span><br><span class="line">network 104.193.81.1/24</span><br><span class="line">no bgp ebgp-requires-policy</span><br><span class="line">no bgp network import-check</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">write</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AS65532</span></span><br><span class="line">vtysh</span><br><span class="line">config</span><br><span class="line">router bgp 65532</span><br><span class="line">neighbor 100.100.9.2 remote-as 65533</span><br><span class="line">neighbor 100.100.10.2 remote-as 65534</span><br><span class="line">neighbor 100.100.15.1 remote-as 65536</span><br><span class="line">network 104.193.82.1/24</span><br><span class="line">no bgp ebgp-requires-policy</span><br><span class="line">no bgp network import-check</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">write</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AS65533</span></span><br><span class="line">vtysh</span><br><span class="line">config</span><br><span class="line">router bgp 65533</span><br><span class="line">neighbor 100.100.7.1 remote-as 65531</span><br><span class="line">neighbor 100.100.9.1 remote-as 65532</span><br><span class="line">neighbor 100.100.11.2 remote-as 65534</span><br><span class="line">neighbor 100.100.12.2 remote-as 65535</span><br><span class="line">network 104.193.83.1/24</span><br><span class="line">no bgp ebgp-requires-policy</span><br><span class="line">no bgp network import-check</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">write</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AS65534</span></span><br><span class="line">vtysh</span><br><span class="line">config</span><br><span class="line">router bgp 65534</span><br><span class="line">neighbor 100.100.8.1 remote-as 65531</span><br><span class="line">neighbor 100.100.10.1 remote-as 65532</span><br><span class="line">neighbor 100.100.11.1 remote-as 65533</span><br><span class="line">neighbor 100.100.13.2 remote-as 65535</span><br><span class="line">network 104.193.84.1/24</span><br><span class="line">no bgp ebgp-requires-policy</span><br><span class="line">no bgp network import-check</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">write</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AS65535</span></span><br><span class="line">vtysh</span><br><span class="line">config</span><br><span class="line">router bgp 65535</span><br><span class="line">neighbor 100.100.12.1 remote-as 65533</span><br><span class="line">neighbor 100.100.13.1 remote-as 65534</span><br><span class="line">no bgp ebgp-requires-policy</span><br><span class="line">no bgp network import-check</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">write</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>这些命令首先会启动 vtysh 终端（这是一个现有的 BGP 协议通用的控制终端，大部分的 BGP 协议实现都会用这个相同的终端），然后将配置对应的 AS 号、通过给出的 IP 地址与邻居建立 Peer 关系，宣告自己的前缀，并设置了两个路由策略（<code>no ebgp-requires-policy</code>, <code>no bgp network import-check</code>），这两个策略是必须的，否则路由器会过滤掉路由宣告。</p><h2 id="拓扑实验"><a href="#拓扑实验" class="headerlink" title="拓扑实验"></a>拓扑实验</h2><h3 id="路由信息查看"><a href="#路由信息查看" class="headerlink" title="路由信息查看"></a>路由信息查看</h3><p>全部设置完毕后，随便找一个实例进入，启动 vtysh 终端，使用命令<code>show ip bgp</code>，会看到类似下图的 BGP 路由表；</p><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://s2.loli.net/2022/10/19/PJbmZqCs2IGXr58.png" alt="路由表示例"></p><p>而命令<code>show ip bgp summary</code>能看到 BGP 邻居表，具体细节可以看<a href="https://blog.csdn.net/u014007878/article/details/104577344">这里</a></p><p>需要注意的是，由于这个拓扑是静态的，因此第一次查看路由表应该只能看到本地路由，如果想看到整个拓扑的路由表请往下看。</p><h3 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h3><p>可以使用以下命令配置 Frrouting 的日志输出，通过查看日志及时 Debug：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /var/log/frr</span><br><span class="line"><span class="comment"># 必须将输出目录的用户/用户组设置为frr</span></span><br><span class="line"><span class="comment"># 如果不这么做，由于docker实例所挂载的文件系统下，所有文件的所有者都是root，frr会因为权限不足无法生成文件。</span></span><br><span class="line"><span class="built_in">chown</span> frr /var/log/frr/</span><br><span class="line">vtysh</span><br><span class="line">config</span><br><span class="line"><span class="built_in">log</span> file /var/log/frr/frr.log</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">write</span><br></pre></td></tr></table></figure><p>使用下述命令转储路由更新信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个frrouting的输出目录，并将这个目录的用户/用户组设置为frr</span></span><br><span class="line"><span class="comment"># 如果不这么做，由于docker实例中所有文件的所有者都是root，frr会因为权限不足无法生成文件。可以通过查看日志的方式去进行确认。</span></span><br><span class="line"><span class="comment"># 如果日志配置成功，但仍然无法dump出信息，可以去查看日志</span></span><br><span class="line"><span class="built_in">mkdir</span> /home/updates</span><br><span class="line"><span class="built_in">chown</span> frr updates</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入某个FRRouting实例后</span></span><br><span class="line">vtysh</span><br><span class="line">config</span><br><span class="line">dump bgp updates /home/updates/%Y%m%d-%H:%M:%S 30 // 每30sdump一次路由更新报文</span><br><span class="line"><span class="comment"># dump bgp all PATH 将会 dump 所有类型bgp报文</span></span><br><span class="line"><span class="comment"># dump bgp routes-mrt PATH 将会 dump 路由表</span></span><br></pre></td></tr></table></figure><p>上述命令只会 dump 路由更新报文（MRT 格式，需要<code>bgpdump</code>等工具进一步解析），由于拓扑是稳定的、不会更新的，因此大部分情况下输出的都是空文件，你可以选择一个 AS 去使用 network 命令宣告个长度大于等于 25 的前缀。注意这个宣告的前缀必须属于这个 AS 的合法前缀空间。例如 AS65536 拥有的网络资源为 <code>104.193.86.1/24</code>，那么在 AS65536 的 vtysh 终端就能使用命令<code>network 104.193.86.2/25</code>宣告一个合法的前缀。需要注意的是，<strong>至少发生一次路由宣告后</strong>，整个拓扑的路由表才会更新。</p><p>转储出的文件是存储在 docker 实例中的，由于默认的 docker 实例并没有挂载持久化存储，因此无法直接把转储出的文件从容器中转移到 WSL 上，需要在 root 权限下使用 <code>docker cp</code> 命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 2cd200541a0b:/home/updates/20220931-06:19:30 .</span><br></pre></td></tr></table></figure><p>这样以后就能把采集到的 BGP 路由数据存储到本地了</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> BGP </tag>
            
            <tag> Windows </tag>
            
            <tag> Frrouting </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
